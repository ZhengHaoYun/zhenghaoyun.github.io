<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="博客,编程,代码,Java,空间,记录">
    <meta name="description" content="郑皓云的个人博客,博客,编程,代码,Java,空间,记录">
    <meta name="author" content="Hoven">
    
    <title>
        
            JVM（一）内存与垃圾回收篇 |
        
        好运的云
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/favicon.png">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"zhenghaoyun.cn","root":"/","language":"zh-Hans","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.png","favicon":"/images/favicon.png","article_img_align":"center","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.2"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                好运的云
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">JVM（一）内存与垃圾回收篇</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Hoven</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2020-06-01 15:32:00
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/JVM/">JVM</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/JVM%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">JVM内存与垃圾回收</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>JVM的学习笔记分为四个篇章：</p>
<ol>
<li>JVM（一）内存与垃圾回收篇</li>
<li>JVM（二）字节码与类的加载篇</li>
<li>JVM（三）性能监控与调优篇</li>
<li>JVM（四）大厂面试篇</li>
</ol>
<p>学习视频来源：尚硅谷宋红康JVM教程</p>
<p>本篇为JVM（一）内存与垃圾回收篇</p>
<span id="more"></span>

<h1 id="一、JVM体系结构"><a href="#一、JVM体系结构" class="headerlink" title="一、JVM体系结构"></a>一、JVM体系结构</h1><p>先来了解两个概念，<strong>字节码</strong>和<strong>多语言混合编程</strong>。</p>
<h2 id="1-字节码"><a href="#1-字节码" class="headerlink" title="1. 字节码"></a>1. 字节码</h2><p>我们平时所说的java字节码是指用java语言编译成的字节码。<strong>准确的说任何能在jvm平台上执行的字节码格式都是一样的</strong>。所以应该统称为：<strong>jvm字节码</strong>。</p>
<p>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</p>
<h2 id="2-多语言混合编程"><a href="#2-多语言混合编程" class="headerlink" title="2. 多语言混合编程"></a>2. 多语言混合编程</h2><p>Java平台上的多语言混合编程正成为主流。</p>
<p>如一个项目：</p>
<ul>
<li>并行处理使用Cloujure</li>
<li>展示层使用JRuby/Rails</li>
<li>中间层则是Java</li>
</ul>
<p>每个应用层都将使用不同的编程语言来完成。</p>
<p><strong>原因：</strong>因为各种语言最终都运行在一个虚拟机上，所以各种语言之间的交互不存在任何困难，就像使用自己语言原生的API一样方便。</p>
<h2 id="3-虚拟机与Java虚拟机"><a href="#3-虚拟机与Java虚拟机" class="headerlink" title="3. 虚拟机与Java虚拟机"></a>3. 虚拟机与Java虚拟机</h2><blockquote>
<p> 在了解Java虚拟机前，你是否懂得虚拟机是什么？</p>
</blockquote>
<p>所谓虚拟机，就是一台虚拟计算机。它是一款<strong>软件</strong>，用来执行一些列虚拟计算机指令。</p>
<p>可以分为：</p>
<ul>
<li>系统虚拟机，如<strong>VMware</strong>就属于系统虚拟机，它完全是对物理计算机的仿真。</li>
<li>程序虚拟机，如<strong>Java虚拟机</strong>，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。</li>
</ul>
<blockquote>
<p>了解了虚拟机，继续了解Java虚拟机。</p>
</blockquote>
<p>JVM是Java Virtual Machine（Java虚拟机）的缩写，用来执行<strong>Java字节码</strong>。Java字节码又可以成为JVM字节码，引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p>
<p><strong>作用</strong></p>
<p>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。</p>
<p><strong>特点</strong></p>
<ol>
<li>一次编译，到处运行。</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ol>
<h2 id="4-JVM的位置"><a href="#4-JVM的位置" class="headerlink" title="4. JVM的位置"></a>4. JVM的位置</h2><p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200601160809.png" alt="Image"></p>
<p>从图中可以看出JVM没有和硬件打交道，它是运行在操作系统之上的。</p>
<h2 id="5-JVM的整体结构"><a href="#5-JVM的整体结构" class="headerlink" title="5. JVM的整体结构"></a>5. JVM的整体结构</h2><p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200601161251.jpg" alt="img"></p>
<center>JVM整体架构图</center>

<p>以上这个图为JVM整体架构图，之后的学习就是按照这个图来。</p>
<p><strong>补充：</strong></p>
<ul>
<li>Java栈是以前的叫法，现在叫做虚拟机栈。</li>
<li>方法区和堆是多线程共享的，Java堆、本地方法栈、程序计数器是每个线程独享的。</li>
<li>执行引擎的作用：操作系统只能识别机器指令，不能识别字节码指令，所以执行引擎的作用是翻译字节码指令。</li>
</ul>
<img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200601162424.png" alt="image-20200601162422306" style="zoom:50%;" />

<center>JVM架构详细图</center>

<h2 id="6-JVM的架构模型"><a href="#6-JVM的架构模型" class="headerlink" title="6. JVM的架构模型"></a>6. JVM的架构模型</h2><p>Java编译器输入的指令基本上是一种基于<strong>栈的指令集架构</strong>，另外一种指令架构则是基于<strong>寄存器的指令集架构。</strong><br>这两种架构之间的区别：</p>
<ul>
<li>栈式架构<ul>
<li>设计和实现简单</li>
<li>使用零地址指令方式分配（没有地址，只有操作数）从而避开了寄存器的分配难题，因为是采用栈式的，永远只对栈顶进行操作，所有是不需要地址的。</li>
<li>指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器更容易实现。</li>
<li>不需要硬件支持，<strong>可移植性更好</strong>，更好实现跨平台。</li>
</ul>
</li>
<li>寄存器架构<ul>
<li>典型的是x86的二进制指令集完全依赖硬件（指令要有CPU来执行），<strong>可移植性差</strong>。</li>
<li>性能优秀、执行更高效</li>
<li>栈式架构指令集小，但是指令多；寄存器架构指令集大，但是指令少。所以能够花费更好的指令去完成一项操作。</li>
<li>大部分情况下，寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同的平台CPU架构不同，所以不能设计基于寄存器的。  </li>
<li>栈式架构：跨平台、指令集小、指令多；执行性能比寄存器差。</li>
</ul>
<p><strong>实例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是三条java指令</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> k = i + j;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基于栈的计算流程，翻译成java字节码指令后，变成了8条。</span></span><br><span class="line"><span class="number">0</span> iconst_3</span><br><span class="line"><span class="number">1</span> istore_1</span><br><span class="line"><span class="number">2</span> iconst_2</span><br><span class="line"><span class="number">3</span> istore_2</span><br><span class="line"><span class="number">4</span> iload_1</span><br><span class="line"><span class="number">5</span> iload_2</span><br><span class="line"><span class="number">6</span> iadd</span><br><span class="line"><span class="number">7</span> istore_3</span><br><span class="line"><span class="number">8</span> <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//而基于寄存器的计算流程，只有2条指令。</span></span><br><span class="line">mov eax,<span class="number">2</span>	<span class="comment">//将eax寄存器的值设为2</span></span><br><span class="line">add eax,<span class="number">3</span>	<span class="comment">//将eax寄存器的值加3</span></span><br></pre></td></tr></table></figure>

<h2 id="7-JVM的生命周期"><a href="#7-JVM的生命周期" class="headerlink" title="7. JVM的生命周期"></a>7. JVM的生命周期</h2><p><strong>虚拟机的启动</strong></p>
<p>Java虚拟机的启动是通过引导类加载器（ bootstrap class loader）创建一个初始类（initial class）来完成的，这个类的名称我们不清楚，这个类是由虚拟机的具体实现指定的。</p>
<p>比如说你想要吃苹果，但是你没有苹果树，所以我们先种一棵苹果树，这个苹果树就是JVM。</p>
<p><strong>虚拟机的执行</strong></p>
<p>一个运行中的虚拟机有着清晰的任务，那就是执行Java代码。</p>
<p> 程序开始执行时他才开始运行，程序结束时他就停止。执行一个Java程序的时候，真真正正执行的是一个叫做Java虚拟机的进程。</p>
<p><strong>虚拟机的退出</strong></p>
<p>有以下几种情况会导致虚拟机退出：</p>
<ol>
<li>程序正常执行结束</li>
<li>遇到异常或者错误</li>
<li>操作系统错误导致Java虚拟机进程异常终止</li>
<li>调用System的exit方法或者Runtime类的halt方法，并且Java安全管理器也允许这次exit或者halt操作。</li>
</ol>
<h1 id="二、类加载子系统"><a href="#二、类加载子系统" class="headerlink" title="二、类加载子系统"></a>二、类加载子系统</h1><h2 id="1-内存结构概述"><a href="#1-内存结构概述" class="headerlink" title="1. 内存结构概述"></a>1. 内存结构概述</h2><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200601213922.png" alt="image-20200601213921809" style="zoom:50%;" />

<p>再来看看这张JVM架构细节图。通过这种图我们可以大概了解JVM的内存结构。</p>
<h2 id="2-类加载子系统的作用"><a href="#2-类加载子系统的作用" class="headerlink" title="2. 类加载子系统的作用"></a>2. 类加载子系统的作用</h2><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200601214118.png" alt="image-20200601214117793" style="zoom：80%;" />

<ol>
<li>类加载子系统负责从文件系统或 网络中加载clss文件，class文件在文件开头有特定的文件标识（CAFEBABE（咖啡宝贝？），后面会提到）。</li>
<li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</li>
<li>加载的类信息被存放于一块称为方法区的内存空间中，字节码文件是物理磁盘上的一个文件，类的加载器将字节码文件加载到内存中，生成Class的实例。</li>
<li>除了类的本身信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</li>
</ol>
<h2 id="3-类加载器ClassLoader角色"><a href="#3-类加载器ClassLoader角色" class="headerlink" title="3. 类加载器ClassLoader角色"></a>3. 类加载器ClassLoader角色</h2><p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200603164236.png" alt="Image"></p>
<ul>
<li>getClassLoader()获取加载去</li>
<li>Car Class调用构造器进行实例化，实例化出car1、car2、car3</li>
</ul>
<h2 id="4-类的加载过程"><a href="#4-类的加载过程" class="headerlink" title="4. 类的加载过程"></a>4. 类的加载过程</h2><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200603164519.png" alt="image-20200603164515825" style="zoom:50%;" />

<p>HelloLoader是一个类，目的是调用main()方法。</p>
<ol>
<li>要想调用main方法，首先检测HelloLoader是否装载，如果没有装载，就使用ClassLoader进行装载。</li>
<li>装载成功，生成对应的字节码文件HelloLoader.class</li>
<li>链接</li>
<li>初始化</li>
<li>调用main()</li>
</ol>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200603172437.png" alt="img"></p>
<center>类加载过程图</center>

<p>这个图是类的加载总过程，其中也有个加载，不过这个加载是类的加载过程中的一个“加载”过程，注意不要混淆。</p>
<p>接下来来讲讲具体的过程</p>
<h3 id="（1）加载"><a href="#（1）加载" class="headerlink" title="（1）加载"></a>（1）加载</h3><p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200603172514.png" alt="Image"></p>
<p><strong>补充：加载.class的方式</strong></p>
<ul>
<li>从本地系统中加载</li>
<li>网络获取，如：Web Applet</li>
<li>zip压缩包读取</li>
<li>运行时计算生成，如：动态代理</li>
<li>由其他文件生成，如：JSP</li>
<li>从专有数据库提取，比较少见</li>
<li>从加密文件中获取，反编译的保护措施</li>
</ul>
<h3 id="（2）链接"><a href="#（2）链接" class="headerlink" title="（2）链接"></a>（2）链接</h3><p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200603215648.png" alt="Image"></p>
<p><strong>验证</strong></p>
<p>检查class文件的头部是否有<code>cafebaby</code>的标识等等，用特定的软件可以看见。</p>
<p><strong>准备</strong></p>
<ol>
<li>为类变量赋值为0或者其他初值，再后来的<strong>初始化</strong>阶段再赋值为自定义的值。</li>
<li>final修饰的static直接被赋值为我们自定义的值，也就是显示初始化。</li>
<li>实例变量不会初始化</li>
</ol>
<p><strong>解析</strong></p>
<ol>
<li>符号引用 转化为 直接引用</li>
<li>直接引用就是直接指向目标的指针</li>
<li>在这里简要的阐述，后面会详细学习。</li>
<li>往往<strong>初始化</strong>之后执行</li>
</ol>
<h3 id="（3）初始化"><a href="#（3）初始化" class="headerlink" title="（3）初始化"></a>（3）初始化</h3><p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200603220717.png" alt="Image"></p>
<p><strong>补充说明：</strong></p>
<ol>
<li>clinit()是类的构造器方法，它会完成所有类变量的赋值动作和执行静态代码块。</li>
</ol>
<img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200603222050.png" alt="image-20200603222050037" style="zoom：67%;" />

<ol start="2">
<li>如果没有静态变量和静态代码块，就不会有clinit方法。</li>
<li>注意到还有个&lt;init&gt;，这个是我们自己定义的构造器方法，如<code>public Customer()&#123;&#125;</code></li>
<li>任何一个类都有对应的&lt;init&gt;</li>
</ol>
<h2 id="5-类加载器的分类"><a href="#5-类加载器的分类" class="headerlink" title="5. 类加载器的分类"></a>5. 类加载器的分类</h2><h3 id="（1）分类"><a href="#（1）分类" class="headerlink" title="（1）分类"></a>（1）分类</h3><ol>
<li><p>JVM支持两种类型的加载器，分别为<strong>引导类加载器C/C++实现（BootStrap ClassLoader）和自定义类加载器由Java实现</strong></p>
</li>
<li><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong>。</p>
</li>
</ol>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604121847.png" alt="Image"></p>
<ol start="3">
<li>上面的蓝色框内为引导类加载器，下面的蓝色框内皆为自定义类加载器。查看源码可以看到ExtClassLoader和AppClassLoader都派生于ClassLoader，所以他们都是自定义类加载器。</li>
<li>注意上图中的加载器划分关系为包含关系，并不是继承关系。</li>
</ol>
<p><strong>代码具体实践</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassLoader加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层  扩展类加载器</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@610455d6</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层 获取不到引导类加载器</span></span><br><span class="line">        ClassLoader bootStrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootStrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于用户自定义类来说：使用系统类加载器进行加载</span></span><br><span class="line">        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//String 类使用引导类加载器进行加载的  --&gt;java核心类库都是使用引导类加载器加载的</span></span><br><span class="line">        ClassLoader classLoader1 = String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//null获取不到间接证明了String 类使用引导类加载器进行加载的</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面代码我们发现个问题：获取引导类加载器返回的都是null！</p>
<p>原因是：这个类加载使用<strong>C/C++语言实现的</strong>，嵌套在JVM内部，所以我们是获取不到它的对象的。</p>
<h3 id="（2）虚拟机自带的加载器"><a href="#（2）虚拟机自带的加载器" class="headerlink" title="（2）虚拟机自带的加载器"></a>（2）虚拟机自带的加载器</h3><p><strong>启动类加载器（引导类加载器，BootStrap ClassLoader）</strong></p>
<p>1.这个类加载使用<strong>C/C++语言实现的</strong>，嵌套在JVM内部</p>
<p>2.它用来加载java的核心库（JAVA_HOME/jre/lib/rt.jar/resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</p>
<p>3.并不继承自java.lang.ClassLoader,没有父加载器</p>
<p>4.加载拓展类和应用程序类加载器，并指定为他们的父加载器，即ClassLoader</p>
<p>5.出于安全考虑，BootStrap启动类加载器只加载包名为java、javax、sun等开头的类（即只加载核心内库）</p>
<p><strong>拓展类加载器（Extension ClassLoader）</strong></p>
<p>1.<strong>java语言</strong>编写 ，由sun.misc.Launcher$ExtClassLoader实现。</p>
<p>2.派生于ClassLoader类</p>
<p>3.从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。<strong>如果用户创建的JAR放在此目录下，也会由拓展类加载器自动加载</strong></p>
<p><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong></p>
<ol>
<li><p>java语言编写， 由sun.misc.Launcher$AppClassLoader实现。</p>
</li>
<li><p>派生于ClassLoader类</p>
</li>
<li><p>它的父类加载器是扩展类加载器</p>
</li>
<li><p>它负责加载环境变量classpath或系统属性 java.class.path指定路径下的类库</p>
</li>
<li><p>该类加载器是程序中默认的类加载器，一般来说，java应用的类都是由它来完成加载</p>
</li>
<li><p>通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器</p>
</li>
</ol>
<p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 虚拟机自带加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;********启动类加载器*********&quot;</span>);</span><br><span class="line">        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="comment">//获取BootStrapClassLoader能够加载的api路径</span></span><br><span class="line">        <span class="keyword">for</span> (URL e:urls)&#123;</span><br><span class="line">            System.out.println(e.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从上面的路径中随意选择一个类 看看他的类加载器是什么</span></span><br><span class="line">        <span class="comment">//Provider位于 /jdk1.8.0_171.jdk/Contents/Home/jre/lib/jsse.jar 下，引导类加载器加载它</span></span><br><span class="line">        ClassLoader classLoader = Provider.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;********拓展类加载器********&quot;</span>);</span><br><span class="line">        String extDirs = System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String path ：extDirs.split(<span class="string">&quot;;&quot;</span>))&#123;</span><br><span class="line">            System.out.println(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从上面的路径中随意选择一个类 看看他的类加载器是什么:拓展类加载器</span></span><br><span class="line">        ClassLoader classLoader1 = CurveDB.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//sun.misc.Launcher$ExtClassLoader@4dc63996</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知识扩展：启动类加载器BootStrapClassLoader能够加载的api路径有</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604221415.png" alt="img"></p>
<p>最近看java.util.concurrent包的内容，发现java.time.*、java.util.*、java.nio.*、java.lang.*、java.text.*、java.sql.*、java.math.*等等都在rt.jar包下。</p>
<h3 id="（3）用户自定义类加载器"><a href="#（3）用户自定义类加载器" class="headerlink" title="（3）用户自定义类加载器"></a>（3）用户自定义类加载器</h3><blockquote>
<p>为什么要自定义类加载器</p>
</blockquote>
<ol>
<li><p>隔离加载类（有些类的路径名、类名都是一样的，避免类冲突，许多框架都会自定义类加载器）</p>
</li>
<li><p>修改类加载的方式</p>
</li>
<li><p>拓展加载源</p>
</li>
<li><p>防止源码泄漏</p>
</li>
</ol>
<blockquote>
<p>怎么去自定义类加载器呢？</p>
</blockquote>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604221442.png" alt="img"></p>
<h3 id="（4）关于ClassLoader"><a href="#（4）关于ClassLoader" class="headerlink" title="（4）关于ClassLoader"></a>（4）关于ClassLoader</h3><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p>
<p><strong>ClassLoader的常用方法</strong></p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604221757.png" alt="img"></p>
<p>其中有一个是loadClass，一个是findClass。调用了findClass()后再调用defineClass()的效果等效于直接调用loadClass()。</p>
<p><strong>如何获取ClassLoader</strong></p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604222006.png" alt="img"></p>
<p><strong>代码示例</strong></p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604222021.png" alt="img"></p>
<h2 id="6-双亲委派机制"><a href="#6-双亲委派机制" class="headerlink" title="6. 双亲委派机制"></a>6. 双亲委派机制</h2><h3 id="（1）原理"><a href="#（1）原理" class="headerlink" title="（1）原理"></a>（1）原理</h3><p>Java虚拟机加载某个类的Class文件时，采用的是<strong>双亲委派机制。</strong>那么什么是双亲委派机制呢？也就是把请求交给父类去处理，父类再交给父类的父类处理，以此类推，直至没有父类为止。</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604222410.png" alt="img"></p>
<p>举一个很形象的例子：当桌子上有一个苹果的时候，出于礼仪，儿子会问妈妈要不要吃苹果，妈妈又会问奶奶要不要吃苹果，如果奶奶要吃，那这个苹果就给奶奶吃了。如果奶奶不吃，妈妈再决定吃不吃这个苹果，依次类推。</p>
<h3 id="（2）双亲委派机制示例"><a href="#（2）双亲委派机制示例" class="headerlink" title="（2）双亲委派机制示例"></a>（2）双亲委派机制示例</h3><h4 id="保护程序安全"><a href="#保护程序安全" class="headerlink" title="保护程序安全"></a>保护程序安全</h4><p>如图，虽然我们自定义了一个java.lang包下的String尝试覆盖核心类库中的String，但是由于双亲委派机制，启动加载器会加载java核心类库的String类（BootStrap启动类加载器只加载包名为java、javax、sun等开头的类），而核心类库中的String并没有main方法</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604223048.png" alt="img"></p>
<h4 id="双亲委派机制在SPI中的应用"><a href="#双亲委派机制在SPI中的应用" class="headerlink" title="双亲委派机制在SPI中的应用"></a>双亲委派机制在SPI中的应用</h4><p>1.某个应用程序由双亲委派机制找到引导类加载器，首先调用rt.jar包中的SPI核心，但由于SPI核心当中有各种各样的接口需要被实现（这里指具体的服务提供商），这里我们已JDBC.jar为例，jdbc.jar可以为我们提供具体的实现。</p>
<p>2.那么这时我们需要反向委托，找到线程上下文类加载器去加载jdbc.jar</p>
<p>3.线程上下文类加载器属于系统类加载器</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604223146.png" alt="img"></p>
<h3 id="（3）双亲委派机制的优势"><a href="#（3）双亲委派机制的优势" class="headerlink" title="（3）双亲委派机制的优势"></a>（3）双亲委派机制的优势</h3><p>1.避免类的重复加载，如上面String类的例子。</p>
<p>2.保护程序安全，防止核心API被随意修改</p>
<p>启动类加载器可以抢在标准扩展类装载器之前去装载类，而标准扩展类装载器可以抢在类路径加载器之前去装载那个类，类路径装载器又可以抢在自定义类加载器之前去加载它。所以Java虚拟机先从最可信的Java核心API查找类型，这是为了防止不可靠的类扮演被信任的类，试想一 下，网络上有个名叫java.lang.Integer的类，它是某个黑客为了想混进java.lang包所起的名字，实际上里面含有恶意代码，但是这种伎俩在双亲模式加载体系结构下是行不通的，因为类加载器在加载它的时候，它首先启用双亲委派机制，这样一直向上委托，直到启动类加载器，而启动类加载器在java.lang（jdk中的核心库）包里发现了这个名字的类，所以它就直接加载java.lang的Integer类，然后将这个类返回，所以自始至终我们伪装的 java.lang.Integer的类是不会被加载的。</p>
<p>3.保证核心API包的访问权限</p>
<p>但是如果这个移动代码不是去试图替换一个被信任的类（就是前面说的那种情况），而是想在一个被信任的包中插入一个全新的类型，情况会怎样呢？比如我们自己定义个一个名为 java.lang.Virus的类，试图将它伪装到java核心库里面的java.lang包下，但是执行main()方法的时候，却报错了，提示没有访问权限，试想如果成功了，我们是不是可以去破坏引导类加载器。</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604223837.png" alt="img"></p>
<h2 id="7-沙箱安全机制"><a href="#7-沙箱安全机制" class="headerlink" title="7. 沙箱安全机制"></a>7. 沙箱安全机制</h2><p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604224001.png" alt="Image"></p>
<h2 id="8-类的主动使用与被动使用"><a href="#8-类的主动使用与被动使用" class="headerlink" title="8. 类的主动使用与被动使用"></a>8. 类的主动使用与被动使用</h2><p><strong>java程序对类的使用方式分为：主动使用和被动使用，即是否调用了clinit()方法</strong></p>
<p>主动使用在类加载系统中的第三阶段initialization即初始化阶段调用了clinit()方法</p>
<p>而被动使用不会去调用</p>
<p>主动使用，分为七种情况</p>
<ol>
<li><p>创建类的实例</p>
</li>
<li><p>访问某各类或接口的静态变量，或者对静态变量赋值</p>
</li>
<li><p>调用类的静态方法</p>
</li>
<li><p>反射 比如Class.forName(com.dsh.jvm.xxx)</p>
</li>
<li><p>初始化一个类的子类</p>
</li>
<li><p>java虚拟机启动时被标明为启动类的类</p>
</li>
<li><p>JDK 7 开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</p>
</li>
</ol>
<p>除了以上七种情况，其他使用java类的方式都被看作是对<strong>类的被动使用，都不会导致类的初始化。</strong></p>
<h2 id="9-其他"><a href="#9-其他" class="headerlink" title="9. 其他"></a>9. 其他</h2><p>1.在jvm中表示两个class对象是否为同一个类存在的两个必要条件</p>
<p>类的完整类名必须一致，包括包名</p>
<p>即使类的完整类名一致，同时要求加载这个类的ClassLoader（指ClassLoader实例对象）必须相同；是引导类加载器、还是定义类加载器</p>
<p>2.换句话说，在jvm中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的.</p>
<p>3.对类加载器的引用，JVM必须知道一个类型是有启动类加载器加载的还是由用户类加载器加载的。如果一个类型由用户类加载器加载的，那么jvm会<strong>将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong>。当解析一个类型到另一个类型的引用的时候，JVM需要保证两个类型的加载器是相同的。</p>
<h1 id="三、运行时数据区"><a href="#三、运行时数据区" class="headerlink" title="三、运行时数据区"></a>三、运行时数据区</h1><p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604225107.png" alt="img"></p>
<p>运行时数据区就是蓝色框内的内容，接下来开始这部分的学习。内存是非常重要的系统资源，是硬盘和cpu的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了JAVA在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<strong>不同的jvm对于内存的划分方式和管理机制存在着部分差异</strong>（对于Hotspot主要指方法区）</p>
<p>JDK8的<strong>元数据区+JIT编译产物</strong> 就是JDK8以前的<strong>方法区</strong></p>
<blockquote>
<p>JavaAPI中的Runtime</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure>

<p>Every Java application has a single instance of class Runtime that allows the application to interface with theenvironment in which the application is running. The current runtime can be obtained from the getRuntime method.</p>
<p>每个Java应用程序都有一个Runtime类的实例，该实例允许该应用程序与运行该应用程序的环境进行交互。 当前运行时可以从getRuntime方法获得。</p>
<h2 id="1-Java内存分区介绍"><a href="#1-Java内存分区介绍" class="headerlink" title="1. Java内存分区介绍"></a>1. Java内存分区介绍</h2><p>java虚拟机定了了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604225307.png" alt="img"></p>
<p>如图，灰色的区域为单独线程私有的，红色的为多个线程共享的。</p>
<blockquote>
<p>Java中的线程与进程</p>
</blockquote>
<ol>
<li><p>每个线程：独立包括程序计数器、栈、本地栈</p>
</li>
<li><p>线程间共享：堆、堆外内存（方法区、永久代或元空间、代码缓存）</p>
</li>
</ol>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604225618.png" alt="img"></p>
<p>图片说明：严格对照Java内存分区</p>
<p>PC即程序计数器</p>
<p>VMS即虚拟机栈</p>
<p>NMS即本地方法栈</p>
<p>一般来说，jvm优化95%是优化堆区，5%优化的是方法区，至于栈区无非出入栈操作所以优化较少</p>
<p><strong>线程</strong></p>
<p>1.线程是一个程序里的运行单元，JVM允许一个程序有多个线程并行的执行；</p>
<p>2.在HotSpot JVM，每个线程都与操作系统的本地线程直接映射。</p>
<ul>
<li>当一个java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。java线程执行终止后。本地线程也会回收。</li>
</ul>
<p>3.操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用java线程中的run（）方法。</p>
<p><strong>JVM系统线程分类</strong></p>
<p>如果你使用jconsole或者任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用main方法的main线程以及所有这个main线程自己创建的线程；</p>
<p>这些主要的后台系统线程在HotSpot JVM里主要是以下几个（了解）：</p>
<p>1.虚拟机线程：这种线程的操作时需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行包括“stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</p>
<p>2.周期任务线程：这种线程是时间周期事件的提现（比如中断），他们一般用于周期性操作的调度执行。</p>
<p>3.GC线程：这种线程对于JVM里不同种类的垃圾收集行为提供了支持</p>
<p>4.编译线程：这种线程在运行时会降字节码编译成本地代码</p>
<p>5.信号调度线程：这种线程接收信号并发送给JVM,在它内部通过调用适当的方法进行处理。</p>
<h2 id="2-程序计数器"><a href="#2-程序计数器" class="headerlink" title="2. 程序计数器"></a>2. 程序计数器</h2><p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p>
<p>一个线程对应一个 JVM Stack。JVM Stack 中包含一组 Stack Frame。当 JVM 调用一个 Java 方法时，它从对应类的类型信息中得到此方法的局部变量区和操作数栈的大小，并据此分配栈帧内存，然后压入 JVM 栈中。</p>
<p>在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法。</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200605105745.png" alt="img"></p>
<h3 id="（1）作用"><a href="#（1）作用" class="headerlink" title="（1）作用"></a>（1）作用</h3><p>PC寄存器是用来存储指向下一条指令的地址，也即将将要执行的指令代码。由执行引擎读取下一条指令。</p>
<ol>
<li><p>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</p>
</li>
<li><p>在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致</p>
</li>
<li><p>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefined）,因为程序计数器不负责本地方法栈。</p>
</li>
<li><p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</p>
</li>
<li><p>字节码解释器工作时就是通过改变这个计数器的值来选取下一跳需要执行的字节码指令</p>
</li>
<li><p>它是唯一一个在java虚拟机规范中<strong>没有规定任何OOM（Out Of Memery）情况</strong>的区域,而且没有垃圾回收</p>
</li>
</ol>
<h3 id="（2）举例说明"><a href="#（2）举例说明" class="headerlink" title="（2）举例说明"></a>（2）举例说明</h3><p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200605114858.png" alt="img"></p>
<p>如图，数字是指令偏移地址，指令后面的#2、#3啊等等是常量池的地址。如#2对应的就是常量池的String abc，#3对应的PrintStream。</p>
<h3 id="（3）相关问题"><a href="#（3）相关问题" class="headerlink" title="（3）相关问题"></a>（3）相关问题</h3><blockquote>
<p> 使用PC寄存器存储字节码指令地址有什么用呢（为什么使用PC寄存器记录当前线程的执行地址呢）</p>
</blockquote>
<p>（1）多线程宏观上是并行（多个事件在同一时刻同时发生）的，但实际上是并发交替执行的</p>
<p>（2）因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行</p>
<p>（3）JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令</p>
<blockquote>
<p>PC寄存器为什么会设定为线程私有？</p>
</blockquote>
<p>（1）众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p>
<p>（2）为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是**为每一个线程都分配一个PC寄存器,**这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p>
<h2 id="3-虚拟机栈"><a href="#3-虚拟机栈" class="headerlink" title="3. 虚拟机栈"></a>3. 虚拟机栈</h2><h3 id="（1）虚拟机背景"><a href="#（1）虚拟机背景" class="headerlink" title="（1）虚拟机背景"></a>（1）虚拟机背景</h3><p>由于跨平台性的设计，java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。<br>根据栈设计的<strong>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</strong></p>
<blockquote>
<p>内存中的堆与栈</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200605173935.png" alt="Image"></p>
<p>1.栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿。</p>
<p>2.一般来讲，对象主要都是放在堆空间的，是运行时数据区比较大的一块</p>
<p>3.栈空间存放基本数据类型的局部变量，以及引用数据类型的对象的引用</p>
<p>总结为：<strong>栈是运行时的单位，而堆是存储的单位。</strong></p>
<p>这句话的意思即栈解决程序的运行问题，即程序如何执行或者说如何处理数据。而堆解决的是数据存储的问题，即数据怎么放、放在哪儿。</p>
</blockquote>
<h3 id="（2）虚拟机栈基本内容"><a href="#（2）虚拟机栈基本内容" class="headerlink" title="（2）虚拟机栈基本内容"></a>（2）虚拟机栈基本内容</h3><blockquote>
<p> Java虚拟机栈是什么</p>
</blockquote>
<p>java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。 每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应这个一次次的java方法调用。它是线程私有的。</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200605174503.png" alt="img"></p>
<blockquote>
<p> 虚拟机栈的作用</p>
</blockquote>
<p>主管java程序的运行，它保存方法的局部变量、8种基本数据类型、对象的引用地址、部分结果，并参与方法的调用和返回。</p>
<p><strong>优点：</strong></p>
<p>1.速度快，仅次于程序计数器。 </p>
<p>2.操作简单：出栈、入栈。  </p>
<p>3.不存在垃圾回收问题，但是栈存在OOM。（因为出栈入栈就可了，栈溢出的时候就直接挂掉了）</p>
<blockquote>
<p> 栈中可能出现的异常</p>
</blockquote>
<p><strong>StackOverFlowError</strong>与<strong>OutOfMemoryError</strong>！</p>
<p>java虚拟机规范允许<strong>Java栈的大小是动态的或者是固定不变的</strong></p>
<p>如果采用固定大小的Java虚拟机栈，那每一个线程的java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量，java虚拟机将会抛出一个 <strong>StackOverFlowError</strong>异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示栈中的异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackErrorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果java虚拟机栈可以动态拓展，并且在尝试拓展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那java虚拟机将会抛出一个 <strong>OutOfMemoryError异常。</strong></p>
<h3 id="（3）设置栈的内存大小"><a href="#（3）设置栈的内存大小" class="headerlink" title="（3）设置栈的内存大小"></a>（3）设置栈的内存大小</h3><p>我们可以使用参数-Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。 （IDEA设置方法：Run-EditConfigurations-VM options 填入指定栈的大小-Xss256k）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示栈中的异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 默认情况下：count 10818</span></span><br><span class="line"><span class="comment"> * 设置栈的大小： -Xss256k count 1872</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackErrorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        count++;</span><br><span class="line">        main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>疑问：如果try-catch会怎样？（未解决）</p>
<h3 id="（4）栈的存储结构和运行原理"><a href="#（4）栈的存储结构和运行原理" class="headerlink" title="（4）栈的存储结构和运行原理"></a>（4）栈的存储结构和运行原理</h3><p>1.每个线程都有自己的栈，栈中的数据都是以**栈帧(Stack Frame)**的格式存在</p>
<p>2.在这个线程上正在执行的每个方法都对应各自的一个栈帧</p>
<p>3.栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</p>
<p>4.JVM直接对java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循先进后出/后进先出的和原则。</p>
<p>5.在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<strong>当前栈帧(Current Frame)</strong>,与当前栈帧对应的方法就是<strong>当前方法（Current Method）</strong></p>
<p>6.执行引擎运行的所有字节码指令只针对当前栈帧进行操作</p>
<p>7.如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前栈帧。</p>
<p>8.不同线程中所包含的栈帧是不允许相互引用的，即不可能在另一个栈帧中引用另外一个线程的栈帧</p>
<p>9.如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</p>
<p>10.Java方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</strong></p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200605180921.png" alt="img"></p>
<p><strong>代码演示：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈帧</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackFrameTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StackFrameTest test = <span class="keyword">new</span> StackFrameTest();</span><br><span class="line">        test.method1();</span><br><span class="line">        <span class="comment">//输出 method1（）和method2（）都作为当前栈帧出现了两次，method3（）一次</span></span><br><span class="line"><span class="comment">//        method1()开始执行。。。</span></span><br><span class="line"><span class="comment">//        method2()开始执行。。。</span></span><br><span class="line"><span class="comment">//        method3()开始执行。。。</span></span><br><span class="line"><span class="comment">//        method3()执行结束。。。</span></span><br><span class="line"><span class="comment">//        method2()执行结束。。。</span></span><br><span class="line"><span class="comment">//        method1()执行结束。。。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method1()开始执行。。。&quot;</span>);</span><br><span class="line">        method2();</span><br><span class="line">        System.out.println(<span class="string">&quot;method1()执行结束。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2()开始执行。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> m = (<span class="keyword">int</span>) method3();</span><br><span class="line">        System.out.println(<span class="string">&quot;method2()执行结束。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i+m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method3()开始执行。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">double</span> j = <span class="number">20.0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;method3()执行结束。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）栈帧的内部结构"><a href="#（5）栈帧的内部结构" class="headerlink" title="（5）栈帧的内部结构"></a>（5）栈帧的内部结构</h3><p>每个栈帧中存储着</p>
<p><strong>1.局部变量表</strong>（Local Variables）</p>
<p><strong>2.操作数栈</strong>（Operand Stack）(或表达式栈)</p>
<p>3.动态链接（Dynamic Linking）(或执行”运行时常量池”的方法引用)—-深入理解Java多态特性必读！！</p>
<p>4.方法返回地址（Return Adress）（或方法正常退出或者异常退出的定义）</p>
<p>5.一些附加信息</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606144912.png" alt="img"></p>
<p>其中部分参考书目上，称方法返回地址、动态链接、附加信息为帧数据区。</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606145038.png" alt="img"></p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>1.局部变量表也被称之为局部变量数组或本地变量表</p>
<p><strong>2.定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddressleixing</p>
<p>3.由于局部变量表是建立在线程的栈上，是线程私有的数据，因此不存在数据安全问题</p>
<p><strong>4.局部变量表所需的容量大小是在编译期确定下来的</strong>,并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的</p>
<p><strong>5.方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。</strong>对一个函数而言，他的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间。</p>
<p><strong>6.局部变量表中的变量只在当前方法调用中有效。</strong>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</strong></p>
<blockquote>
<p>查看帧的局部变量表</p>
</blockquote>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606155050.png" alt="img"></p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606155202.png" alt="image-20200606155202155"></p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606160026.png" alt="image-20200606160025218"></p>
<p>StartPC：变量开始作用的起始行（声明的下一行）</p>
<p>Length：有效的长度</p>
<p>Index：局部变量的索引，有四个局部变量，分别是0、1、2、3。</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606160407.png" alt="img"></p>
<blockquote>
<p>变量槽slot的理解与演示</p>
</blockquote>
<p>1.参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束</p>
<p>2.局部变量表，<strong>最基本的存储单元是Slot(变量槽)</strong></p>
<p>3.局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p>
<p>4.在局部变量表里，<strong>32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</strong></p>
<ul>
<li><p>byte、short、char、float在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true；</p>
</li>
<li><p>long和double则占据两个slot。</p>
</li>
</ul>
<img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606160759.png" alt="img" style="zoom:50%;" />

<p>5.JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p>
<p>6.当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照声明顺序被复制到局部变量表中的每一个slot上</p>
<p><strong>7.如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。</strong>（比如：访问long或者double类型变量）</p>
<p>8.如果当前帧是由构造方法或者实例方法创建的（意思是当前帧所对应的方法是构造器方法或者是普通的实例方法），那么<strong>该对象引用this将会存放在index为0的slot处</strong>,其余的参数按照参数表顺序排列。</p>
<p>9.静态方法中不能引用this，是因为静态方法所对应的栈帧当中的局部变量表中不存在this</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606162106.png"></p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606162126.png"></p>
<p>通过index我们可以发现b、c、d都占了两个槽位，因为他们都是64位的变量！</p>
<blockquote>
<p>slot的重复利用</p>
</blockquote>
<p>栈帧中的局部变量表中的槽位是可以重复利用的，如果一个局部变量过了其作用域，那么在其作用域之后声明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        b = a+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//变量c使用之前以及经销毁的变量b占据的slot位置</span></span><br><span class="line">    <span class="keyword">int</span> c = a+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码对应的栈帧中局部变量表中一共有3个slot（也就是局部变量表的长度是3）</p>
<p>因为变量b的作用域是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">     b = a+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了这个括号，b就失效了，然后c重复使用了b的槽号。</p>
<p>所以最终局部变量表中this占0号、a单独占1号，c为2号（之前b也是2号，b失效后，c占用b的槽）</p>
<blockquote>
<p>静态变量与局部变量的对比及小结</p>
</blockquote>
<p>变量的分类：</p>
<ul>
<li>按照数据类型分：<ul>
<li>①基本数据类型;</li>
<li>②引用数据类型；</li>
</ul>
</li>
<li>按照在类中声明的位置分：<ul>
<li>①成员变量：在使用前，都经历过默认初始化赋值<ul>
<li>static修饰：类变量：类加载链接的准备preparation阶段给类变量默认赋0值——&gt;初始化阶段initialization给类变量显式赋值即静态代码块赋值；</li>
<li>不被static修饰：实例变量：随着对象的创建，会在堆空间分配实例变量空间，并进行默认赋值</li>
</ul>
</li>
<li>②局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。</li>
</ul>
</li>
</ul>
<blockquote>
<p>补充</p>
</blockquote>
<ul>
<li>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</li>
<li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong>。</li>
</ul>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>1.栈 ：可以使用数组或者链表来实现</p>
<p>2.每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出的操作数栈，也可以成为表达式栈</p>
<p><strong>3.操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）或出栈（pop）</strong></p>
<ul>
<li><p>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈，使用他们后再把结果压入栈。（如字节码指令bipush操作）</p>
</li>
<li><p>比如：执行复制、交换、求和等操作</p>
</li>
</ul>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606164511.png" alt="img"></p>
<blockquote>
<p>操作数栈特点</p>
</blockquote>
<ul>
<li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</strong></li>
<li>操作数栈就是jvm执行引擎的一个工作区，当一个方法开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的</li>
<li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译器就定义好了，保存在方法的code属性中，为max_stack的值。</li>
<li>栈中的任何一个元素都是可以任意的java数据类型<ul>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈深度单位</li>
</ul>
</li>
<li>操作数栈<strong>并非采用访问索引的方式来进行数据访问</strong>的，而是只能通过标准的入栈push和出栈pop操作来完成一次数据访问</li>
<li><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，</strong>并更新PC寄存器中下一条需要执行的字节码指令。</li>
<li>操作数栈中的元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类验证阶段的数据流分析阶段要再次验证。</li>
<li>另外，我们说Java虚拟机的<strong>解释引擎是基于栈的执行引擎</strong>,其中的栈指的就是操作数栈</li>
</ul>
<blockquote>
<p>操作数栈代码追踪</p>
</blockquote>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606170228.png" alt="img"></p>
<p>①15入栈；②存储15，15进入局部变量表</p>
<p>注意：局部变量表的0号位被this占用，所以15从局部变量表1号开始。</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606170251.png" alt="img"></p>
<p>③压入8进入操作数栈；④8出栈，存储8进入局部变量表；</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606170339.png" alt="img"></p>
<p>⑤从局部变量表中把索引为1和2的是数据取出来，放到操作数栈；⑥iadd相加操作</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606170419.png" alt="img"></p>
<p>⑦iadd操作结果23出栈⑧将23存储在局部变量表索引为3的位置上istore_3。</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606170439.png" alt="img"></p>
<blockquote>
<p>栈顶缓存技术ToS(Top-of-Stack Cashing)</p>
</blockquote>
<ul>
<li>基于栈式架构的虚拟机所使用的零地址指令（即不考虑地址，单纯入栈出栈）更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数</li>
<li>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率</strong></li>
</ul>
<h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><blockquote>
<p>什么是运行时常量池</p>
</blockquote>
<p>运行时常量池位于方法区（注意： JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。）</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606213344.png" alt="img"></p>
<blockquote>
<p>常量池的作用是什么</p>
</blockquote>
<p>常量池的作用，就是为了提供一些符号和常量，便于指令的识别。</p>
<p>下面提供一张测试类的运行时字节码文件格式。</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606213453.png" alt="image-20200606213452872"></p>
<blockquote>
<p>动态链接</p>
</blockquote>
<p>1.每一个栈帧内部都包含一个指向运行时常量池Constant pool或该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如invokedynamic指令</p>
<p>2.在Java源文件被编译成字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Refenrence）保存在class字节码文件（javap反编译查看）的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用（#）最终转换为调用方法的直接引用。</strong></p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606214126.png" alt="img"></p>
<blockquote>
<p>方法的调用（重要）</p>
</blockquote>
<p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>
<ul>
<li><strong>静态链接</strong><br>当一个 字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</li>
<li><strong>动态链接</strong><br>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</li>
</ul>
<p>对应的方法的绑定机制为：早起绑定（Early Binding）和晚期绑定（Late Bingding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p>
<ul>
<li><strong>早期绑定</strong><br>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li>
<li><strong>晚期绑定</strong><br>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</li>
</ul>
<p>随着高级语言的横空出世，类似于java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装，集成和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。<br>Java中任何一个普通的方法其实都具备虚函数（即编译期无法确定）的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p>
<blockquote>
<p>虚方法与非虚方法</p>
</blockquote>
<p>子类对象的多态性使用前提：<br>①类的继承关系（父类的声明）②方法的重写（子类的实现）</p>
<p>非虚方法</p>
<ul>
<li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法</li>
<li><strong>静态方法、私有方法、final方法、实例构造器（实例已经确定，this()表示本类的构造器）、父类方法（super调用）都是非虚方法</strong></li>
</ul>
<p>虚方法</p>
<ul>
<li>其他所有体现多态特性的方法称为虚方法</li>
</ul>
<p><strong>虚拟机中提供了以下几条方法调用指令</strong>：</p>
<p><strong>普通调用指令：</strong></p>
<ul>
<li>invokestatic：调用静态方法，解析阶段确定唯一方法版本；</li>
<li>invokespecial：调用&lt;init&gt;方法、私有及父类方法，解析阶段确定唯一方法版本</li>
<li>invokevirtual：调用所有虚方法；</li>
<li>invokeinterface：调用接口方法；</li>
</ul>
<p><strong>动态调用指令</strong>（Java7新增）：</p>
<ul>
<li>invokedynamic：动态解析出需要调用的方法，然后执行 。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">关于invokedynamic指令</span><br><span class="line"></span><br><span class="line">1. JVM字节码指令集一直比较稳定，一直到java7才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。</span><br><span class="line"></span><br><span class="line">2. 但是java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令.直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在java中才有了直接生成方式。</span><br><span class="line"></span><br><span class="line">3. Java7中增加的动态语言类型支持的本质是对java虚拟机规范的修改，而不是对java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在java平台的动态语言的编译器。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">关于动态类型语言和静态类型语言</span><br><span class="line"></span><br><span class="line">动态类型语言和静态类型语言两者的却别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之则是动态类型语言。</span><br><span class="line"></span><br><span class="line">直白来说 静态语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息,这是动态语言的一个重要特征</span><br><span class="line"></span><br><span class="line">Java是静态类型语言（尽管lambda表达式为其增加了动态特性），js，python是动态类型语言。</span><br><span class="line"></span><br><span class="line">Java：String info &#x3D; &quot;硅谷&quot;;&#x2F;&#x2F;静态语言</span><br><span class="line">JS：var name &#x3D; &quot;硅谷“；var name &#x3D; 10;&#x2F;&#x2F;动态语言</span><br><span class="line">Pythom：info &#x3D; 130;&#x2F;&#x2F;更加彻底的动态语言</span><br></pre></td></tr></table></figure>

<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。</p>
<p><strong>其中invokestatic指令和invokespecial指令调用的方法称为非虚方法</strong>。</p>
<p><strong>其中invokevirtual（final修饰的除外，JVM会把final方法调用也归为invokevirtual指令，但要注意final方法调用不是虚方法）、invokeinterface指令调用的方法称称为虚方法。</strong></p>
<blockquote>
<p>方法的调用：方法重写的本质</p>
</blockquote>
<p><strong>Java语言中方法重写的本质：</strong></p>
<ul>
<li>1 找到操作数栈的第一个元素所执行的对象的实际类型，记作C。</li>
<li>2.如果在类型C中找到与常量池中的描述符、简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。</li>
<li>3.否则，按照继承关系从下往上依次对c的各个父类进行第二步的搜索和验证过程。</li>
<li>4.如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li>
</ul>
<p><strong>IllegalAccessError介绍</strong> ：</p>
<p>程序视图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p>
<blockquote>
<p>方法的调用：虚方法表</p>
</blockquote>
<ul>
<li>在面向对象编程中，会很频繁期使用到动态分派，如果在每次动态分派的过程中都要重新在累的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，jvm采用在类的方法区建立一个虚方法表（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</li>
<li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</li>
<li>那么虚方法表什么时候被创建？ 虚方法表会在类加载的链接阶段被创建 并开始初始化，类的变量初始值准备完成之后，jvm会把该类的虚方法表也初始化完毕。</li>
</ul>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606222935.png" alt="img"></p>
<p>如果是自己的方法，就指向自己，如果是父类的或者Object类型的，就指向父类或者Object。</p>
<h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><ul>
<li>存放调用该方法的PC寄存器的值。</li>
<li>一个方法的结束，有两种方式：<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
</li>
<li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者（方法的调用者可能也是一个方法）的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</strong>而通过异常退出时，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li>
<li>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</li>
<li><strong>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></li>
</ul>
<blockquote>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法。</p>
</blockquote>
<p>1.执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；</p>
<ul>
<li>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定</li>
<li>在字节码指令中，返回指令包含ireturn（当返回值是boolena、byte、char、short和int类型时使用）、lreturn、freturn、dreturn以及areturn(引用类型的)</li>
<li>另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用</li>
</ul>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606224313.png" alt="img"></p>
<p>2.在方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中<strong>没有搜素到匹配的异常处理器（try-catch)<strong>，就会导致方法退出，简称</strong>异常完成出口</strong><br>而如果存在方法执行过程中抛出异常时的<strong>异常处理</strong>，它会存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606224518.png" alt="img"></p>
<p>method1发生异常，method2进行处理。</p>
<p>在method2中可以看到字节码当中的异常处理表：下表的行号不是上图的代码的行号，而是其对应字节码当中的行号。</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606224604.png" alt="img"></p>
<p> 在字节码当中的4<del>11行是存在异常的代码行号，对应Java中70</del>73行，11代表字节码中能够处理该异常的位置是第11行也就是上图中的第72行。</p>
<h4 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h4><p>栈帧中还允许携带与java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。（很多资料都忽略了附加信息）</p>
<h3 id="（6）虚拟机栈的五道面试题"><a href="#（6）虚拟机栈的五道面试题" class="headerlink" title="（6）虚拟机栈的五道面试题"></a>（6）虚拟机栈的五道面试题</h3><blockquote>
<ol>
<li>举例栈溢出的情况（StackOverlowError）</li>
</ol>
</blockquote>
<ul>
<li>使用了大量递归或者无限递归</li>
<li>使用了大量循环或者死循环</li>
<li>全局变量过多</li>
<li>数组、List、map数据过大</li>
</ul>
<blockquote>
<ol start="2">
<li>调整栈大小，就能保证不会溢出吗？</li>
</ol>
</blockquote>
<p>不能保证，假如无限递归，就算调整栈大小，也还是会溢出。</p>
<blockquote>
<ol start="3">
<li>分配栈内存越大越好吗？</li>
</ol>
</blockquote>
<p>肯定不是，栈内存分配的越大，其他程序的内存就变小，我们需要找到一个平衡点。</p>
<blockquote>
<ol start="4">
<li>垃圾回收是否会涉及到虚拟机栈？</li>
</ol>
</blockquote>
<p>不会，栈内存是一次次的方法调用产生的栈帧内存，一次方法调用后就会弹出栈，就会被自动的回收掉，所以根本不需要垃圾回收来管理栈内存，垃圾回收只是回收堆内存中的无用对象。</p>
<blockquote>
<ol start="5">
<li>方法中定义的局部变量是否线程安全？</li>
</ol>
</blockquote>
<p>如果局部变量不是方法的形参或者不是作为方法的返回值，那么它就是线程安全的。</p>
<h2 id="4-本地方法栈"><a href="#4-本地方法栈" class="headerlink" title="4. 本地方法栈"></a>4. 本地方法栈</h2><h3 id="（1）本地方法概述"><a href="#（1）本地方法概述" class="headerlink" title="（1）本地方法概述"></a>（1）本地方法概述</h3><p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200914105226.png" alt="img"></p>
<p>简单来讲，<strong>一个Native Method就是一个java调用非java代码的接口</strong>，一个Native Method 是这样一个java方法：该方法的底层实现由非Java语言实现，比如C。这个特征并非java特有，很多其他的编程语言都有这一机制，比如在C++ 中，你可以用extern “C” 告知C++ 编译器去调用一个C的函数。<br>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。<br>本地接口的作用是融合不同的编程语言为java所用，它的初衷是融合C/C++程序。<br>标识符native可以与其他所有的java标识符连用，但是abstract除外（因为抽象方法没有方法体）。</p>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本地方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">IHaveNatives</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//abstract 没有方法体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//native 和 abstract不能共存，native是有方法体的，由C语言来实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native1</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">Native2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="keyword">private</span> <span class="keyword">float</span> <span class="title">Native3</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native4</span><span class="params">(<span class="keyword">int</span>[] array)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么要使用Native Method？</p>
</blockquote>
<p>java使用起来非常方便，然而有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p>
<ul>
<li><strong>与java环境外交互</strong><br>有时java应用需要与java外面的环境交互，这是本地方法存在的主要原因。 你可以想想java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样的一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐细节。</li>
<li><strong>与操作系统交互</strong>（比如线程最后要回归于操作系统线程）<br>JVM支持着java语言本身和运行库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至jvm的一些部分就是用C写的。还有，如果我们要使用一些java语言本身没有提供封装的操作系统特性时，我们也需要使用本地方法。</li>
<li><strong>Sun’s Java</strong><br>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的事该类里的本地方法setPriority0（）。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setPriority()API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</li>
</ul>
<blockquote>
<p>现状</p>
</blockquote>
<p>现在的Java已经非常强大了，目前该方法的是用越来越少了，除非是与硬件有关的应用，比如通过java程序驱动打印机或者java系统管理生产设备，在企业级应用已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以是用Web Service等等，不多做介绍。</p>
<h3 id="（2）本地方法栈概述"><a href="#（2）本地方法栈概述" class="headerlink" title="（2）本地方法栈概述"></a>（2）本地方法栈概述</h3><p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200608222608.png" alt="img"></p>
<ol>
<li><p>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法（一般非Java实现的方法）的调用。</p>
</li>
<li><p>本地方法栈，也是线程私有的。</p>
</li>
<li><p>允许被实现成固定或者是可动态拓展的内存大小。（和Java虚拟机栈在内存溢出方面情况是相同的）</p>
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverFlowError异常。</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么java虚拟机将会抛出一个OutOfMemoryError异常。</li>
</ul>
</li>
<li><p>本地方法是用C语言实现的。</p>
</li>
<li><p>要想使用本地方法，它的具体做法是<strong>Native Method Stack</strong>中登记native方法，在<strong>Execution Engine</strong>执行时加载本地方法库。</p>
</li>
<li><p><strong>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限</strong></p>
<ul>
<li><p>本地方法可以通过本地方法接口来 <strong>访问虚拟机内部的运行时数据区</strong></p>
</li>
<li><p>它甚至可以直接使用本地处理器中的寄存器</p>
</li>
<li><p>直接从本地内存的堆中分配任意数量的内存</p>
</li>
</ul>
</li>
<li><p>.并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈（如上面那个图是Hostpot JVM，它就是支持本地方法栈的）。</p>
</li>
</ol>
<h2 id="5-堆空间"><a href="#5-堆空间" class="headerlink" title="5. 堆空间"></a>5. 堆空间</h2><h3 id="（1）堆的核心概述"><a href="#（1）堆的核心概述" class="headerlink" title="（1）堆的核心概述"></a>（1）堆的核心概述</h3><ol>
<li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</li>
<li>Java 堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。<ul>
<li>注意：堆内存的大小是可以调节的</li>
</ul>
</li>
<li>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑思维它应该被视为连续的。（涉及到物理内存和虚拟内存）</li>
<li>所有的线程共享Java堆（线程不安全），在这里还可以划分<strong>线程私有</strong>的缓冲区。</li>
<li>《Java虚拟机规范》中对Java堆的描述是:所有的对象实例以及数组都应当在运行时分配在堆上。| (The heap is the run-time data area fromwhich memory for <strong>all class</strong> instances and arrays is allocated )<ul>
<li>我要说的是:“几乎”所有的对象实例都在这里分配内存。从实际使用角度看的。</li>
</ul>
</li>
<li>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</li>
<li>堆，是GC ( Garbage Collection, 垃圾收集器)执行垃圾回收的重点区域。</li>
<li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</li>
</ol>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610173835" alt="image-20200523213852303"></p>
<p>如上图代码，s1、s2是main方法里面的局部变量，s1、s2指向堆中创建的两个对象。</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610173917" alt="image-20200523213906307"></p>
<p>注意：当main方法结束后，这两个对象不会被立即回收！</p>
<p>main方法结束后，s1，s2就被弹出栈，堆中的s1，s2实例就没有被引用了，当GC进行判断的时候，发现s1,s2没有被引用，就判断为垃圾.<strong>如果栈中的引用刚弹出，堆中的对象就被回收，那么GC的频率将特别高！</strong></p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610174050" alt="image-20200523214532877"></p>
<center>创建对象的字节码指令</center>

<h4 id="内存细分"><a href="#内存细分" class="headerlink" title="内存细分"></a>内存细分</h4><p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610174211" alt="img"></p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610174353" alt="image-20200523214917451"></p>
<h3 id="（2）设置堆内存大小与OOM"><a href="#（2）设置堆内存大小与OOM" class="headerlink" title="（2）设置堆内存大小与OOM"></a>（2）设置堆内存大小与OOM</h3><h4 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h4><ol>
<li>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-XmX”和”-Xms”来进行设置。<ul>
<li>“-Xms”用于表示堆区（<strong>年轻代+老年代（不包括元空间）</strong>）的起始内存**，等价于-XX：Ini tialHeapSize</li>
<li>“-Xmx”则用于表示堆区的最大内存，等价于-XX ：MaxHeapSize</li>
</ul>
</li>
<li>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutOfMemoryError异常。<br>通常会将-Xms 和-Xmx两个参数配置相同的值，其<strong>目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</strong></li>
</ol>
<p>场景一：计算堆空间大小和系统内存大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 设置堆空间大小的参数</span></span><br><span class="line"><span class="comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span></span><br><span class="line"><span class="comment"> * -X 是jvm的运行参数</span></span><br><span class="line"><span class="comment"> * ms 是memory start</span></span><br><span class="line"><span class="comment"> * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小</span></span><br><span class="line"><span class="comment"> * 2. 默认堆空间的大小</span></span><br><span class="line"><span class="comment"> * 初始内存大小：物理电脑内存大小 / 64</span></span><br><span class="line"><span class="comment"> * 最大内存大小：物理电脑内存大小 / 4</span></span><br><span class="line"><span class="comment"> * 3. 手动设置：-Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> * 开发中建议将初始堆内存和最大的堆内存设置成相同的值。</span></span><br><span class="line"><span class="comment"> * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id</span></span><br><span class="line"><span class="comment"> * 方式二：-XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">// 返回Java虚拟机视图使用的最大堆内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms:&quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx:&quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;系统内存大小&quot;</span> + initialMemory * <span class="number">64.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;系统内存大小&quot;</span> + maxMemory * <span class="number">4.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610211628.png" alt="image-20200610211628051"></p>
<blockquote>
<p>问题：为什么通过两种方式得到的系统内存大小不一致？（我的电脑内存是8G，按道理计算出来的系统内存大小也是8G）</p>
</blockquote>
<p>原因一：物理内存为8G，但是必须加载的数据会占据一定空间，所以可用空间比8G少。</p>
<p>原因二：之后说明</p>
<hr>
<p><strong>场景二：自定义JVM参数</strong></p>
<ol>
<li>设置初始堆内存大小与最大内存大小</li>
</ol>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610211004.png" alt="image-20200610211003917"></p>
<blockquote>
<p>问题：为什么将初始堆内存和最大的堆内存设置成相同的值？</p>
</blockquote>
<p>如果内存不够，我们会进行扩容，如果内存多余，会进行内存释放。那么将初始堆内存和最大的堆内存设置成相同的值，就不必进行频繁的内存扩容与释放，给系统造成额外压力。</p>
<ol start="2">
<li>再次测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回Java虚拟机中的堆内存总量</span></span><br><span class="line">    <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">// 返回Java虚拟机视图使用的最大堆内存量</span></span><br><span class="line">    <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-Xms:&quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;-Xmx:&quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">    <span class="comment">//        System.out.println(&quot;系统内存大小&quot; + initialMemory * 64.0 / 1024 + &quot;G&quot;);</span></span><br><span class="line">    <span class="comment">//        System.out.println(&quot;系统内存大小&quot; + maxMemory * 4.0 / 1024 + &quot;G&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">-Xms:575M</span><br><span class="line">-Xmx:575M</span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题：为什么比我们设置的600m小呢？</p>
</blockquote>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200914110437.png" alt="image-20200914110436721"></p>
<ol>
<li>原理</li>
</ol>
<p>新生代分为Eden空间、Survivor0空间和Survivor1空间 (有时也叫做from区、to区)，因为有两个Survivor区，也叫幸存区，用的是标记拷贝的GC算法，实际分配时，永远有一个幸存区是不能被使用的，所以最大堆内存没有包含这一部分。</p>
<ol start="2">
<li>实践</li>
</ol>
<p>（1）修改代码，让main线程休眠1000秒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">// 返回Java虚拟机视图使用的最大堆内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms:&quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx:&quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"><span class="comment">//        System.out.println(&quot;系统内存大小&quot; + initialMemory * 64.0 / 1024 + &quot;G&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;系统内存大小&quot; + maxMemory * 4.0 / 1024 + &quot;G&quot;);</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）S0与S1是两个幸存区，C后缀的表示总容量大小，U后缀的表示已用大小，从图中可以看出两个S0与S1的总大小都为25600（我截图没截好，S0C也是25600）</p>
<p>我们计算总堆空间大小：（25600+153600+409600）÷1024=575，刚好是我们通过代码计算出来的堆空间大小。</p>
<p>如果将两个幸存区大小都加进去，那就是（25600+25600+153600+409600）÷1024=600，是我们所设置的堆空间的大小。</p>
<p>从而得出结论：永远有一个幸存区是不能被使用的，所以最大堆内存没有包含这一部分。</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610221323.png" alt="image-20200610221322956"></p>
<p>（3）另外一种方式证明：</p>
<p>1）去掉休眠的代码</p>
<p>2）增加参数</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610222306.png" alt="image-20200610222306548"></p>
<p>3）重新运行程序，打印结果如下：</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610222600.png" alt="image-20200610222559969"></p>
<h4 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h4><p>OOM - Out of Memory，内存溢出。</p>
<ol>
<li>代码：在堆区新建很多对象，形成OOM场景。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * -Xms600m -Xmx600m</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class OOMTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;Picture&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(20);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(new Picture(new Random().nextInt(1024 * 1024)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Picture &#123;</span><br><span class="line">    private byte[] pixels;</span><br><span class="line"></span><br><span class="line">    public Picture(int length) &#123;</span><br><span class="line">        this.pixels &#x3D; new byte[length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>运行</p>
</li>
<li><p>打开jvisualvm，可以看到Old在逐渐上升！</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610223936.png" alt="image-20200610223936140"></p>
</li>
<li><p>当Old满了的时候，就会出现OOM，再返回IDEA，发现控制台也确实报了OOM。</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610224022.png" alt="image-20200610224021882"></p>
</li>
</ol>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610224127.png" alt="image-20200610224127107"></p>
<ol start="5">
<li>查看抽样器，可以查看OOM的原因：byte[]太多。</li>
</ol>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610224232.png" alt="image-20200610224232596"></p>
<h3 id="（3）年轻代与老年代"><a href="#（3）年轻代与老年代" class="headerlink" title="（3）年轻代与老年代"></a>（3）年轻代与老年代</h3><p>存储在JVM中的Java对象可以被划分为两类:</p>
<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li>
<li>另外一类对象的生命周期却非常长，在某些服端的情况下还能够与JVM的生命周期保持一致。</li>
</ul>
<p>Java堆区进一步细分的话， 可以划分为<strong>年轻代</strong>(YoungGen)和<strong>老年代</strong>(OldGen)<br>其中年轻代又可以划分为<strong>Eden空间</strong>、<strong>Survivor0</strong>空间和<strong>Survivor1</strong>空间 (有时也叫做from区、to区)。</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200614220215.jpg" alt="img"></p>
<h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><p><strong>新生代与老年代的比例</strong></p>
<p>我们可以自行配置新生代与老年代在堆结构的占比。</p>
<ul>
<li><p>默认：-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</p>
</li>
<li><p>可以修改为：-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</p>
</li>
</ul>
<p>一般情况下，我们不会去修改这个比例，如果我们明确知道生命周期较长或者较短的对象多，我们就可以调下这个新生代与老年代的比例。</p>
<p><strong>Eden空间、Survivor0空间和Survivor1空间的比例</strong></p>
<p>在HotSpot中，Eden 空间和另外两个Survivor空间缺省所占的比例是8:1:1，我们可以通过“-XX:SurvivorRatio”调整这个空间比例，比如-XX：SurvivorRatio=8。</p>
<blockquote>
<p>问题：默认是8:1:1，但是我们通过jvisualvm查看的时候，发现真实情况不是如此！</p>
</blockquote>
<p>真实情况是6:1:1，原因是这中间存在一个东西：<strong>自适应的机制</strong>。</p>
<img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200614221025.png" alt="image-20200614221024839" style="zoom：67%;" />

<blockquote>
<p>解决方案一：-XX:-UseAdaptiveSizePolicy：关闭自适应的内存分配策略（无效！）</p>
</blockquote>
<p>-UseAdaptiveSizePolicy表示关闭自适应机制，+UseAdaptiveSizePolicy表示开启自适应机制。我们设置好-XX:-UseAdaptiveSizePolicy这个参数后，发现还是无效！还是6:1:1！</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200614221254.png" alt="image-20200614221254586"></p>
<blockquote>
<p>解决方案二：用到-XX:SurvivorRatio=8，表示8:1:1，显式声明后有效！</p>
</blockquote>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200614221505.png" alt="image-20200614221505280"></p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200614221516" alt="image-20200524112228284"></p>
<blockquote>
<p>补充知识：</p>
</blockquote>
<ul>
<li><strong>几乎所有</strong>的Java对象都是在Eden区被new出来的。</li>
<li>绝大部分的Java对象的销毁都在新生代进行了。<br>➢IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</li>
<li>可以使用选项”-Xmn”设置新生代最大内存大小<ul>
<li>这个参数一般使用默认值就可以了。</li>
<li>如果又有-XX:NewRatio，又有-Xmn参数，两个就会矛盾，最终以Xmn为主。</li>
</ul>
</li>
</ul>
<h3 id="（4）图解对象分配过程"><a href="#（4）图解对象分配过程" class="headerlink" title="（4）图解对象分配过程"></a>（4）图解对象分配过程</h3><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<p><strong>对象分配过程：</strong></p>
<ol>
<li><p>新建对象放在Eden区（此区有大小限制）</p>
</li>
<li><p>当Eden区满时，此时触发垃圾回收机制（Minor GC或Young GC），将Eden区中不再被其他对象引用的对象进行回收，再加载新的对象放入Eden区</p>
</li>
<li><p>将Eden区中仍然被引用的对象移动到幸存者0区。</p>
<ul>
<li>注意：当Eden区满了出发Minor GC的时候，Minor GC也会回收幸存者0区的无效对象。</li>
</ul>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200615115201.png" alt="image-20200615115014074"></p>
<p>红色的是需要进行回收的，绿色的表示不需要回收，从图中可以看到，它被移入S0。</p>
</li>
<li><p>如果Eden区又满了，再次触发MinorGC，然后回收Eden区与幸存者0区的无效对象，那么幸存者0区有效的对象就不会被回收，我们会将它移动到幸存者1区。</p>
</li>
</ol>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200615115341.png" alt="image-20200615115340461"></p>
<p>​    Eden区满了，又进行一次Minor GC，是放在S0还是S1呢？是放在S1当中。因为S1为空，就称为to（表示空）。将Eden的绿色对象放入s1中后，此时S0中的绿色对象也要进行判断，当发现这俩还被占用，还不能被销毁，就把S0区的也放入S1区并增长为2。此时S0空了变为to区，s1变为from区，以此类推。</p>
<blockquote>
<p>什么时候能去老年代呢？</p>
</blockquote>
<p>可以设置参数-XX:MaxTenuringThreshold=<N>，默认是15。</p>
<p>什么意思呢？每个在新生代的对象有一个计数值，在垃圾回收的时候，如果他活下来了，他的计数值就会加1，当达到15的时候，它就会被移动到老年区。</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200615115937.png" alt="image-20200615115937322"></p>
<p>Eden又满了，就继续放入S0，S1进行判断，1号还用就放入S0。我们发现S1中有两个已经达到15了，就晋升至老年代，放入Old，此时就不进行判断它了。只有当有柱子再进入老年代的时候才进行判断。15称为阈值（临界值，默认的）</p>
<p>注意：<strong>幸存者区不会主动触发GC，它会被动回收</strong>！原因是：Eden区满时触发YGC，Eden触发GC的时候会将Eden与S区（属于被动）一起进行垃圾回收。</p>
<p>老年代一般很少有垃圾回收机制，当内存不足时，触发GC：Major GC，进行老年区的内<br>存清理。</p>
<p>执行了Major GC之 后发现依然无法进行对象的保存，<strong>就会产生OOM异常java.lang. OutOfMemoryError：Java heap space</strong></p>
<blockquote>
<p>总结：</p>
</blockquote>
<ul>
<li>针对幸存者s0,s1区的总结:复制之后有交换，谁空谁是to。</li>
<li>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集。</li>
</ul>
<blockquote>
<p>对象分配的特殊情况</p>
</blockquote>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200618105633" alt="image-20200524145910809"></p>
<p>通过图片可以很清楚的了解当Eden区放不下对象的时候，会怎么办。</p>
<p>需要注意的是：</p>
<ul>
<li>放不下就扔Old区。</li>
<li>当Old放不下的时候，会启动FGC。</li>
<li>当FGC后，Old还是放不下后，就会报OOM。</li>
</ul>
<blockquote>
<p>常用调优工具</p>
</blockquote>
<ul>
<li>JDK命令行</li>
<li>Eclipse ：Memory Analyzer Tool</li>
<li>Jconsole</li>
<li>VisualVM</li>
<li>Jprofiler</li>
<li>Java Flight Recorder</li>
<li>GCViewer</li>
<li>GC Easy</li>
</ul>
<h3 id="（5）Minor-GC、Major-GC、Full-GC"><a href="#（5）Minor-GC、Major-GC、Full-GC" class="headerlink" title="（5）Minor GC、Major GC、Full GC"></a>（5）Minor GC、Major GC、Full GC</h3><p>JVM在进行GC时，并非每次都对上面三个内存区域(新生代、老年代；方法区)一起回收的，大部分时候回收的都是指新生代（80%）。</p>
<p>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是<strong>部分收集</strong>(Partial GC)，一种是<strong>整堆收集</strong>(Full GC)。</p>
<p><strong>部分收集(Partial GC)：</strong>是完整收集整个Java堆的垃圾收集。其中又分为:</p>
<ul>
<li>新生代收集(Minor GC / Young GC) :只是新生代(Eden/S0,S1)的垃圾收集</li>
<li>老年代收集(Major GC / Old GC) :只是老年代的垃圾收集。<ul>
<li>目前，只有CMS GC会有单独收集老年代的行为。</li>
<li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代<br>回收还是整堆回收。</li>
</ul>
</li>
<li>混合收集(Mixed GC)：收集整个新生代以及部分老年代的垃圾收集。<ul>
<li>目前，只有G1 GC会有这种行为。</li>
</ul>
</li>
</ul>
<p>**整堆收集(Full GC)**：收集整个java堆和方法区的垃圾收集。</p>
<blockquote>
<p>年轻代GC触发条件</p>
</blockquote>
<ul>
<li>当年轻代空间不足时，就会触发Minor GC， 这里的年轻代满指的是Eden代满，Survivor满不会引发GC。( 每次Minor GC会清理年轻代的内存。)</li>
<li>因为Java 对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</li>
<li>Minor GC会引发STW， 暂停其它用户的线程，等垃圾回收结束，用户线<br>程才恢复运行。</li>
</ul>
<blockquote>
<p>老年代GC触发条件</p>
</blockquote>
<ul>
<li>指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”<br>发生了。</li>
<li>出现了Major GC，经常会伴随至少一次的Minor GC (但非绝对的，Parallel<br>Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。<ul>
<li>也就是在老年代空间不足时，会先尝试进行触发 Minor GC。如果之后空间还不足，则触发Major GC。</li>
</ul>
</li>
<li>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</li>
<li>如果Major GC后，内存还不足，就报OOM了。</li>
</ul>
<blockquote>
<p>Full GC触发条件</p>
</blockquote>
<ul>
<li>调用System.gc()时，系统建议执行Full GC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>
<li>由Eden区、survivor space0 ( From Space) 区向survivor space1 (To Space)区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ul>
<p>我们实际上希望出现GC情况少一些。GC也是垃圾回收的线程来做的，对应的另一个线程是用户线程（我们真正要执行代码所用到的线程）。GC的线程在判断哪些是垃圾的时候，会让用户线程做一个暂停，用户线程一暂停，程序执行的一个吞吐量就会差一些。减少GC就减少了这个STW的频率，用户就会被较少的干预到。重点关注Major GC和Full GC，因为他们两个所产生的暂停时间比Minor GC长</p>
<h3 id="（6）堆空间的分代思想"><a href="#（6）堆空间的分代思想" class="headerlink" title="（6）堆空间的分代思想"></a>（6）堆空间的分代思想</h3><blockquote>
<p>为什么需要把Java堆分代?不分代就不能正常工作了吗?</p>
</blockquote>
<ul>
<li>经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。<ul>
<li>新生代：有Eden、两块大小相同的Survivor(又称为from/to， s0/s1)构成，to总为空。</li>
<li>老年代：存放新生代中经历多次GC仍然存活的对象。</li>
</ul>
</li>
</ul>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200618145216" alt="image-20200527161159646"></p>
<ul>
<li>其实不分代完全可以，<strong>分代的唯一理由就是优化GC性能</strong>。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的 候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</li>
</ul>
<h3 id="（7）内存分配策略"><a href="#（7）内存分配策略" class="headerlink" title="（7）内存分配策略"></a>（7）内存分配策略</h3><p>内存分配策略也叫做对象提升（Promotion）原则</p>
<p>如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor<br>容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor区中每熬过一次MinorGC，年龄就增加1 岁，当它的年龄增加到一定程度(默认为15岁，其实每个JVM、每个GC都有所不同)时，就会被晋升到老年代中。<br>对象晋升老年代的年龄阈值，可以通过选项**-XX：MaxTenuringThreshold**来设置。</p>
<p>针对不同年龄段的对象分配原则如下所示:<br>● 优先分配到Eden</p>
<p>● 大对象直接分配到老年代</p>
<p>​    ➢尽量避免程序中出现过多的大对象</p>
<p>● 长期存活的对象分配到老年代</p>
<p>● 动态对象年龄判断<br>    ➢如果Survivor 区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
<p>● 空间分配担保<br>    ➢ -XX：HandlePromotionFailure<br><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200618154954" alt="image-20200527164220614"><br>如图所示，新建一个20M的对象，Eden区为16M，放不下，直接放到老年代。</p>
<h3 id="（8）为对象分配内存：TLAB"><a href="#（8）为对象分配内存：TLAB" class="headerlink" title="（8）为对象分配内存：TLAB"></a>（8）为对象分配内存：TLAB</h3><blockquote>
<p> 为什么有TLAB（Thread Local Allocation Buffer ）？</p>
</blockquote>
<ul>
<li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内<br>存空间是线程不安全的</li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li>
</ul>
<blockquote>
<p>什么是TLAB？</p>
</blockquote>
<ul>
<li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为<br>每个线程分配了一个私有缓存区域，它包含在Eden空间内。</li>
<li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</li>
<li>据说所有OpenJDK衍生出来的JVM都提供了TLAB的设计。<br><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200618155604" alt="image-20200527164854508"></li>
</ul>
<blockquote>
<p>TLAB的说明：</p>
</blockquote>
<ol>
<li>尽管不是所有的对象实例都能够在TLAB中成功分配内存（因为TLAB的空间相对来说还是比较小的），<strong>但JVM确实是TLAB作为内存分配的首选。</strong><ul>
<li>在程序中，开发人员可以通过选项“-XX:UseTLAB”设置是否开启TLAB空间（默认开启）。</li>
</ul>
</li>
<li>默认情况下，TLAB空间的内存非常小，**仅占有整个Eden空间的1%**，当然我们可以通过选项“-XX:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</li>
<li>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过<strong>使用加锁机制</strong>确保数据操作的原子性，从而直接在Eden空间中分配内存。</li>
</ol>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200618160009" alt="image-20200527170706159"></p>
<h3 id="（9）小结堆空间的参数设置"><a href="#（9）小结堆空间的参数设置" class="headerlink" title="（9）小结堆空间的参数设置"></a>（9）小结堆空间的参数设置</h3><p>官网说明</p>
<ul>
<li><p>-XX：+PrintFlagsInitial：查看所有的参数的默认初始值</p>
</li>
<li><p>-XX：+PrintFlagsFinal ：查看所有的参数的最终值(可能会存在修改,<br>不再是初始值)</p>
<ul>
<li>具体查看某个参数的指令：jps （ 查看当前运行的进程）</li>
<li>jinfo -flag SurviorRation 进程id</li>
</ul>
</li>
<li><p>-Xms：初始堆空间内存 (默认为物理内存的1/64)</p>
</li>
<li><p>-Xmx：最大堆空间内存(默认为物理内存的1/4)    </p>
</li>
<li><p>-Xmn：设置新生代的大小。(初始值及最大值)</p>
</li>
<li><p>-XX：NewRatio:配置新生代与老年代在堆结构的占比</p>
</li>
<li><p>-XX：SurvivorRatio:设置新生代中Eden和S0/S1空间的比例</p>
</li>
<li><p>-XX：MaxTenuri ngThreshold:设置新生代垃圾的最大年龄</p>
</li>
<li><p>-XX：+PrintGCDetails:输出详细的GC处理日志</p>
<ul>
<li>打印gc简要信息（两种方式）：①-XX：+PrintGC. ②-verbose:gc</li>
</ul>
</li>
<li><p>-XX：HandlePromotionFalilure:是否设置空间分配担保</p>
</li>
</ul>
<blockquote>
<p>关于SurvivorRatio的说明</p>
</blockquote>
<p>如果SurvivorRatio的值过大，那么Eden空间大，S区小，每经过一次Minor GC，S区都放不下存活的对象，这些对象就被直接转入老年代。这样Monor GC就失去了意义。因为S区一直是空的。</p>
<blockquote>
<p>关于空间分配担保的说明</p>
</blockquote>
<p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p>
<ul>
<li>如果大于，则此次Minor GC是安全的</li>
<li>如果小于，则虚拟机会查看-XX: HandlePromotionFai lure设置值是否允许担保失败</li>
<li>如果HandlePromotipnFailure=true，那么会继续检查老年代最大可<br>用连续空间是否大于历次晋升到老年代的对象的平均大小。<ul>
<li>如果大于，则尝试进行一次Minor GC， 但这次Minor GC依然是有风险的;</li>
<li>如果小于，则改为进行一次Full GC。</li>
</ul>
</li>
<li>如果HandlePromotionFailure=false， 则改为进行一次Full GC。</li>
</ul>
<p>在JDK6 Update24之后（JDK7），HandlePromot ionFailure参数不会再影响到虚拟机的空间分配担保策略，观察OpenJDK中的源码变化，虽然源码中还定义了HandlePromot ionFailure参数，但是在代码中已经不会再使用它。JDK6 Update24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。也就是默认为true。</p>
<h3 id="（10）堆是分配对象的唯一选择吗"><a href="#（10）堆是分配对象的唯一选择吗" class="headerlink" title="（10）堆是分配对象的唯一选择吗"></a>（10）堆是分配对象的唯一选择吗</h3><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述:<br>随着JIT编译期的发展与<strong>逃逸分析技术</strong>逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，<strong>所有的对象都分配到堆上也渐渐变得不那么“绝对”了</strong>。</p>
<p>在Java虛拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析(Escape Analysis) 后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。</strong>这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>
<p>此外，前面提到的基于openJDK深度定制的TaoBaoVM，其中创新的GCIH (GC invisible heap) 技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低Gc的回收频率和提升GC的回收效率的目的。</p>
<p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p>
<p>通过逃逸分析，JavaHotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<p>逃逸分析的基本行为就是分析对象动态作用域:</p>
<ul>
<li>当一个对象在方法中被定义后，<strong>对象只在方法内部使用，则认为没有</strong><br><strong>发生逃逸。</strong></li>
<li>当一个对象在方法中被定义后，<strong>它被外部方法所引用，则认为发生逃</strong><br>逸。例如作为调用参数传递到其他地方中。</li>
</ul>
<blockquote>
<p>逃逸分析的参数设置</p>
</blockquote>
<p>在JDK 6u23（JDK7）版本之后，HotSpot中默认就已经开启了逃逸分析。<br>如果使用的是较早的版本，开发人员则可以通过:</p>
<ul>
<li>选项“-XX: +DoEscapeAnalysis” 显式开启逃逸分析</li>
<li>通过选项“-XX: +PrintEscapeAnalysis”查看逃逸分析的筛选结果</li>
</ul>
<blockquote>
<p>代码优化：逃逸分析之栈上分配</p>
</blockquote>
<p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p>
<blockquote>
<p>代码优化：逃逸分析之同步省略</p>
</blockquote>
<ul>
<li>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</li>
<li>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</li>
</ul>
<img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619152221" alt="image-20200528133246945" style="zoom:50%;" />

<p>但是我们查看字节码文件，会发现同步代码块的字节码还是存在的。</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619152351" alt="image-20200528134535753"></p>
<blockquote>
<p>代码优化：逃逸分析之标量替换</p>
</blockquote>
<p><strong>标量</strong>是指一个无法分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，可以再分解的叫做<strong>聚合量，Java中的对象就是聚合量。</strong></p>
<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来替代。这个过程就是标量替换。</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619152903.png" alt="image-20200619152903517"></p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619152912" alt="image-20200528134905654"></p>
<p>用两个标量去替换了原来的对象，就不需要在堆上给对象分配空间了，直接在栈中的局部变量表分配空间就好了，也就没有了GC，因为虚拟机栈是没有垃圾回收的。</p>
<blockquote>
<p>总结</p>
</blockquote>
<p>关于逃逸分析，可能会使用到以下参数：</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619153753.png" alt="image-20200619153753537"></p>
<p>注意-server可以省略掉，因为我的JVM本身就是在Server模式的。</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619153931.png" alt="image-20200619153931366"></p>
<p><strong>开发中能使用局部变量的，就不要使用在方法外定义。</strong>从而避免逃逸。</p>
<p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也<strong>不成熟</strong>。<br>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是<strong>逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong><br>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。<br>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。<br>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据所知，<strong>Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上</strong>。</p>
<p>目前很多书籍还是基于JDK 7以前的版本，JDK已经发生了很大变化，字符串常量和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，字符串常量和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论:对象实例都是分配在堆上。</p>
<h3 id="（11）堆空间总结"><a href="#（11）堆空间总结" class="headerlink" title="（11）堆空间总结"></a>（11）堆空间总结</h3><ul>
<li>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</li>
<li>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上;</li>
<li>如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</li>
<li>当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGC。当GC发生在老年代时则被称为MajorGC或者FullGC。 一般的，MinorGC的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</li>
</ul>
<hr>
<h2 id="6-方法区"><a href="#6-方法区" class="headerlink" title="6. 方法区"></a>6. 方法区</h2><h3 id="（1）栈、堆、方法区的交互关系"><a href="#（1）栈、堆、方法区的交互关系" class="headerlink" title="（1）栈、堆、方法区的交互关系"></a>（1）栈、堆、方法区的交互关系</h3><p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619171053" alt="image-20200604135724895"></p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619171229.png" alt="image-20200619171228915"></p>
<p>Jdk 1.8之后用元空间取代了永久代（方法区的实现，方法区是一种规范，永久代是方法区的实现）</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619172614" alt="image-20200604145945327"></p>
<p>上图已经很清晰明了了！</p>
<h3 id="（2）方法区的理解"><a href="#（2）方法区的理解" class="headerlink" title="（2）方法区的理解"></a>（2）方法区的理解</h3><p><a class="link"   target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4" >官方文档地址<i class="fas fa-external-link-alt"></i></a></p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619172857.png" alt="image-20200619172857191"></p>
<center>官方文档对方法区的解释</center>



<blockquote>
<p>翻译：</p>
</blockquote>
<p>Java虚拟机有一个在所有Java虚拟机线程之间共享的方法区。方法区类似于传统语言编译代码的存储区域，或类似于操作系统进程中的“文本”段。它存储每个类的结构，比如运行时常量池、属性和方法数据，以及方法和构造函数的代码，包括在类、实例接口初始化中使用的特殊方法。</p>
<p>方法区是在虚拟机启动时创建的。虽然方法区在逻辑上是堆的一部分，但一些简单的实现可能不会去选择进行垃圾收集或压缩。该规范没有规定方法区的位置或用于管理已编译代码的策略。方法区可以是固定大小，也可以根据计算的需要进行扩展，如果不需要更大的方法区，则可以缩小。方法区的内存不需要是连续的。</p>
<p>Java虚拟机实现可以为程序员或用户提供对方法区初始大小的控制，以及在方法区大小可变的情况下，可以控制最大和最小方法区的大小。</p>
<p>以下异常情况与方法区相关:</p>
<ul>
<li>如果方法区中的内存无法满足分配请求，Java虚拟机将抛出OutOfMemoryError错误。</li>
</ul>
<blockquote>
<p>方法区在哪里？</p>
</blockquote>
<p>《Java虚拟机规范》中明确说明:“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap (非堆)，目的就是要和堆分开。</p>
<p>所以，方法区看做是一块独立于Java堆的内存空间。</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619174517" alt="image-20200604152637450"></p>
<blockquote>
<p>方法区的基本理解</p>
</blockquote>
<ul>
<li>方法区(MethodArea)与Java堆一样，是各个线程共享的内存区域。（意思是既然是一个共享区域，如果这个类没有加载的话，只能有一个线程去调用ClassLoader，其他线程想要使用这个类的话就必须得等待。即我们只需要加载一次）</li>
<li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误: java. lang .OutofMemoryError:PermGen space 或者java. lang.OutOfMemoryError:Metaspace</li>
<li>关闭JVM就会释放这个区域的内存。</li>
</ul>
<h3 id="（3）设置方法区大小与OOM"><a href="#（3）设置方法区大小与OOM" class="headerlink" title="（3）设置方法区大小与OOM"></a>（3）设置方法区大小与OOM</h3><h3 id="（4）方法区的内部结构"><a href="#（4）方法区的内部结构" class="headerlink" title="（4）方法区的内部结构"></a>（4）方法区的内部结构</h3><h3 id="（5）方法区使用实例"><a href="#（5）方法区使用实例" class="headerlink" title="（5）方法区使用实例"></a>（5）方法区使用实例</h3><h3 id="（6）方法区的演进细节"><a href="#（6）方法区的演进细节" class="headerlink" title="（6）方法区的演进细节"></a>（6）方法区的演进细节</h3><ul>
<li><p>在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始， 使用元空间取代了永久代。（可以把方法区当成接口，永久带或者元空间当作实现）</p>
<blockquote>
<p>In JDK 8, casses metadata is now stored in the native heap and this space is called Metaspace.</p>
</blockquote>
</li>
<li><p>本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java 虚拟规范》对如何实现方法区，不做统一要求。例如: BEA JRockit/ IBM J9中不存在永久代的概念。</p>
<ul>
<li>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOM （超过-XX :MaxPermSize.上限）</li>
</ul>
</li>
</ul>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619175839" alt="image-20200604154937740"></p>
<p>而到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在<strong>本地</strong><br><strong>内存中</strong>实现的元空间(Metaspace)来代替。</p>
<p><img src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619175917" alt="image-20200604155221247"></p>
<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存。</strong></p>
<p>永久代、元空间二者并不只是名字变了，内部结构也调整了。</p>
<p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。</p>
<h3 id="（7）方法区的垃圾回收"><a href="#（7）方法区的垃圾回收" class="headerlink" title="（7）方法区的垃圾回收"></a>（7）方法区的垃圾回收</h3><h3 id="（8）总结"><a href="#（8）总结" class="headerlink" title="（8）总结"></a>（8）总结</h3>
        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：JVM（一）内存与垃圾回收篇</li>
        <li>Post author：Hoven</li>
        <li>Create time：2020-06-01 15:32:00</li>
        <li>
            Post link：https://zhenghaoyun.cn/JVM/JVM（一）内存与垃圾回收篇
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/MySQL/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">MySQL高级篇笔记（一）MySQL存储引擎</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/Docker/Docker%E4%B8%80%E6%8E%A2%E7%A9%B6%E7%AB%9F"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Docker一探究竟</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;Comments</i>
    </div>
    

        
            
    <div class="valine-container">
        <script 
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script >
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'uffz9vWTIQhDc1YbAjAndspC-gzGzoHsz',
                    appKey: 'KQwbThRfP3cQIJYoLHMIqXLX',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '',
                    lang: 'zh-Hans'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Hoven';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('false') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2019</span>&nbsp;-&nbsp;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Hoven</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.2</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">一、JVM体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-text">1. 字节码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%A4%9A%E8%AF%AD%E8%A8%80%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B"><span class="nav-text">2. 多语言混合编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8EJava%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-text">3. 虚拟机与Java虚拟机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-JVM%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-text">4. JVM的位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-JVM%E7%9A%84%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="nav-text">5. JVM的整体结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-JVM%E7%9A%84%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B"><span class="nav-text">6. JVM的架构模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-JVM%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">7. JVM的生命周期</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="nav-text">二、类加载子系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="nav-text">1. 内存结构概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">2. 类加载子系统的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8ClassLoader%E8%A7%92%E8%89%B2"><span class="nav-text">3. 类加载器ClassLoader角色</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-text">4. 类的加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%8A%A0%E8%BD%BD"><span class="nav-text">（1）加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E9%93%BE%E6%8E%A5"><span class="nav-text">（2）链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">（3）初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">5. 类加载器的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%88%86%E7%B1%BB"><span class="nav-text">（1）分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%87%AA%E5%B8%A6%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">（2）虚拟机自带的加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">（3）用户自定义类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E5%85%B3%E4%BA%8EClassLoader"><span class="nav-text">（4）关于ClassLoader</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-text">6. 双亲委派机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%8E%9F%E7%90%86"><span class="nav-text">（1）原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%A4%BA%E4%BE%8B"><span class="nav-text">（2）双亲委派机制示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E7%A8%8B%E5%BA%8F%E5%AE%89%E5%85%A8"><span class="nav-text">保护程序安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E5%9C%A8SPI%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">双亲委派机制在SPI中的应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-text">（3）双亲委派机制的优势</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="nav-text">7. 沙箱安全机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E7%B1%BB%E7%9A%84%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="nav-text">8. 类的主动使用与被动使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E5%85%B6%E4%BB%96"><span class="nav-text">9. 其他</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="nav-text">三、运行时数据区</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Java%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E4%BB%8B%E7%BB%8D"><span class="nav-text">1. Java内存分区介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-text">2. 程序计数器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%BD%9C%E7%94%A8"><span class="nav-text">（1）作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="nav-text">（2）举例说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="nav-text">（3）相关问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-text">3. 虚拟机栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%83%8C%E6%99%AF"><span class="nav-text">（1）虚拟机背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9"><span class="nav-text">（2）虚拟机栈基本内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E8%AE%BE%E7%BD%AE%E6%A0%88%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="nav-text">（3）设置栈的内存大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-text">（4）栈的存储结构和运行原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E6%A0%88%E5%B8%A7%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-text">（5）栈帧的内部结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="nav-text">局部变量表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="nav-text">操作数栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-text">动态链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="nav-text">方法返回地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="nav-text">一些附加信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%886%EF%BC%89%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%84%E4%BA%94%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-text">（6）虚拟机栈的五道面试题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-text">4. 本地方法栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="nav-text">（1）本地方法概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E6%A6%82%E8%BF%B0"><span class="nav-text">（2）本地方法栈概述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%A0%86%E7%A9%BA%E9%97%B4"><span class="nav-text">5. 堆空间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E8%BF%B0"><span class="nav-text">（1）堆的核心概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%BB%86%E5%88%86"><span class="nav-text">内存细分</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E8%AE%BE%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E4%B8%8EOOM"><span class="nav-text">（2）设置堆内存大小与OOM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98"><span class="nav-text">堆内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OOM"><span class="nav-text">OOM</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%B9%B4%E8%BD%BB%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-text">（3）年轻代与老年代</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-text">参数设置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E5%9B%BE%E8%A7%A3%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="nav-text">（4）图解对象分配过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89Minor-GC%E3%80%81Major-GC%E3%80%81Full-GC"><span class="nav-text">（5）Minor GC、Major GC、Full GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%886%EF%BC%89%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E4%BB%A3%E6%80%9D%E6%83%B3"><span class="nav-text">（6）堆空间的分代思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%887%EF%BC%89%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-text">（7）内存分配策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%888%EF%BC%89%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%EF%BC%9ATLAB"><span class="nav-text">（8）为对象分配内存：TLAB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%889%EF%BC%89%E5%B0%8F%E7%BB%93%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-text">（9）小结堆空间的参数设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%8810%EF%BC%89%E5%A0%86%E6%98%AF%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%94%AF%E4%B8%80%E9%80%89%E6%8B%A9%E5%90%97"><span class="nav-text">（10）堆是分配对象的唯一选择吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%8811%EF%BC%89%E5%A0%86%E7%A9%BA%E9%97%B4%E6%80%BB%E7%BB%93"><span class="nav-text">（11）堆空间总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-text">6. 方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB"><span class="nav-text">（1）栈、堆、方法区的交互关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text">（2）方法区的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%8EOOM"><span class="nav-text">（3）设置方法区大小与OOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-text">（4）方法区的内部结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E6%96%B9%E6%B3%95%E5%8C%BA%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-text">（5）方法区使用实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%886%EF%BC%89%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B%E7%BB%86%E8%8A%82"><span class="nav-text">（6）方法区的演进细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%887%EF%BC%89%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">（7）方法区的垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%888%EF%BC%89%E6%80%BB%E7%BB%93"><span class="nav-text">（8）总结</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
