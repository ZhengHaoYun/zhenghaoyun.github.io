<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="博客,编程,代码,Java,空间,记录">
    <meta name="description" content="郑皓云的个人博客,博客,编程,代码,Java,空间,记录">
    <meta name="author" content="Hoven">
    
    <title>
        
            JUC并发编程学习笔记[全] |
        
        好运的云
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/favicon.png">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"zhenghaoyun.cn","root":"/","language":"zh-Hans","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.png","favicon":"/images/favicon.png","article_img_align":"center","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.2"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                好运的云
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">JUC并发编程学习笔记[全]</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Hoven</span>
                        
                            <span class="author-label">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2020-05-01 11:55:20
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/JUC/">JUC</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/JUC/">JUC</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>本笔记录了有关JUC的很多知识点，笔记做的比较匆忙，如果发现有任何问题都可以在评论区指出来。</p>
<span id="more"></span>

<h1 id="初识JUC"><a href="#初识JUC" class="headerlink" title="初识JUC"></a>初识JUC</h1><h2 id="JUC概述"><a href="#JUC概述" class="headerlink" title="JUC概述"></a>JUC概述</h2><p>JUC是Java中<code>java.util.concurrent</code>包中线程的高级应用，简称JUC，业内人士都读作钩优C~虽然我也不知道这个读法哪来打，但是我看的教程里面都是这么读的哈哈哈…</p>
<p>JUC是从<code>JAVA 1.5</code>开始出现的，在此包中增加了在并发编程中的实用工具类，如<code>BlockingQueue</code>、<code>Callable</code>呀等等，还提供了线程池、异步IO和轻量级任务框架等等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/07/yvLhFpmz63gZBCj.png"
                     
                ></p>
<p>在学习JUC之前，需要先了解下线程与进程的区别，并发与并行的区别。</p>
<h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><p>线程：程序执行的最小单位，是CPU调度的最小单位。</p>
<p>进程：操作系统分配资源的最小单位。</p>
<p>这样一说真的很抽象，必须打点比方才能迅速又深刻的记住二者的区别。</p>
<p>打开windows任务管理器，可以看到线程比进程的数量多出几倍，可以大胆的猜测进程与线程是父子关系，一个进程包括多个线程。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/07/v6pFyMqZiGDHw2X.png"
                      alt="image-20200507215629871"
                ></p>
<p>接下来引用知乎上的一个形象的比喻：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/07/Qk6BbXo9FLuC72t.png"
                      alt="image-20200507215953786" style="zoom:80%;" /
                >

<center>图片来源于知乎</center>

<p>是不是生动形象了很多？</p>
<p>不过我认为对于线程和进程可以有更深层次的理解，本人对线程与进程的理解也仅限于此，望日后有空可以深究。</p>
<hr>
<h3 id="JAVA是否可以开启线程？"><a href="#JAVA是否可以开启线程？" class="headerlink" title="JAVA是否可以开启线程？"></a>JAVA是否可以开启线程？</h3><p>答案是开不了，来看看源码吧！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/07/pfjTX4FPNWxCMZa.png"
                      alt="image-20200507223222900"
                ></p>
<p>从关键字<code>native</code>中可以看出Thread源码中查看到Java启动线程的方法是调用的本地方法，所以Java是没本事自己开启线程的！</p>
<hr>
<h3 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h3><p>再次通过源码说事</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/07/MxNhmFlYbzGSe6w.png"
                      alt="image-20200507223438570"
                ></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;    </span><br><span class="line">	<span class="comment">// 新生    </span></span><br><span class="line">	NEW,</span><br><span class="line">	<span class="comment">// 运行    </span></span><br><span class="line">	RUNNABLE,</span><br><span class="line">    <span class="comment">// 阻塞    </span></span><br><span class="line">    BLOCKED,        </span><br><span class="line">    <span class="comment">// 等待，死死地等    </span></span><br><span class="line">    WAITING,</span><br><span class="line">    <span class="comment">// 超时等待    </span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    <span class="comment">// 终止    </span></span><br><span class="line">    TERMINATED; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并发：指两个或多个事件在很短的时间间隔内交替发生。</p>
<p>并行：指两个或多个事件在同一时刻同时执行。</p>
<p>如果觉得还是有点模糊，再看下面两张图，这样就不难理解了吧。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/16/T4JbGu3woe98VfM.png"
                      alt="image-20200507221751892"
                ></p>
<center>并发</center>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/16/uc52y93RhTjDnQ4.png"
                      alt="image-20200507221734140"
                ></p>
<center>并行</center>

<p>更具体的说并发就是一个处理器一次只能执行一个进程，但是它飞快的切换进程（也就是分配给每个进程的时间片很短，不，是非常短！），形成一种它同时在处理多个进程的错觉。</p>
<p>所以对于并发有一种更为高级也更为精炼的解释：<strong>宏观上并行，微观上串行！</strong></p>
<p>而并行呢，就是多个处理器同时处理多个进程，这就是实打实的同时处理。</p>
<hr>
<p>并发编程的实质就是充分利用CPU资源，就好比企业要挣钱，就要提高效率，就要找一个厉害的人去顶替三个不厉害的人，人员减少了，但是技术成本也提高了。</p>
<h1 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h1><p>在没学习JUC之前，要做到同步互斥，就要使用到<code>synchronized</code>。现在可以使用JUC内的LOCK接口。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/07/92z3cVRivdOW4t8.png"
                      alt="image-20200507230349274"
                ></p>
<p>LOCK接口是JUC包内的一个接口，它有三个实现类：</p>
<ul>
<li>ReentrantLock：可重入锁</li>
<li>ReadLock：读锁</li>
<li>WriteLock：写锁</li>
</ul>
<h2 id="高内聚低耦合"><a href="#高内聚低耦合" class="headerlink" title="高内聚低耦合"></a>高内聚低耦合</h2><p>在进行多线程开发的时候，讲究的是高内聚低耦合，那么什么是高内聚和低耦合呢？</p>
<h3 id="高内聚"><a href="#高内聚" class="headerlink" title="高内聚"></a>高内聚</h3><p>高内聚指的是某个特定的软件模块内部包含一系列关系极其相关的功能，就比如说定义一个Class，里面包含了诸多的成员变量和方法，这些方法可以供外部使用，这就叫做高内聚。</p>
<p>再打个生活上的部分，就如同你的电脑主机，主机内部的复杂组件被封装在主机里面，主机外部有很多插口，可以接屏幕、接鼠标、接网线等等，我们只能使用其暴露在外部的插口等，这就是高内聚。</p>
<h3 id="低耦合"><a href="#低耦合" class="headerlink" title="低耦合"></a>低耦合</h3><p>低耦合是指模块之间的依赖程度低，假如有两个模块A和B，如果每次修改A都要修改B，那么A和B之间就是强耦合。我们要尽量避免这种情况，就如同主机和屏幕，主机不连接屏幕，电脑的使用就会很复杂，可以说是无法使用，这种耦合性就很强。但是U盘和主机就几乎没什么关系吧，这就是低耦合。</p>
<hr>
<p>多线程操作的高内聚低耦合的实质就是<strong>线程-&gt;操作-&gt;资源类</strong></p>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p>这里使用售票员卖票作为例子，首先定义一个Ticket，这个Ticket类就是资源类，它只包含必须的属性与方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 资源类 OOP </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;    </span><br><span class="line">	<span class="comment">// 属性、方法    </span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 卖票的方式    </span></span><br><span class="line">    <span class="comment">// synchronized 本质: 队列，锁    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;        </span><br><span class="line">        <span class="keyword">if</span> (number&gt;<span class="number">0</span>)&#123;            </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖出了&quot;</span>+(number-)+<span class="string">&quot;票,剩余：&quot;</span>+number);        </span><br><span class="line">    	&#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了防止多个线程卖票的时候去查询剩余票量时出现混乱，在这里使用<code>synchronized</code>加锁，使得只能有一个线程进入此方法，现在创建三个售票员分别来卖票试试吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) ticket.sale();</span><br><span class="line">    &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) ticket.sale();</span><br><span class="line">    &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) ticket.sale();</span><br><span class="line">    &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后输出的结果有序且正确：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/08/hwytfrnJHcVZlzu.png"
                      alt="image-20200508000012987"
                ></p>
<h2 id="Lock锁介绍"><a href="#Lock锁介绍" class="headerlink" title="Lock锁介绍"></a>Lock锁介绍</h2><p>然后再使用LOCK来上锁试试吧，LOCK接口最常用的实现类就是<strong>可重入锁</strong>（ReentrantLock），查看<code>ReentrantLock</code>源码可以看到有两种构造方法，默认的无参构造是<code>new NonfairSync()</code>，这个东西叫做非公平锁，第二种构造方法传入一个布尔值，这个布尔值决定是创建<code>FairSync</code>（公平锁）还是<code>NonfairSync</code>（非公平锁）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/24/sOEApzy9ol2tZCH.png"
                      alt="image-20200508000145805"
                ></p>
<h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>那么什么是公平锁与非公平锁？</p>
<p>公平锁：当某个线程拿到锁的时候，其他线程就得等待，这些等待的线程按到的顺序序排着长队，当锁释放的时候，排在队伍前面的线程就先去拿锁。</p>
<p>非公平锁：就是非常的不公平，当锁释放的时候，等待的线程可以进行插队。</p>
<h3 id="ReentrantLock的使用"><a href="#ReentrantLock的使用" class="headerlink" title="ReentrantLock的使用"></a>ReentrantLock的使用</h3><p>查看官方文档</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/08/oyThIsKv3B8ltqe.png"
                      alt="image-20200508001641852"
                ></p>
<p>大概的意思就是先定义可重入锁，然后在方法中用try-catch-finally包围起来，try和finally必须要有，finally块中需要将锁进行解锁，代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                num--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出了第&quot;</span> + (<span class="number">30</span> - num) + <span class="string">&quot;票\t还剩&quot;</span> + num + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论如何都要进行解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h2><p>其实从上面的代码上来看，使用LOCK也不简单，甚至说代码比synchronized还多一点，那为什么还要使用LOCK呢？自然而然就想到去探索下两者的区别：</p>
<ol>
<li>Synchronized 是内置的Java关键字，Lock 是一个Java类。</li>
<li>Synchronized 无法判断获取锁的状态，Lock 可以判断是否获取到了锁。</li>
<li>Synchronized 会自动释放锁，Lock 必须要手动释放锁！如果不释放锁，会导致死锁。</li>
<li>Synchronized  线程 1（获得锁，阻塞）、线程2（等待，傻傻的等）；Lock锁就不一定会等待下去；</li>
<li>Synchronized  是可重入锁，不可以中断的，非公平；Lock ，也是可重入锁，可以判断锁，非公平（可以 自己设置）；</li>
<li>Synchronized  适合锁少量的代码同步问题，Lock  适合锁大量的同步代码。</li>
</ol>
<p>用B站狂神的话来讲就是：</p>
<blockquote>
<p>任何一个新的技术，绝对不是仅仅只是覆盖了原来的技术，它是优势和补充！</p>
</blockquote>
<h1 id="生产者和消费者问题"><a href="#生产者和消费者问题" class="headerlink" title="生产者和消费者问题"></a>生产者和消费者问题</h1><p>生产者和消费者问题是非常常见的一种问题，这个问题的意思是有一个生产者和一个消费者，生产者负责生产资源，消费者负责消费资源，二者协同合作，维持资源的稳定数目。</p>
<h2 id="传统-Synchronized-实现"><a href="#传统-Synchronized-实现" class="headerlink" title="传统 Synchronized 实现"></a>传统 Synchronized 实现</h2><p>生产者和消费者问题的解决思路就在这里简述下吧，这不是本次学习的重点。</p>
<ol>
<li>资源的数目初始化为0。</li>
<li>生产者检测资源的数目是否为0，如果为0则进行生产，如果不为0则等待。</li>
<li>假设生产者生产资源后，资源的数目变为1。</li>
<li>消费者检测到资源的数目大于0，于是进行消费，让资源的数目减1。</li>
<li>如果消费者检测到资源的数目不大于0 ，则也继续等待，等待生产者生产资源。</li>
</ol>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        <span class="comment">// A进程负责生产，B进程负责消费。</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用synchronized对方法加锁，保证每次只能有一个线程进入。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 num 不为0，就没有生产（增加）的必要了。</span></span><br><span class="line">            <span class="comment">//线程等待，同时wait()方法会释放掉锁。</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;&gt;&quot;</span> + num);</span><br><span class="line">        <span class="comment">// 将num++后可唤醒在decrement()方法中等待的线程，让其去num--。</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// decrement的思路和increment差不多</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        num--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;&gt;&quot;</span> + num);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过输出结果可以看到资源一直维持在0与1。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/08/A2qlIkaOLYPevBj.png"
                      alt="image-20200508175242801"
                ></p>
<h3 id="虚假唤醒问题"><a href="#虚假唤醒问题" class="headerlink" title="虚假唤醒问题"></a>虚假唤醒问题</h3><p>上面的代码其实是有问题的，注意到我是使用<code>if (num != 0)</code>去判断资源的数目的，这就会存在一个问题：<strong>虚假唤醒</strong>。</p>
<h4 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h4><p>之前只有一个A进程和一个B进程，现在我再增加一个C进行，让它去生产。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.increment();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;C&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>再次运行，通过输出结果可以看到资源的数目乱套了！它不再维持0和1这里两个数字，反而增加到10以上了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/08/e8FW9ojwPJvbTD4.png"
                      alt="image-20200508175916400"
                ></p>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>这就是因为是使用<code>if (num != 0)</code>的原因，假设此时的num为1，那么A和C进程就会等待。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/08/NguHmJqX5t4Y63A.png"
                      alt="image-20200508181751879"
                ></p>
<p>有同学会说，不是使用了synchronized来保证只有一个线程会进入吗，那A和C怎么会一起在等待，是这样的没错，但是使用wait()后，线程就会释放掉锁，那么其他进程就也可以进入此方法。假如A先进来，然后进行wait()，释放掉锁，C抢到锁，再次进来，也发现num != 0，于是A和C就一起在此等待了。</p>
<p>这个时候A和C都在等待，B抢到锁开始做消费的操作，num–后，B唤醒其他的所有进程。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/08/aQCoigjkzNrFswP.png"
                      alt="image-20200508180507682"
                ></p>
<p>A和C被唤醒，A和C也开始争夺锁，假如A抢到锁，继续执行下面的代码，A将num+1，并且唤醒其他进程，C抢到锁，那C也会将num+1，这个时候num就变成2了，这就是虚假唤醒问题。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>首先看看官方文档对于虚假唤醒的解释和解决吧~</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/08/HIGVTESKdA1qBkF.png"
                      alt="image-20200508175645521"
                ></p>
<center>官方文档中对于虚假唤醒的解决方案</center>

<p>只要将if换成while就可以了！这是因为if只会进行一次判断，线程被唤醒后就继续执行下面的代码，而while会多次判断，直至不满足while(条件)的条件后，线程才能走出while，所以当处于等待中的A和C被唤醒后，假设A抢到锁，它还是会去判断num是否为0，C抢到锁，也会去判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用synchronized对方法加锁，保证每次只能有一个线程进入。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果 num 不为0，就没有生产（增加）的必要了。</span></span><br><span class="line">        <span class="comment">//线程等待，同时wait()方法会释放掉锁。</span></span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;&gt;&quot;</span> + num);</span><br><span class="line">    <span class="comment">// 将num++后可唤醒在decrement()方法中等待的线程，让其去num--。</span></span><br><span class="line">    <span class="keyword">this</span>.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// decrement的思路和increment差不多</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    num--;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;&gt;&quot;</span> + num);</span><br><span class="line">    <span class="keyword">this</span>.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次执行，发现结果很美好。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/08/PrA3VBNmYOxM8IT.png"
                      alt="image-20200508182210561"
                ></p>
<h2 id="JUC版本的实现"><a href="#JUC版本的实现" class="headerlink" title="JUC版本的实现"></a>JUC版本的实现</h2><p>看官方文档可以发现Lock可以调用newCondition()方法得到一个Condition对象，这个Condition就是负责对线程的监控。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/08/fykKhbaJFIVHQOE.png"
                      alt="image-20200508183824433"
                ></p>
<p>再来看看Condition的API吧</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/08/sfZ5TA8nwBNtzI4.png"
                      alt="image-20200508183918001"
                ></p>
<p>直接上代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Lock和Condition实现生产者消费者问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;&gt;&quot;</span> + num);</span><br><span class="line">            condition.signalAll();  <span class="comment">//唤醒所有</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;&gt;&quot;</span> + num);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行 达到了同样的效果</p>
<h2 id="使用Condition实现精准唤醒"><a href="#使用Condition实现精准唤醒" class="headerlink" title="使用Condition实现精准唤醒"></a>使用Condition实现精准唤醒</h2><p>再次引用那句话！</p>
<blockquote>
<p>任何一个新的技术，绝对不是仅仅只是覆盖了原来的技术，它是优势和补充！</p>
</blockquote>
<p>之所以使用Condition是因为Condition非常的强大，假设在做一种流水线生产，A做完后通知B继续，B做完后通知C继续，必须保证这种顺序，就可以使用Condition去实现。</p>
<p>上代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 精准唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1-A 2-B 3-C</span></span><br><span class="line">    <span class="comment">//num为1时A工作，2时B工作，3时C工作。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">1</span>) &#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="number">2</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;&gt;&quot;</span> + num);</span><br><span class="line">            <span class="comment">// 通知B去工作</span></span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">2</span>) &#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="number">3</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;&gt;&quot;</span> + num);</span><br><span class="line">            <span class="comment">// 通知C去工作</span></span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">3</span>) &#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;&gt;&quot;</span> + num);</span><br><span class="line">            <span class="comment">// 通知A去工作</span></span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Data data = <span class="keyword">new</span> Data();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            data.printA();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            data.printB();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            data.printC();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/08/wdIoNKM5XPU2pmG.png"
                      alt="image-20200508185149073"
                ></p>
<p>可以看到实现了A-&gt;B-&gt;C的有序工作。</p>
<h1 id="8锁现象"><a href="#8锁现象" class="headerlink" title="8锁现象"></a>8锁现象</h1><p>不知道大家在使用锁的时候有没有想过锁究竟是什么？它到底锁的是什么？这次通过8锁现象可以对锁来一次深层次的了解。</p>
<p>8锁现象就是关于锁的8种问题</p>
<h3 id="现象1-多个线程使用一把锁-无阻塞"><a href="#现象1-多个线程使用一把锁-无阻塞" class="headerlink" title="现象1-多个线程使用一把锁-无阻塞"></a>现象1-多个线程使用一把锁-无阻塞</h3><p>下面这种情况会先打电话还是先发短信呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="comment">//A负责发短信</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; phone.send(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 休眠一秒，使得A线程先拿到锁。</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//B负责打电话</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; phone.call(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Phone中有两个方法，一个是发短信，一个是打电话。都加了锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//发信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打电话</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行多次后发现都是先发短信再打电话，这说明了谁先拿到锁，就先执行。锁的对象是方法的调用者，也就是phone，所以A和B线程使用的是同一把锁，而A线程先拿到锁，所以它先执行。</p>
<h3 id="现象2-多个线程使用同一把锁（其中一个线程被阻塞）"><a href="#现象2-多个线程使用同一把锁（其中一个线程被阻塞）" class="headerlink" title="现象2-多个线程使用同一把锁（其中一个线程被阻塞）"></a>现象2-多个线程使用同一把锁（其中一个线程被阻塞）</h3><p>试试将发短信的线程休眠几秒</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现还是运行结果还是先发短信</p>
<p>因为锁的是phone，多个线程调用phone的方法，也就是使用同一把锁，谁先拿到锁就先执行，即使其中有阻塞。</p>
<h3 id="现象3-调用普通方法"><a href="#现象3-调用普通方法" class="headerlink" title="现象3-调用普通方法"></a>现象3-调用普通方法</h3><p>在Phone中增加一个普通方法read(),增加一个线程去调用read()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//A负责发短信</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; phone.send(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//B负责打电话</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; phone.call(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="comment">//C负责看书</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; phone.read(), <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Phone中有两个方法，一个是发短信，一个是打电话。都加了锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//发信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打电话</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未加锁的方法：读书</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;读书&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行多次后发现是先读书，因为普通方法没有加锁，所以不受限制，它不会去等待发信息的线程休眠3秒完后再去执行，而打电话的线程无论如何都会等待发消息的线程休眠完毕后再执行。</p>
<h3 id="现象4-多个线程使用多把锁"><a href="#现象4-多个线程使用多把锁" class="headerlink" title="现象4-多个线程使用多把锁"></a>现象4-多个线程使用多把锁</h3><p>现在使用两部phone，A使用phone1，B使用phone2，是会先发短信还是先打电话呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//A负责发短信</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; phone1.send(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//B负责打电话</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; phone2.call(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Phone中有两个方法，一个是发短信，一个是打电话。都加了锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//发信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打电话</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>锁的是方法的调用者，两部phone就是两把锁，相互之间不干扰，所以最后先打电话。</p>
<h3 id="现象5-添加静态方法"><a href="#现象5-添加静态方法" class="headerlink" title="现象5-添加静态方法"></a>现象5-添加静态方法</h3><p>使得Phone中的两个方法增加static修饰，还是使用一个对象，是先打电话还是先发短信呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//A负责发短信</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; phone.send(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//B负责打电话</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; phone.call(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Phone中有两个方法，一个是发短信，一个是打电话。都加了锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//发信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打电话</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未加锁的方法：读书</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;读书&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果是先发短信。</p>
<p>添加了加锁的静态方法，这个时候锁的不再是方法调用者，而是Phone这个class类，但是因为A先拿到锁，所以还是先发短信。所以有静态方法的时候还是按顺序执行。</p>
<h3 id="现象6-添加静态方法同时使用两个对象"><a href="#现象6-添加静态方法同时使用两个对象" class="headerlink" title="现象6-添加静态方法同时使用两个对象"></a>现象6-添加静态方法同时使用两个对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//A负责发短信</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; phone1.send(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//B负责打电话</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; phone2.call(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Phone中有两个方法，一个是发短信，一个是打电话。都加了锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//发信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打电话</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未加锁的方法：读书</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;读书&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候锁的是Class，所以不管多少个对象，都是使用的同一把锁，所以还是按顺序执行，谁先拿到锁就先执行，所以结果就是三秒过后发短信，然后再是打电话。</p>
<h3 id="现象7-一个静态同步方法与一个普通同步方法"><a href="#现象7-一个静态同步方法与一个普通同步方法" class="headerlink" title="现象7-一个静态同步方法与一个普通同步方法"></a>现象7-一个静态同步方法与一个普通同步方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//A负责发短信</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; phone.send(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//B负责打电话</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; phone.call(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Phone中有两个方法，一个是发短信，一个是打电话。都加了锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//发信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打电话</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未加锁的方法：读书</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;读书&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候就是先打电话了，因为<code>static synchronized</code>锁的是class类，而只被<code>synchronized</code>修饰的锁的是方法的调用者，前者是class锁，后者是对象锁，二者不是同一把锁，互不干扰。</p>
<h3 id="现象8-多个对象-静态同步-普通同步"><a href="#现象8-多个对象-静态同步-普通同步" class="headerlink" title="现象8-多个对象+静态同步+普通同步"></a>现象8-多个对象+静态同步+普通同步</h3><p>使用两个phone对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//A负责发短信</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; phone1.send(), <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//B负责打电话</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; phone2.call(), <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Phone中有两个方法，一个是发短信，一个是打电话。都加了锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//发信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打电话</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未加锁的方法：读书</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;读书&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被 synchronized和static修饰的方法，锁的对象是类的class对象！唯一的同一把锁；</p>
<p>只被synchronized修饰的方法，是普通锁（如对象锁），不是Class锁，所以进程之间执行顺序互不干扰。</p>
<p>所以最后还是先打电话。</p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>通过这8个案例，应该能弄懂线程的执行顺序，锁的是什么。</p>
<p>在并发编程下，ArrayList是线程不安全的，如果在修改ArrayList时同时读取ArrayList，它会造成<code>ConcurrentModificationException</code>（并发修改异常），这是在并发编程下需要解决的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. arraylist线程不完全</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码就是一边读一边写，最终运行结果如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/09/FSCwWNGjQplE9rT.png"
                      alt="image-20200509162857657"
                ></p>
<h3 id="解决方案一：Vector"><a href="#解决方案一：Vector" class="headerlink" title="解决方案一：Vector"></a>解决方案一：Vector</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Vector就不会发生并发修改异常，原因是：</p>
<p>通过查看Vector源码可以发现Vector的方法上加了<code>synchronized</code>，那么这个list就被上锁了，这样在写入的时候就不能读取，在读取的时候就不能写入，使得读写分离，就不会发生并发修改异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this Vector.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this Vector</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>同时我也注意到Vector在Jdk 1.2就存在了，比ArrayList出生的还早一些，那为什么还会设计线程不安全的ArrayList呢？是因为Vector在读取的时候不能修改，在修改的时候不能读取，那它的效率就比ArrayList低，所以才有了ArrayList的存在。</p>
<h3 id="解决方案二：Collections-synchronizedList"><a href="#解决方案二：Collections-synchronizedList" class="headerlink" title="解决方案二：Collections.synchronizedList()"></a>解决方案二：Collections.synchronizedList()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>Collections.synchronizedList()</code>可以得到一个同步的List，也可以解决并发修改异常问题。</p>
<h3 id="解决方案三：-CopyOnWriteArrayList"><a href="#解决方案三：-CopyOnWriteArrayList" class="headerlink" title="解决方案三： CopyOnWriteArrayList"></a>解决方案三： CopyOnWriteArrayList</h3><p><code>CopyOnWriteArrayList</code>也是JUC下的一个类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CopyOnWriteArrayList</code>的原理是在写入的时候先复制一份底层的数组，然后对这个复制好的数组进行操作，这样就不会操作原始的数组，操作完成后，再将复制的数组设置为底层的数组。读取的时候读的是原始数组，写入的时候写的是复制数组，二者不是同一个事物，自然就不会产生并发修改异常。</p>
<p>以下是<code>CopyOnWriteArrayList</code>在增加元素时的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h1><h2 id="Callable介绍"><a href="#Callable介绍" class="headerlink" title="Callable介绍"></a>Callable介绍</h2><p><code>Callable</code>是一个接口，类似于<code>Runnable</code>，但是<code>Runnable</code>没有返回值，<code>Runnable</code>不返回结果，也不能抛出被检查的异常。</p>
<p> <code>Callable</code>却可以做到：</p>
<ul>
<li>有返回值</li>
<li>计算错误时抛出异常</li>
<li><code>Runnable</code>使用run()，<code>Callable</code>使用call()。</li>
</ul>
<h2 id="Callable使用"><a href="#Callable使用" class="headerlink" title="Callable使用"></a>Callable使用</h2><p>但是<code>Thread</code>的构造方法中，<code>Callable</code>是不能作为参数的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/09/3XRrjeP85B9ipnY.png"
                      alt="image-20200509212857843"
                ></p>
<p>这里要使用到<code>FutureTask</code>，它是<code>Runnable</code>接口的一个实现类，同时它的构造方法<code>FutureTask(Callable&lt;V&gt; callable) </code>可以接受<code>Callable</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/09/zmd4BfsG6Uranlt.png"
                      alt="image-20200509213156120"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/09/AkQZPLzmJUjiqou.png"
                      alt="image-20200509213132794"
                ></p>
<p>所以可以通过以下代码使用<code>Callable</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个线程将1024作为返回值</span></span><br><span class="line">FutureTask futureTask = <span class="keyword">new</span> FutureTask(() -&gt; <span class="number">1024</span>);</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<h2 id="FutureTask的方法介绍"><a href="#FutureTask的方法介绍" class="headerlink" title="FutureTask的方法介绍"></a>FutureTask的方法介绍</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/09/zocUWSda62wDiIj.png"
                      alt="image-20200509213539438"
                ></p>
<p>需要注意的是get()会一直等待计算完成，也就是如果计算一直没完成可能会产生阻塞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个线程将1024作为返回值</span></span><br><span class="line">FutureTask futureTask = <span class="keyword">new</span> FutureTask(() -&gt; <span class="number">1024</span>);</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">thread.start();</span><br><span class="line">Integer num = (Integer)futureTask.get();</span><br><span class="line">System.out.println(num.toString());</span><br></pre></td></tr></table></figure>

<p>最后输出的结果就是1024。</p>
<h1 id="集合不安全"><a href="#集合不安全" class="headerlink" title="集合不安全"></a>集合不安全</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>在并发编程下，ArrayList是线程不安全的，如果在修改ArrayList时同时读取ArrayList，它会造成<code>ConcurrentModificationException</code>（并发修改异常），这是在并发编程下需要解决的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. arraylist线程不完全</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码就是一边读一边写，最终运行结果如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/09/FSCwWNGjQplE9rT.png"
                      alt="image-20200509162857657"
                ></p>
<h3 id="解决方案一：Vector-1"><a href="#解决方案一：Vector-1" class="headerlink" title="解决方案一：Vector"></a>解决方案一：Vector</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Vector就不会发生并发修改异常，原因是：</p>
<p>通过查看Vector源码可以发现Vector的方法上加了<code>synchronized</code>，那么这个list就被上锁了，这样在写入的时候就不能读取，在读取的时候就不能写入，使得读写分离，就不会发生并发修改异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this Vector.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this Vector</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h4><p>同时我也注意到Vector在Jdk 1.2就存在了，比ArrayList出生的还早一些，那为什么还会设计线程不安全的ArrayList呢？是因为Vector在读取的时候不能修改，在修改的时候不能读取，那它的效率就比ArrayList低，所以才有了ArrayList的存在。</p>
<h3 id="解决方案二：Collections-synchronizedList-1"><a href="#解决方案二：Collections-synchronizedList-1" class="headerlink" title="解决方案二：Collections.synchronizedList()"></a>解决方案二：Collections.synchronizedList()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>Collections.synchronizedList()</code>可以得到一个同步的List，也可以解决并发修改异常问题。</p>
<h3 id="解决方案三：-CopyOnWriteArrayList-1"><a href="#解决方案三：-CopyOnWriteArrayList-1" class="headerlink" title="解决方案三： CopyOnWriteArrayList"></a>解决方案三： CopyOnWriteArrayList</h3><p><code>CopyOnWriteArrayList</code>也是JUC下的一个类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CopyOnWriteArrayList</code>的原理是在写入的时候先复制一份底层的数组，然后对这个复制好的数组进行操作，这样就不会操作原始的数组，操作完成后，再将复制的数组设置为底层的数组。读取的时候读的是原始数组，写入的时候写的是复制数组，二者不是同一个事物，自然就不会产生并发修改异常。</p>
<p>以下是<code>CopyOnWriteArrayList</code>在增加元素时的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set其实和List是一样的，也会产生并发修改异常，而且解决方案也是类似的，在这里就统一列出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.HashSet 会发生并发修改异常</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.synchronizedSet</span></span><br><span class="line">set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.CopyOnWriteArraySet</span></span><br><span class="line">set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>回顾Map基本操作</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200912210905.png"
                      alt="image-20200912210801561" style="zoom:80%;" /
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200912210900.png"
                      alt="image-20200912210900098" style="zoom:80%;" /
                >



<h1 id="常用辅助类"><a href="#常用辅助类" class="headerlink" title="常用辅助类"></a>常用辅助类</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch 有两个用途：</p>
<ul>
<li>第一个是启动信号，防止任何工作人员进入，直到驾驶员准备好继续前进; </li>
<li>第二个是完成信号，允许司机等到所有的工作人员完成。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设有6个人，驾驶员需要等待6个人都上车后，再启动车辆。</span></span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;上车了&quot;</span>);</span><br><span class="line">            <span class="comment">// 每上一个人，将6减掉1。</span></span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;, i + <span class="string">&quot;&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// await()方法的作用是只有当6不断减1减到0的时候，才会执行接下来的代码，不然会一直在此等待。</span></span><br><span class="line">        <span class="comment">// 就好比驾驶员一直在等待所有人上车</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所有人都上车了，启动车辆！</span></span><br><span class="line">    System.out.println(<span class="string">&quot;驾驶员发车&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果就是当6个人都上车后，驾驶员才会发车。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/09/BMeYxzNsIXEmRfF.png"
                      alt="image-20200509215325091"
                ></p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>CyclicBarrier 的作用和 CountDownLatch 差不太多，就是使用方法有点差距。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个里面的第二个参数是最后要执行的，等待所有条件满足后才会执行。</span></span><br><span class="line">    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">6</span>,()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;大家都进来了，发车吧！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进来了&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 每个人进入车后要awiat()，表示自己已经进来了，等待其他人上车</span></span><br><span class="line">                <span class="comment">// 当所有人都调用了awiat()后，驾驶员就会发车。</span></span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, i + <span class="string">&quot;&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后输出结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/09/BV4dtgITkeiofFU.png"
                      alt="image-20200509220118382"
                ></p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore就是信号量，有操作系统基础的应该很好理解。</p>
<p>我们可以通过Semaphore去限制操作某个资源的线程的数量。</p>
<p>比如说桌上有两个苹果，那么Semaphore为2，当妈妈拿了一个，Semaphore减1，爸爸也可以拿，Semaphore减1，这个时候Semaphore为0，这你就不能拿了，只能等爷爷再削个苹果放桌上，Semaphore加1，你就可以拿苹果了。</p>
<p>下面是一个限制车流量的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 停车位数量有限 所以采用Semaphore限流</span></span><br><span class="line">    <span class="comment">// 假设总共有3个车位 却有6台车</span></span><br><span class="line">    Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();    <span class="comment">//车位减1</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进来停2秒的车&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进来停2秒后走了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                semaphore.release();    <span class="comment">//车位加1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h1><p>ReadWriteLock（读写锁）可以使得读和读互不影响，读和写互斥，写和写互斥，提高读写的效率。</p>
<p>ReadWriteLock中包含两把锁：</p>
<ul>
<li>读锁（共享锁）</li>
<li>写锁（独占锁）</li>
</ul>
<p>两种方法去获取锁</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/09/x1tNZXiG4VsmOye.png"
                      alt="image-20200509223654884"
                ></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCacheLock myCache = <span class="keyword">new</span> MyCacheLock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; myCache.write(temp + <span class="string">&quot;&quot;</span>, temp + <span class="string">&quot;&quot;</span>), String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; myCache.read(temp + <span class="string">&quot;&quot;</span>), String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCacheLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span>  ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写入&quot;</span> + key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-写入OK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读取&quot;</span> + key);</span><br><span class="line">           map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-读取OK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加读锁的作用是保证在读的时候，其他线程不能写，因为读锁和写锁是互斥的。如果不加读锁，可能在读的时候，其他线程就能写，而加了读锁，其他线程就不能加写锁了。</p>
<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p>阻塞队列和队列是一样的，讲究FIFO的原则，但是多了<code>阻塞</code>二字，意思是当队列满了的时候，就必须阻塞等待。</p>
<h2 id="阻塞队列的实现类"><a href="#阻塞队列的实现类" class="headerlink" title="阻塞队列的实现类"></a>阻塞队列的实现类</h2><p>阻塞队列是一个接口，有以下实现类：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/10/dwuSiIM6U439cKW.png"
                      alt="image-20200510154958476"
                ></p>
<h2 id="阻塞队列的地位"><a href="#阻塞队列的地位" class="headerlink" title="阻塞队列的地位"></a>阻塞队列的地位</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/10/YCZLWAtJ9euVg1c.png"
                      alt="image-20200510155056890"
                ></p>
<h2 id="阻塞队列的使用"><a href="#阻塞队列的使用" class="headerlink" title="阻塞队列的使用"></a>阻塞队列的使用</h2><p>在并发编程和线程池中，阻塞队列会被使用到。</p>
<p>阻塞队列有四组添加和移除的方法，每一组的功能都不同，总结如下表：</p>
<table>
<thead>
<tr>
<th align="center">方式</th>
<th align="center">有返回值会抛出异常</th>
<th align="center">有返回值不抛出异常</th>
<th align="center">会阻塞等待</th>
<th align="center">会超时等待</th>
</tr>
</thead>
<tbody><tr>
<td align="center">添加</td>
<td align="center">add()</td>
<td align="center">offer()</td>
<td align="center">put()</td>
<td align="center">offer(…)</td>
</tr>
<tr>
<td align="center">移除</td>
<td align="center">remove()</td>
<td align="center">poll()</td>
<td align="center">take()</td>
<td align="center">poll(…)</td>
</tr>
<tr>
<td align="center">检索但不删除队头</td>
<td align="center">element()</td>
<td align="center">peek()</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
</tbody></table>
<p>说明：</p>
<ol>
<li>可能产生的异常有：<ul>
<li>IllegalStateException - 如果由于容量限制，此时无法添加该元素</li>
<li>ClassCastException - 如果指定元素的类阻止将其添加到此队列 </li>
<li>NullPointerException - 如果指定的元素为空 </li>
<li>IllegalArgumentException - 如果指定元素的某些属性阻止将其添加到此队列中</li>
<li>NoSuchElementException - 如果这个队列是空的 </li>
<li>等等…</li>
</ul>
</li>
<li>超时等待那一列的方法的参数可以写时间，表明过了多久时间就不等待了。</li>
</ol>
<h2 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2><p>SynchronousQueue是这样一种阻塞队列，其中每个put必须等待一个take，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。<br>不能在同步队列上进行peek，因为仅在试图要取得元素时，该元素才存在；除非另一个线程试图移除某个元素，否则也不能（使用任何方法）添加元素；也不能迭代队列，因为其中没有元素可用于迭代。队列的头是尝试添加到队列中的首个已排队线程元素；如果没有已排队线程，则不添加元素并且头为null。<br>对于其他Collection方法（例如contains），SynchronousQueue作为一个空集合。此队列不允许null元素。<br>它非常适合于传递性设计，在这种设计中，在一个线程中运行的对象要将某些信息、事件或任务传递给在另一个线程中运行的对象，它就必须与该对象同步。<br>对于正在等待的生产者和使用者线程而言，此类支持可选的公平排序策略。默认情况下不保证这种排序。<br>但是，使用公平设置为true所构造的队列可保证线程以FIFO的顺序进行访问。公平通常会降低吞吐量，但是可以减小可变性并避免得不到服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步队列 * 和其他的BlockingQueue 不一样， SynchronousQueue 不存储元素 </span></span><br><span class="line"><span class="comment"> * put了一个元素，必须从里面先take取出来，否则不能在put进去值！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(); <span class="comment">// 同步队列</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; put 1&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; put 2&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; put 3&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + blockingQueue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>线程池的三大方法、七大参数、四大拒绝策略。</p>
<h2 id="池化技术"><a href="#池化技术" class="headerlink" title="池化技术"></a>池化技术</h2><p>程序运行会占用系统资源，采用池化技术可以优化资源的使用。常见的池子有：线程池、连接池、内存池、对象池等等。</p>
<p>池化技术也就是说：事先准备好一些资源，有人需要就过来拿，用完后就归还。</p>
<h3 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h3><ul>
<li>降低资源的消耗（可以线程复用）</li>
<li>提高响应的速度（可以控制最大并发数）</li>
<li>方便管理（可以管理线程）</li>
</ul>
<blockquote>
<p>使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资<br>源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者 “过度切换”的问题。 ——引用自阿里巴巴开发手册</p>
</blockquote>
<h2 id="线程池三大方法"><a href="#线程池三大方法" class="headerlink" title="线程池三大方法"></a>线程池三大方法</h2><p>阿里巴巴开发手册中这样写道：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/12/nKa231siHRlVmq7.png"
                      alt="image-20200512161036004"
                ></p>
<p>可见要创建线程池推荐使用ThreadPoolExecutor，但是我先使用下Executors，好让我了解下Executors的弊端。</p>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor()"></a>newSingleThreadExecutor()</h3><p>这个方法可以创建在线程池中创建一个单一线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService threadPool = Executors.newSingleThreadExecutor();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(() -&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//用完后线程池要关闭</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/12/MpL7hHk3xqDB1uR.png"
                      alt="image-20200512161407287"
                ></p>
<p>可以看到一直是同一个线程。</p>
<h3 id="newFixedThreadPool-…"><a href="#newFixedThreadPool-…" class="headerlink" title="newFixedThreadPool(…)"></a>newFixedThreadPool(…)</h3><p>在线程池中创建固定数量的线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(() -&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//用完后线程池要关闭</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后可以看到最多只有5个线程，就不放图了。</p>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool()"></a>newCachedThreadPool()</h3><p>这个方法不用参数，可以根据需要创建线程数量，也可重用之前创建好的线程。不过创建的线程数量根据CPU的性能而定，如果你的CPU只运行同时运行20个线程，那么你就不能创建30个线程同时工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 需要创建1000个线程</span></span><br><span class="line">        <span class="comment">// 但是运行结果只创建了100多个线程，根据CPU的性能而定。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(() -&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//用完后线程池要关闭</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七大参数"><a href="#七大参数" class="headerlink" title="七大参数"></a>七大参数</h2><p>首先来看看上面提到的三个方法的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现这个三个方法的本质都是ThreadPoolExecutor，这也就是为什么阿里巴巴推荐使用ThreadPoolExecutor。</p>
<p>这三个方法允许请求的队列长度都是Integer.MAX_VALUE，可能会堆积大量的请求，导致OOM。</p>
<p>下面是ThreadPoolExecutor中各大参数的含义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,						&#x2F;&#x2F;核心线程池大小</span><br><span class="line">                          int maximumPoolSize,					&#x2F;&#x2F;最大核心线程池大小</span><br><span class="line">                          long keepAliveTime,					&#x2F;&#x2F;超时了没有人调用就会释放</span><br><span class="line">                          TimeUnit unit,						&#x2F;&#x2F;超时单位</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,	&#x2F;&#x2F;阻塞队列</span><br><span class="line">                          ThreadFactory threadFactory,			&#x2F;&#x2F;线程工厂，用来创建线程。</span><br><span class="line">           				  &#x2F;&#x2F;拒接策略</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;&#x3D; 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.acc &#x3D; System.getSecurityManager() &#x3D;&#x3D; null ?</span><br><span class="line">            null :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    this.corePoolSize &#x3D; corePoolSize;</span><br><span class="line">    this.maximumPoolSize &#x3D; maximumPoolSize;</span><br><span class="line">    this.workQueue &#x3D; workQueue;</span><br><span class="line">    this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory &#x3D; threadFactory;</span><br><span class="line">    this.handler &#x3D; handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来以银行办理业务举例来说明这几大参数的意义：</p>
<p>在生活中，我们去银行办理业务时，都会有柜台、候客区等。</p>
<ol>
<li>假设有5个柜台，但是只有1号和2号柜台是开放的，其他3个柜台暂时关闭，这个时候corePoolSize就为2，maximumPoolSize就为5。</li>
<li>现在来了两个客人，那么他们俩就可以去1号和2号柜台办理业务。</li>
<li>又来了三个客人，他们就只能在候客区等待（假设候客区是三个位置），他们三个人就把候客区坐满了。如果前面两个人业务办理完了，他们就可以按FIFO原则去柜台办理业务。这个候客区就是workQueue（阻塞队列）。</li>
<li>但是如果有一天人特别多，候客区都坐满了，还是有人从银行进来，这个时候银行就会将另外关闭了三个窗口开放，这就体现了maximumPoolSize的含义。</li>
<li>如果5个窗口都有人在，候客区也坐满了，还是有人进来，那就得去处理这个人，是让他离开还是给他找个地方等，这就叫做RejectedExecutionHandler（拒绝策略）</li>
<li>keepAliveTime表示如果银行等了keepAliveTime的时间，还是没有人来办理业务，银行就会将临时开放的三个窗口给关闭，也就是释放线程池。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/12/zFk3lbcjpwoaLYh.png"
                      alt="image-20200512175120673"
                ></p>
<center>图示</center>

<h2 id="四种拒绝策略"><a href="#四种拒绝策略" class="headerlink" title="四种拒绝策略"></a>四种拒绝策略</h2><ul>
<li>new ThreadPoolExecutor.AbortPolicy()   银行满了，还有人进来，不处理这个人，直接抛出异常。</li>
<li>new ThreadPoolExecutor.CallerRunsPolicy()  哪来的去哪里！</li>
<li>new ThreadPoolExecutor.DiscardPolicy() 队列满了，丢掉任务，不会抛出异常！</li>
<li>new ThreadPoolExecutor.DiscardOldestPolicy() 队列满了，尝试去和早的竞争，也不会抛出异常！</li>
</ul>
<h2 id="手动自定义线程池"><a href="#手动自定义线程池" class="headerlink" title="手动自定义线程池"></a>手动自定义线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * new ThreadPoolExecutor.AbortPolicy() // 银行满了，还有人进来，不处理这个人的，抛出异 常</span></span><br><span class="line"><span class="comment">     * new ThreadPoolExecutor.CallerRunsPolicy() // 哪来的去哪里！</span></span><br><span class="line"><span class="comment">     * new ThreadPoolExecutor.DiscardPolicy() //队列满了，丢掉任务，不会抛出异常！</span></span><br><span class="line"><span class="comment">     * new ThreadPoolExecutor.DiscardOldestPolicy() //队列满了，尝试去和早的竞争，也不会 抛出异常！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">            <span class="number">5</span>,</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 最大承载：Deque的容量 + maximumPoolSize</span></span><br><span class="line">        <span class="comment">// 超过就抛出RejectedExecutionException</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 使用了线程池之后，使用线程池来创建线程</span></span><br><span class="line">            threadPool.execute(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ok&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="池的大小如何设定"><a href="#池的大小如何设定" class="headerlink" title="池的大小如何设定"></a>池的大小如何设定</h2><p>关于池中线程数量的设定有两种说法</p>
<ol>
<li>CPU密集型：根据你的CPU性能来设置线程数量，保持CPU的效率最高。</li>
</ol>
<p><code>Runtime.getRuntime().availableProcessors()</code>可以获取到当前计算机的CPU的核数，不能将最大线程数量写死，假如你的项目迁移到别人的电脑上，而他的电脑配置很低，你要是最大线程数量写的过大的话，就会出问题。而用<code>Runtime.getRuntime().availableProcessors()</code>可以很好的解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPool &#x3D; new ThreadPoolExecutor(</span><br><span class="line">        3,</span><br><span class="line">        Runtime.getRuntime().availableProcessors(),     &#x2F;&#x2F;用CPU的核数代替最大线程数量</span><br><span class="line">        3,</span><br><span class="line">        TimeUnit.SECONDS,</span><br><span class="line">        new LinkedBlockingDeque&lt;&gt;(3),</span><br><span class="line">        Executors.defaultThreadFactory(),</span><br><span class="line">        new ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>IO密集型：判断程序中十分耗IO的线程的数量，设置最大线程数量大于IO线程数量（一般为两倍）。</li>
</ol>
<p>因为IO线程非常占用资源，而我们设置最大线程数量大于IO线程数量，就可以避免线程阻塞。</p>
<h1 id="ForkJoin详解"><a href="#ForkJoin详解" class="headerlink" title="ForkJoin详解"></a>ForkJoin详解</h1><p>ForkJoin中文名叫做分支合并，ForkJoin是在JDK1.7出现的，它主要用作在大数据量时并行执行效率，提高效率。</p>
<h2 id="ForkJoin思想"><a href="#ForkJoin思想" class="headerlink" title="ForkJoin思想"></a>ForkJoin思想</h2><p>它的思想是将一个大任务分割成若干个小任务，最终汇总每个小任务的结果得到这个大任务的结果。类似于分治法。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/13/v4dEieLXKPZNTpu.png"
                      alt="image-20200513142115803"
                ></p>
<h2 id="ForkJoin特点：工作窃取"><a href="#ForkJoin特点：工作窃取" class="headerlink" title="ForkJoin特点：工作窃取"></a>ForkJoin特点：工作窃取</h2><p>如图A和B线程处理两个任务，当B比A先处理完时，它可以从另一头开始去处理A的任务。A和B的任务是一个双端队列，所以B可以从另外一头进入。这就是工作窃取。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/13/rHRcn2pz5j16IKZ.png"
                      alt="image-20200513142256555"
                ></p>
<h2 id="ForkJoin使用"><a href="#ForkJoin使用" class="headerlink" title="ForkJoin使用"></a>ForkJoin使用</h2><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><ol>
<li>ForkJoinPool</li>
</ol>
<p>ForkJoinPool用来存放一个个任务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/13/JBhIo6vaQEKzufS.png"
                      alt="image-20200513214414430"
                ></p>
<ol start="2">
<li>ForkJoinTask</li>
</ol>
<p>ForkJoinTask就是ForkJoinPool里面的一个个任务，它有两个主要子类：</p>
<ul>
<li>RecusiveAction（递归事件，没有返回值）</li>
<li>RecisiveTask（递归任务，有返回值）</li>
</ul>
<p>可以通过fork()方法去分配任务执行任务，通过join()方法汇总任务结果（其他方法具体可以看官方文档）</p>
<p>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责存放程序提交给ForkJoinPool的任务，而ForkJoinWorkerThread数组负责执行这些任务。</p>
<h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><p>目的：计算1至1亿相加的结果</p>
<ol>
<li>创建自己的任务类 MyTask，需要继承RecisiveTask。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> forkjoin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 我的任务Class</span></span><br><span class="line"><span class="comment"> * 任务是计算1至1亿的和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long start; <span class="comment">//计算起始点</span></span><br><span class="line">    <span class="keyword">private</span> Long end;   <span class="comment">//计算终点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long temp = <span class="number">10000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(Long start, Long end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果计算量较小，直接交给for循环去计算。</span></span><br><span class="line">        <span class="keyword">if</span> ((end - start) &lt; temp) &#123;</span><br><span class="line">            Long sum = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (Long i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//使用forkjoin去计算</span></span><br><span class="line">            <span class="keyword">long</span> middle = (start + end) / <span class="number">2</span>;                <span class="comment">//中间值</span></span><br><span class="line">            <span class="comment">//开始拆分任务</span></span><br><span class="line">            MyTask task1 = <span class="keyword">new</span> MyTask(start, middle);       <span class="comment">//任务1</span></span><br><span class="line">            task1.fork();                                   <span class="comment">//使用fork()去拆分任务，将任务压入线程队列。</span></span><br><span class="line">            MyTask task2 = <span class="keyword">new</span> MyTask(middle + <span class="number">1</span>, end);     <span class="comment">//任务2</span></span><br><span class="line">            task2.fork();</span><br><span class="line">            <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> forkjoin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestForkJoin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        Long startTime = System.currentTimeMillis();</span><br><span class="line">        MyTask myTask = <span class="keyword">new</span> MyTask(<span class="number">1L</span>, <span class="number">1_0000_0000L</span>);</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(myTask);    <span class="comment">//提交任务</span></span><br><span class="line">        Long sum = submit.get();                                    <span class="comment">//get()方法会去等待返回值，可能会发生阻塞。</span></span><br><span class="line">        Long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;结果是：&quot;</span> + sum + <span class="string">&quot;，所耗时间为：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>运行结果</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/13/dyWP5As98wxIjqg.png"
                      alt="image-20200513220808233"
                ></p>
<ol start="4">
<li>使用Stream流去计算会更加块</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用Stream流去计算</span></span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    LongStream stream = LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">1_0000_0000</span>);</span><br><span class="line">    <span class="keyword">long</span> sum = stream.parallel().reduce(Long::sum).getAsLong();</span><br><span class="line">    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;结果是：&quot;</span> + sum + <span class="string">&quot;，所耗时间为：&quot;</span> + (endTime - startTime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/13/qSnTLb9EJYasMQx.png"
                      alt="image-20200513221859810"
                ></p>
<h1 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h1><p>学习过Ajax的应该很好理解这部分的内容。</p>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p>CompletableFuture内包含两类常用方法：</p>
<h3 id="没有返回值的方法"><a href="#没有返回值的方法" class="headerlink" title="没有返回值的方法"></a>没有返回值的方法</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/16/A8MzfcUxP3tHNCZ.png"
                      alt="image-20200516212905649"
                ></p>
<p>就好比小红和小明一起在健身房，，小红突然有事，对小明说我先走了，小红不用等小明回复，打声招呼就走了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRunAsync</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有返回值的用法</span></span><br><span class="line">    <span class="comment">// Void是void的包装类，就好比Integer是int的包装类。</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; voidCompletableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;没有返回值！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(voidCompletableFuture.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool.commonPool-worker-1没有返回值！</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<h3 id="有返回值的方法"><a href="#有返回值的方法" class="headerlink" title="有返回值的方法"></a>有返回值的方法</h3><h3 id="有返回值的方法-1"><a href="#有返回值的方法-1" class="headerlink" title="有返回值的方法"></a>有返回值的方法</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/16/8lrWjnpkDMqw9uH.png"
                      alt="image-20200516213355855"
                ></p>
<p>这个的意思就是说假如你有道题目不会做，你去问同桌，但是同桌也得想一下，你就对同桌说我先去做其他作业了，你做好后告诉我。如果同桌做好了，他就告诉你正确的结果，如果同桌也遇到了困难，他就会告诉你不会做（给你返回异常信息）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSupplyAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有返回值的用法，返回1+1的结果。</span></span><br><span class="line">    CompletableFuture&lt;Integer&gt; integerCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;有返回值！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// whenComplete表示完成后的操作</span></span><br><span class="line">    <span class="comment">// whenComplete内的参数是一个BiConsumer接口，它能够接受两个参数。而普通的Consumer接口只能接受一个参数。</span></span><br><span class="line">    integerCompletableFuture.whenComplete((integer, throwable) -&gt; &#123;</span><br><span class="line">        System.out.println(integer);        <span class="comment">// 1+1的结果，如果有异常，就为null。</span></span><br><span class="line">        System.out.println(throwable);      <span class="comment">// 异常信息，如果没有异常就为null。</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 输出后第一行是1+1的结果，第二行为null。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是计算1+1/0呢，这个肯定是出现异常的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSupplyAsync</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 有返回值的用法，返回1+1的结果。</span></span><br><span class="line">    CompletableFuture&lt;Integer&gt; integerCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;有返回值！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// whenComplete表示完成后的操作</span></span><br><span class="line">    <span class="comment">// whenComplete内的参数是一个BiConsumer接口，它能够接受两个参数。而普通的Consumer接口只能接受一个参数。</span></span><br><span class="line">    System.out.println(integerCompletableFuture.whenComplete((integer, throwable) -&gt; &#123;</span><br><span class="line">        System.out.println(integer);        <span class="comment">// 1+1的结果，如果有异常，就为null。</span></span><br><span class="line">        System.out.println(throwable);      <span class="comment">// 异常信息，如果没有异常就为null。</span></span><br><span class="line">    &#125;).exceptionally(throwable -&gt; &#123;</span><br><span class="line">        <span class="comment">// exceptionally就好比try-finally的finally</span></span><br><span class="line">        System.out.println(<span class="string">&quot;出现异常啦：&quot;</span> + throwable.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4444</span>;</span><br><span class="line">    &#125;).get());</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool.commonPool-worker-1有返回值！</span><br><span class="line">null</span><br><span class="line">java.util.concurrent.CompletionException: java.lang.ArithmeticException: &#x2F; by zero</span><br><span class="line">出现异常啦：java.lang.ArithmeticException: &#x2F; by zero</span><br><span class="line">4444</span><br></pre></td></tr></table></figure>

<h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><h2 id="什么是JMM"><a href="#什么是JMM" class="headerlink" title="什么是JMM"></a>什么是JMM</h2><p>JMM 是Java内存模型，是一个不存在的东西，是一种概念、约定，不是像JVM是存在的东西。</p>
<h2 id="JMM对同步的约定"><a href="#JMM对同步的约定" class="headerlink" title="JMM对同步的约定"></a>JMM对同步的约定</h2><ol>
<li>线程解锁前必须把共享变量<strong>立刻</strong>刷新回主存。</li>
</ol>
<blockquote>
<p>什么意思呢？</p>
<p>假设主存中有个布尔变量flag=true，线程A要去拿这个变量的时候，会将这个变量拷贝到线程自己的工作内存中，而不是操作主存中的flag变量，当线程解锁的时候，如果它将flag改为false，它就必须将flag=false刷新会主存，也就是将主存中的flag改为false。</p>
<p>这其中对应了8中操作：</p>
<ol>
<li>read：从主存中读（read）出flag=true</li>
<li>load：将flag=true load 至线程自己的工作内存</li>
<li>use：执行引擎use工作内存中的flag变量</li>
<li>assign：执行引擎use完后assign（赋值）至工作内存</li>
<li>store：线程用完flag变量后store至工作内存的变量副本中，对应load操作</li>
<li>write：将store操作从工作内存中得到的变量放入主内存的变量中，对应read</li>
<li>lock：加锁，把一个变量标识位线程独占状态</li>
<li>unlock：解锁，将一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li>
</ol>
</blockquote>
<ol start="2">
<li>线程加锁前，必须读取主存中的最新值到工作内存中！</li>
<li>加锁和解锁是同一把锁。</li>
</ol>
<h2 id="内存交互对应8种操作"><a href="#内存交互对应8种操作" class="headerlink" title="内存交互对应8种操作"></a>内存交互对应8种操作</h2><ol>
<li>read：从主存中读（read）出flag=true</li>
<li>load：将flag=true load 至线程自己的工作内存</li>
<li>use：执行引擎use工作内存中的flag变量</li>
<li>assign：执行引擎use完后assign（赋值）至工作内存</li>
<li>store：线程用完flag变量后store至工作内存的变量副本中，对应load操作</li>
<li>write：将store操作从工作内存中得到的变量放入主内存的变量中，对应read</li>
<li>lock：加锁，把一个变量标识位线程独占状态</li>
<li>unlock：解锁，将一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/16/pfR1u5aGl4As8ZY.png"
                      alt="image-20200516221312702"
                ></p>
<p>JMM对着8种指令的使用制定了如下规则：</p>
<ol>
<li>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须 write 。</li>
<li>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存 。</li>
<li>不允许一个线程将没有assign的数据从工作内存同步回主内存 。</li>
<li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量 。</li>
<li>实施use、store操作之前，必须经过assign和load操作 。</li>
<li>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁 。</li>
<li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前， 必须重新load或assign操作初始化变量的值 。</li>
<li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量 对一个变量进行unlock操作之前，必须把此变量同步回主内存。</li>
</ol>
<h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h1><blockquote>
<p>面试题：请你谈谈你对Volatile的理解</p>
</blockquote>
<p>Volatile 是 Java 虚拟机提供的轻量级的同步机制</p>
<ol>
<li>保证可见性</li>
<li>不保证原子性</li>
<li>禁止指令重排</li>
</ol>
<h2 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h2><p>可见性：一个线程对共享变量的修改，更够及时的被其他线程看到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试保证可见性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// num为线程A与main线程的共享变量，但是由于不可见性，A线程无法指定主存中num的变化，所以会一直卡在while循环。</span></span><br><span class="line">        <span class="keyword">while</span> (num == <span class="number">0</span>) ;</span><br><span class="line">    &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main线程将主存中的num的值改为1</span></span><br><span class="line">    num = <span class="number">1</span>;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;将num修改为1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>private static int num = 0</code>修改为<code>private volatile static int num = 0</code>后，主存中的num变量对A可见，A能及时感知到num的变化，当num为1的时候，就不会卡在while循环。</p>
<p>这就体现了可见性。</p>
<h2 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h2><p>原子性：不可分割的操作</p>
<p>线程A在执行操作的时候，是不能被打扰的，也不能被分割，要么同时成功，要么同时失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * num++对应的字节码指令为：</span></span><br><span class="line"><span class="comment">     *  getstatic </span></span><br><span class="line"><span class="comment">     *  iconst_1</span></span><br><span class="line"><span class="comment">     *  iadd</span></span><br><span class="line"><span class="comment">     *  putstatic</span></span><br><span class="line"><span class="comment">     *  return</span></span><br><span class="line"><span class="comment">     *  所以num++的操作是非原子性的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 理论上num最后的结果应该是20000，</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++)&#123;</span><br><span class="line">                add();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;   <span class="comment">// GC main</span></span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码及运行结果可以知道volatile是不保证原子性的。</p>
<blockquote>
<p>通过对add()加锁可以保证原子性，那不加锁怎么保证原子性呢？</p>
</blockquote>
<p>JUC包下有很多原子类</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/17/fEmKaLjc41piMQ8.png"
                      alt="image-20200517093629661"
                ></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> AtomicInteger num = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    num.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 理论上num最后的结果应该是20000，</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++)&#123;</span><br><span class="line">                add();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;   <span class="comment">// GC main</span></span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就得到了正确结果</p>
<h2 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h2><blockquote>
<p>什么是指令重排</p>
<p>你写的程序，计算机并不是按照你写的那样的顺序去执行的。</p>
<p>源代码&gt;编译器优化的重排&gt;指令并行也可能会重排&gt;内存系统也会重排&gt;执行</p>
</blockquote>
<p>但是计算机在重排指令的时候，也不会乱排：它会考虑数据的依赖性！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int x &#x3D; 1; &#x2F;&#x2F; 1 </span><br><span class="line">int y &#x3D; 2; &#x2F;&#x2F; 2 </span><br><span class="line">x &#x3D; x + 5; &#x2F;&#x2F; 3 </span><br><span class="line">y &#x3D; x * x; &#x2F;&#x2F; 4</span><br><span class="line">我们所期望的：1234 </span><br><span class="line">但是可能执行的时候会变成 2134、1324 </span><br><span class="line">但不可能是  4123！因为要考虑数据的依赖性</span><br></pre></td></tr></table></figure>

<p>再看下面这个例子，a、b、x、y这四个值默认都是0</p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>x=a</td>
<td>y=b</td>
</tr>
<tr>
<td>b=1</td>
<td>a=2</td>
</tr>
</tbody></table>
<p>但是由于指令重排，执行的顺序可能会变成这样：</p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>b=1</td>
<td>a=2</td>
</tr>
<tr>
<td>x=a</td>
<td>y=b</td>
</tr>
</tbody></table>
<p>造成我们意料之外的结果：x=2，y=1。</p>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>volatile可以避免指令重排，而原理就是内存屏障。</p>
<p>内存屏障是一种屏障指令，它使CPU或编译器对屏障指令之前和之后发出的内存操作执行一个排序约束。 这通常意味着在屏障之前发布的操作被保证在屏障之后发布的操作之前执行。</p>
<p>屏障一共分为四种类型：</p>
<p><strong>LoadLoad屏障</strong>：</p>
<p>抽象场景：Load1; LoadLoad; Load2</p>
<p>Load1 和 Load2 代表两条读取指令。在Load2要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p>
<p><strong>StoreStore屏障：</strong></p>
<p>抽象场景：Store1; StoreStore; Store2</p>
<p>Store1和 Store2代表两条写入指令。在Store2写入执行前，保证Store1的写入操作对其它处理器可见</p>
<p><strong>LoadStore屏障：</strong></p>
<p>抽象场景：Load1; LoadStore; Store2</p>
<p>在Store2被写入前，保证Load1要读取的数据被读取完毕。</p>
<p><strong>StoreLoad屏障：</strong></p>
<p>抽象场景：Store1; StoreLoad; Load2</p>
<p>在Load2读取操作执行前，保证Store1的写入对所有处理器可见。<strong>StoreLoad屏障的开销是四种屏障中最大的</strong>。</p>
<h1 id="玩转单例模式"><a href="#玩转单例模式" class="headerlink" title="玩转单例模式"></a>玩转单例模式</h1><p>volatile在单例模式模式中非常有用，在实例化对象的时候会有指令重排，造成线程不安全，volatile可以解决此问题。</p>
<p>先上实现单例模式的几种方法的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    // 1.懒汉式[线程不安全]</span></span><br><span class="line"><span class="comment">//    //这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。</span></span><br><span class="line"><span class="comment">//    private static Singleton instance;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    private Singleton() &#123;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    public static Singleton getInstance()&#123;</span></span><br><span class="line"><span class="comment">//        if(instance == null)&#123;</span></span><br><span class="line"><span class="comment">//            instance = new Singleton();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return instance;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    // 2.懒汉式[线程安全][效率低]</span></span><br><span class="line"><span class="comment">//    //这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。</span></span><br><span class="line"><span class="comment">//    private static Singleton instance;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    public synchronized static Singleton getInstance() &#123;</span></span><br><span class="line"><span class="comment">//        if (instance == null) &#123;</span></span><br><span class="line"><span class="comment">//            instance = new Singleton();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return instance;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    // 3.饿汉式</span></span><br><span class="line"><span class="comment">//    /*</span></span><br><span class="line"><span class="comment">//    描述：这种方式比较常用，但容易产生垃圾对象。</span></span><br><span class="line"><span class="comment">//    优点：没有加锁，执行效率会提高。</span></span><br><span class="line"><span class="comment">//    缺点：类加载时就初始化，浪费内存。</span></span><br><span class="line"><span class="comment">//    它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，</span></span><br><span class="line"><span class="comment">//    虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，</span></span><br><span class="line"><span class="comment">//    这时候初始化 instance 显然没有达到 lazy loading 的效果。</span></span><br><span class="line"><span class="comment">//     */</span></span><br><span class="line"><span class="comment">//    private static Singleton instance = new Singleton();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    private Singleton()&#123;&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    public static Singleton getInstance() &#123;</span></span><br><span class="line"><span class="comment">//        return instance;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    // 4.双检锁/双重校验锁（DCL，即 double-checked locking）</span></span><br><span class="line"><span class="comment">//    // 这种方式采用双锁机制，安全且在多线程情况下能保持高性能</span></span><br><span class="line"><span class="comment">//    private static volatile Singleton instance;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    private Singleton() &#123;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    public static Singleton getInstance() &#123;</span></span><br><span class="line"><span class="comment">//        if (instance == null) &#123;</span></span><br><span class="line"><span class="comment">//            synchronized (Singleton.class) &#123;</span></span><br><span class="line"><span class="comment">//                if (instance == null)</span></span><br><span class="line"><span class="comment">//                    /* 1. 分配内存空间 * 2、执行构造方法，初始化对象 * 3、把这个对象指向这个空间 */</span></span><br><span class="line"><span class="comment">//                    /* 指令重排可能会导致1、2、3顺序错乱，volatile通过添加内存屏障禁止指令重排。*/</span></span><br><span class="line"><span class="comment">//                    instance = new Singleton();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        return instance;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.登记式/静态内部类</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    采用静态内部类的形式可以达到同样的效果，而且代码更加简单。</span></span><br><span class="line"><span class="comment">    这种方式是就算Singleton被加载了,INSTANCE也不一定被实例化。</span></span><br><span class="line"><span class="comment">    SingletonHolder，只有显示调用了getInstance()方法时，</span></span><br><span class="line"><span class="comment">    才会显示装载SingletonHolder类，这个时候INSTANCE才会被实例化。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你以为这样就安全了吗？我们还可以利用反射去打破单例模式！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//你以为这就安全了吗？利用反射去打破单例模式！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">// 利用正规方法获取到singleton实例</span></span><br><span class="line">        Singleton singleton1 = Singleton.getInstance();</span><br><span class="line">        <span class="comment">// 利用反射获取到singleton实例</span></span><br><span class="line">        Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Singleton singleton2 = constructor.newInstance();</span><br><span class="line">        </span><br><span class="line">        System.out.println(singleton1.equals(singleton2));  <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的的反射我们居然获取到了两个实例，这明显违背了单例模式。<br>尝试去解决这个问题，在构造器中加锁！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不要试图用反射去破坏单例模式！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.reflect.InvocationTargetException</span><br><span class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:<span class="number">45</span>)</span><br><span class="line">	at java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">423</span>)</span><br><span class="line">	at single.TestSingleton.main(TestSingleton.java:<span class="number">18</span>)</span><br><span class="line">Caused by: java.lang.RuntimeException: 不要试图用反射去破坏单例模式！</span><br><span class="line">	at single.Singleton.&lt;init&gt;(Singleton.java:<span class="number">55</span>)</span><br><span class="line">	... <span class="number">5</span> more</span><br></pre></td></tr></table></figure>

<p>但是这样还是不安全的</p>
<p>如果我们这样去反射，直接利用反射去得到两个实例！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//你以为这就安全了吗？利用反射去打破单例模式！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException </span>&#123;</span><br><span class="line"><span class="comment">//        // 利用正规方法获取到singleton实例</span></span><br><span class="line"><span class="comment">//        Singleton singleton1 = Singleton.getInstance();</span></span><br><span class="line">        <span class="comment">// 利用反射获取到singleton实例</span></span><br><span class="line">        Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Singleton singleton1 = constructor.newInstance();</span><br><span class="line">        Singleton singleton2 = constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(singleton1.equals(singleton2));  <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是成功获取到了两个实例</p>
<p>通过设置一个标志位去解决这个问题！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> singletonFlag = <span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (singletonFlag == <span class="keyword">false</span>) &#123;</span><br><span class="line">            singletonFlag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不要试图用反射去破坏单例模式！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就得不到两个实例了，我们还可以对singletonFlag这个变量进行加密，这样别人就找不到这个变量了，就不能改变这个变量的值。</p>
<p>但是再牛逼的加密也有更牛逼的人解密，万一别人解密出来了，去改变这个变量的值，单例模式又再次被打破！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//你以为这就安全了吗？利用反射去打破单例模式！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException, NoSuchFieldException </span>&#123;</span><br><span class="line">        <span class="comment">// 假设SingletonFlag被解密出来了，尝试去改变它的值。</span></span><br><span class="line">        Field singletonFlag = Singleton.class.getDeclaredField(<span class="string">&quot;singletonFlag&quot;</span>);</span><br><span class="line">        singletonFlag.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Singleton singleton1 = constructor.newInstance();</span><br><span class="line">        singletonFlag.set(singleton1, <span class="keyword">false</span>);</span><br><span class="line">        Singleton singleton2 = constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(singleton1.equals(singleton2));  <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就又得到了两个变量</p>
<p><strong>最后一种方式：使用枚举去完成单例模式！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。</p>
<h1 id="深入理解CAS"><a href="#深入理解CAS" class="headerlink" title="深入理解CAS"></a>深入理解CAS</h1><h2 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h2><p>什么是CAS？</p>
<blockquote>
<p>CAS即CompareAndSwap，比较并交换，CAS有三个操作参数：内存地址、期望值、要修改的新值。当期望值和内存当中的值进行比较不相等的时候，表示内存中的值已经被别线程改动过，这时候失败返回，只有相等时，才会将内存中的值改为新的值，并返回成功。</p>
</blockquote>
<p>这里我们可以看一下JAVA的原子类AtomicLong.getAndIncrement()的实现，来理解一下CAS这一乐观锁（JDK 1.8）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, <span class="number">1L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看一下 Unsafe.getAndAddLong()的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAddLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> var6;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">       var6 = <span class="keyword">this</span>.getLongVolatile(var1, var2);</span><br><span class="line">   &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapLong(var1, var2, var6, var6 + var4));</span><br><span class="line">   <span class="keyword">return</span> var6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到AtomicLong.getAndIncrement()的实现就是通过CAS循环操作的实现，只有期望值与真实值相同情况下，CAS操作才会成功执行，退出循环，如果失败则继续<strong>自旋</strong>，直到成功。</p>
<p>CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。</p>
<h2 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h2><p>CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。</p>
<ol>
<li>循环时间长开销很大。</li>
<li>只能保证一个共享变量的原子操作。</li>
<li>ABA问题。</li>
</ol>
<h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>如果内存地址V初次读取的值是A，并且在准备赋值的时候检查到它的值仍然为A，那我们就能说它的值没有被其他线程改变过了吗？</p>
<p>如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>ABA问题的解决思路是，每次变量更新的时候把变量的<strong>版本号</strong>加1，那么A-B-A就会变成A1-B2-A3，只要变量被某一线程修改过，改变量对应的版本号就会发生递增变化，从而解决了ABA问题。在JDK的java.util.concurrent.atomic包中提供了AtomicStampedReference来解决ABA问题，该类的compareAndSet是该类的核心方法，实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                            V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">   Pair&lt;V&gt; current = pair;</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">       expectedReference == current.reference &amp;&amp;</span><br><span class="line">       expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">       ((newReference == current.reference &amp;&amp;</span><br><span class="line">         newStamp == current.stamp) ||</span><br><span class="line">        casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现，该类检查了当前引用与当前标志是否与预期相同，如果全部相等，才会以原子方式将该引用和该标志的值设为新的更新值，这样CAS操作中的比较就不依赖于变量的值了。</p>
<h3 id="场景重现"><a href="#场景重现" class="headerlink" title="场景重现"></a>场景重现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AtomicStampedReference 注意，如果泛型是一个包装类，注意对象的引用问题        // 正常在业务操作，这里面比较的都是一个个对象</span></span><br><span class="line"><span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CAS  compareAndSet : 比较并交换！</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> stamp = atomicStampedReference.getStamp(); <span class="comment">// 获得版本号            System.out.println(&quot;a1=&gt;&quot;+stamp);</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        atomicStampedReference.compareAndSet(<span class="number">1</span>, <span class="number">2</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a2=&gt;&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">        System.out.println(atomicStampedReference.compareAndSet(<span class="number">2</span>, <span class="number">1</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;a3=&gt;&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">    &#125;, <span class="string">&quot;a&quot;</span>).start();</span><br><span class="line">    <span class="comment">// 乐观锁的原理相同！</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">        <span class="comment">// 获得版本号</span></span><br><span class="line">        System.out.println(<span class="string">&quot;b1=&gt;&quot;</span> + stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (</span><br><span class="line">                InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(atomicStampedReference.compareAndSet(<span class="number">1</span>, <span class="number">6</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;b2=&gt;&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">    &#125;, <span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><br><strong>Integer 使用了对象缓存机制，默认范围是 -128 ~ 127 ，推荐使用静态工厂方法 valueOf 获取对象实例，而不是 new，因为 valueOf 使用缓存，而 new 一定会创建新的对象分配新的内存空间；</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/23/Y2nPyQVmB9j1Fob.png"
                      alt="image-20200523222720833"
                ></p>
<h1 id="几种锁"><a href="#几种锁" class="headerlink" title="几种锁"></a>几种锁</h1><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>如果有两个线程A和B同时进行，如果线程A拿到了锁1，同时去申请锁2，而线程B到了锁2并申请锁1，因为锁2在B手里，A就拿不到，A就一直等待；同理锁1在A手里，B也拿不到，就一直等待。这就造成了<strong>死锁</strong>现象。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/24/iv6EIZp34xursCb.jpg"
                      alt="img"
                ></p>
<h3 id="JAVA代码重现死锁场景"><a href="#JAVA代码重现死锁场景" class="headerlink" title="JAVA代码重现死锁场景"></a>JAVA代码重现死锁场景</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZhengHaoYun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/5/24 17:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String lockA = <span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">        String lockB = <span class="string">&quot;lockB&quot;</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(lockA, lockB), <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(lockB, lockA), <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String lockA, String lockB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockA = lockA;</span><br><span class="line">        <span class="keyword">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;lock:&quot;</span> + lockA + <span class="string">&quot;=&gt;get&quot;</span> + lockB);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;lock:&quot;</span> + lockB + <span class="string">&quot;=&gt;get&quot;</span> + lockA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T1拿到lockA，然后休眠2秒，在这两秒内，T2拿到lockB。2秒后T1去获取lockB，T2去获取lockA，但是都拿不到，造成死锁现象。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>我查了下百度百科，大概有这几种办法去解决吧：</p>
<ol>
<li><p>死锁预防</p>
<ol>
<li>当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</li>
<li>采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</li>
<li>实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源</li>
</ol>
<p>死锁预防有个著名的算法：银行家算法</p>
</li>
<li><p>死锁避免</p>
<p>系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源；如果分配后系统可能发生死锁，则不予分配，否则予以分配。这是一种保证系统不进入死锁状态的动态策略。</p>
</li>
<li><p>死锁排查</p>
<ol>
<li>使用 <code>jps -l</code> 定位进程号</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/24/92vm7NBhztkUqw3.png"
                      alt="image-20200524172207756"
                ></p>
<ol start="2">
<li>使用 <code>jstack 进程号 </code>找到死锁问题</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/24/dcQTuta1oMELPjp.png"
                      alt="image-20200524172326499"
                ></p>
</li>
</ol>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>可重入锁其实就是字面意思，<strong>可重入！</strong>浅显的讲就是你进了朋友的家，那你就也可以进朋友的卧室去参观参观了！</p>
<p>大多数的内置锁都是可重入的，用专业的话讲也就是说<strong>如果某个线程尝试获取一个它已经持有的锁的时，那么这个请求就会立刻成功</strong>，并且会将这个锁的计数值+1（可重入锁会有一个计数值），而当线程退出同步代码块的时候，计数值会-1，当计数值为0的时候，锁会释放。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2020/05/24/XmTxrionLBFuYMq.png"
                      alt="image-20200524230850873" style="zoom:150%;" /
                >

<p>自己实现的可重入锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread lockedBy = <span class="keyword">null</span>; <span class="comment">//存储哪个线程拿了锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> holdCount = <span class="number">0</span>;  <span class="comment">//计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span> (isLocked &amp;&amp; !lockedBy.equals(thread)) wait();</span><br><span class="line">        isLocked = <span class="keyword">true</span>;</span><br><span class="line">        lockedBy = thread;</span><br><span class="line">        holdCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().equals(lockedBy)) &#123;</span><br><span class="line">            holdCount--;</span><br><span class="line">            <span class="keyword">if</span> (holdCount == <span class="number">0</span>) &#123;</span><br><span class="line">                isLocked = <span class="keyword">false</span>;</span><br><span class="line">                notify();</span><br><span class="line">                lockedBy = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>自旋锁的原理比较简单，如果持有锁的线程能在短时间内释放锁资源，那么那些<strong>等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态</strong>，它们只需要等一等(自旋)，等到持有锁的线程释放锁之后即可获取，这样就避免了用户进程和内核切换的消耗。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>导致死锁</li>
</ol>
<blockquote>
<p><a class="link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%AD%BB%E9%94%81" >死锁<i class="fas fa-external-link-alt"></i></a>。试图递归地获得自旋锁必然会引起死锁：递归程序的持有实例在第二个实例循环，以试图获得相同自旋锁时，不会释放此自旋锁。在递归程序中使用自旋锁应遵守下列策略：递归程序决不能在持有自旋锁时调用它自己，也决不能在<a class="link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8" >递归调用<i class="fas fa-external-link-alt"></i></a>时试图获得相同的自旋锁。此外如果一个进程已经将资源锁定，那么，即使其它申请这个资源的进程不停地疯狂“自旋”,也无法获得资源，从而进入<a class="link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%AD%BB%E5%BE%AA%E7%8E%AF" >死循环<i class="fas fa-external-link-alt"></i></a>。</p>
</blockquote>
<ol start="2">
<li>过多占用<a class="link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/cpu" >cpu<i class="fas fa-external-link-alt"></i></a>资源</li>
</ol>
<blockquote>
<p>过多占用<a class="link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/cpu" >cpu<i class="fas fa-external-link-alt"></i></a>资源。如果不加限制，由于申请者一直在循环等待，因此自旋锁在锁定的时候,如果不成功,不会睡眠,会持续的尝试,单cpu的时候自旋锁会让其它process动不了. 因此，一般自旋锁实现会有一个参数限定最多持续尝试次数. 超出后, 自旋锁放弃当前time slice. 等下一次机会。</p>
</blockquote>
<p>具体关于死锁的可以看<a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/cxuanBlog/p/11679883.html" >这篇文章<i class="fas fa-external-link-alt"></i></a> </p>
<h1 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h1><p>至此关于JUC的笔记就到此结束了，完结撒花~</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：JUC并发编程学习笔记[全]</li>
        <li>Post author：Hoven</li>
        <li>Create time：2020-05-01 11:55:20</li>
        <li>
            Post link：https://zhenghaoyun.cn/JUC/JUC并发编程学习笔记 [全]
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/Docker/Docker%E4%B8%80%E6%8E%A2%E7%A9%B6%E7%AB%9F"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Docker一探究竟</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/Linux/Ubuntu%2018.04%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Ubuntu 18.04搭建FTP服务器</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;Comments</i>
    </div>
    

        
            
    <div class="valine-container">
        <script 
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script >
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'uffz9vWTIQhDc1YbAjAndspC-gzGzoHsz',
                    appKey: 'KQwbThRfP3cQIJYoLHMIqXLX',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '',
                    lang: 'zh-Hans'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Hoven';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('false') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2019</span>&nbsp;-&nbsp;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Hoven</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.2</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9D%E8%AF%86JUC"><span class="nav-text">初识JUC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JUC%E6%A6%82%E8%BF%B0"><span class="nav-text">JUC概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="nav-text">线程与进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JAVA%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%BC%80%E5%90%AF%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-text">JAVA是否可以开启线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-text">线程的几种状态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="nav-text">并发与并行</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lock%E9%94%81"><span class="nav-text">Lock锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E5%86%85%E8%81%9A%E4%BD%8E%E8%80%A6%E5%90%88"><span class="nav-text">高内聚低耦合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E5%86%85%E8%81%9A"><span class="nav-text">高内聚</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8E%E8%80%A6%E5%90%88"><span class="nav-text">低耦合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronized"><span class="nav-text">Synchronized</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock%E9%94%81%E4%BB%8B%E7%BB%8D"><span class="nav-text">Lock锁介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-text">公平锁与非公平锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">ReentrantLock的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">两者的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-text">生产者和消费者问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F-Synchronized-%E5%AE%9E%E7%8E%B0"><span class="nav-text">传统 Synchronized 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E9%97%AE%E9%A2%98"><span class="nav-text">虚假唤醒问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E9%87%8D%E7%8E%B0"><span class="nav-text">问题重现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A0"><span class="nav-text">原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">解决方案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JUC%E7%89%88%E6%9C%AC%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">JUC版本的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Condition%E5%AE%9E%E7%8E%B0%E7%B2%BE%E5%87%86%E5%94%A4%E9%86%92"><span class="nav-text">使用Condition实现精准唤醒</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8%E9%94%81%E7%8E%B0%E8%B1%A1"><span class="nav-text">8锁现象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%B0%E8%B1%A11-%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E4%B8%80%E6%8A%8A%E9%94%81-%E6%97%A0%E9%98%BB%E5%A1%9E"><span class="nav-text">现象1-多个线程使用一把锁-无阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%B0%E8%B1%A12-%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E6%8A%8A%E9%94%81%EF%BC%88%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%A2%AB%E9%98%BB%E5%A1%9E%EF%BC%89"><span class="nav-text">现象2-多个线程使用同一把锁（其中一个线程被阻塞）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%B0%E8%B1%A13-%E8%B0%83%E7%94%A8%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95"><span class="nav-text">现象3-调用普通方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%B0%E8%B1%A14-%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%8A%8A%E9%94%81"><span class="nav-text">现象4-多个线程使用多把锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%B0%E8%B1%A15-%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-text">现象5-添加静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%B0%E8%B1%A16-%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="nav-text">现象6-添加静态方法同时使用两个对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%B0%E8%B1%A17-%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E4%B8%8E%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-text">现象7-一个静态同步方法与一个普通同步方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%B0%E8%B1%A18-%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1-%E9%9D%99%E6%80%81%E5%90%8C%E6%AD%A5-%E6%99%AE%E9%80%9A%E5%90%8C%E6%AD%A5"><span class="nav-text">现象8-多个对象+静态同步+普通同步</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%BE%E5%A3%B0"><span class="nav-text">尾声</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9AVector"><span class="nav-text">解决方案一：Vector</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E9%99%B7"><span class="nav-text">缺陷</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9ACollections-synchronizedList"><span class="nav-text">解决方案二：Collections.synchronizedList()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%89%EF%BC%9A-CopyOnWriteArrayList"><span class="nav-text">解决方案三： CopyOnWriteArrayList</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Callable"><span class="nav-text">Callable</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Callable%E4%BB%8B%E7%BB%8D"><span class="nav-text">Callable介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Callable%E4%BD%BF%E7%94%A8"><span class="nav-text">Callable使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FutureTask%E7%9A%84%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="nav-text">FutureTask的方法介绍</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-text">集合不安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList"><span class="nav-text">ArrayList</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9AVector-1"><span class="nav-text">解决方案一：Vector</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E9%99%B7-1"><span class="nav-text">缺陷</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9ACollections-synchronizedList-1"><span class="nav-text">解决方案二：Collections.synchronizedList()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%89%EF%BC%9A-CopyOnWriteArrayList-1"><span class="nav-text">解决方案三： CopyOnWriteArrayList</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set"><span class="nav-text">Set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map"><span class="nav-text">Map</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E8%BE%85%E5%8A%A9%E7%B1%BB"><span class="nav-text">常用辅助类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch"><span class="nav-text">CountDownLatch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier"><span class="nav-text">CyclicBarrier</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore"><span class="nav-text">Semaphore</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ReadWriteLock"><span class="nav-text">ReadWriteLock</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-text">阻塞队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-text">阻塞队列的实现类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E5%9C%B0%E4%BD%8D"><span class="nav-text">阻塞队列的地位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">阻塞队列的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97"><span class="nav-text">同步队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="nav-text">池化技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%BD%E5%A4%84%EF%BC%9A"><span class="nav-text">好处：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%89%E5%A4%A7%E6%96%B9%E6%B3%95"><span class="nav-text">线程池三大方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#newSingleThreadExecutor"><span class="nav-text">newSingleThreadExecutor()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#newFixedThreadPool-%E2%80%A6"><span class="nav-text">newFixedThreadPool(…)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#newCachedThreadPool"><span class="nav-text">newCachedThreadPool()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0"><span class="nav-text">七大参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-text">四种拒绝策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">手动自定义线程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%A0%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%A6%82%E4%BD%95%E8%AE%BE%E5%AE%9A"><span class="nav-text">池的大小如何设定</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ForkJoin%E8%AF%A6%E8%A7%A3"><span class="nav-text">ForkJoin详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ForkJoin%E6%80%9D%E6%83%B3"><span class="nav-text">ForkJoin思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ForkJoin%E7%89%B9%E7%82%B9%EF%BC%9A%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96"><span class="nav-text">ForkJoin特点：工作窃取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ForkJoin%E4%BD%BF%E7%94%A8"><span class="nav-text">ForkJoin使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="nav-text">简单介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8"><span class="nav-text">具体使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83"><span class="nav-text">异步回调</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CompletableFuture"><span class="nav-text">CompletableFuture</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">没有返回值的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">有返回值的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95-1"><span class="nav-text">有返回值的方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JMM"><span class="nav-text">JMM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJMM"><span class="nav-text">什么是JMM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JMM%E5%AF%B9%E5%90%8C%E6%AD%A5%E7%9A%84%E7%BA%A6%E5%AE%9A"><span class="nav-text">JMM对同步的约定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E5%AF%B9%E5%BA%948%E7%A7%8D%E6%93%8D%E4%BD%9C"><span class="nav-text">内存交互对应8种操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Volatile"><span class="nav-text">Volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-text">保证可见性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-text">不保证原子性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="nav-text">禁止指令重排</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="nav-text">内存屏障</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8E%A9%E8%BD%AC%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-text">玩转单例模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CAS"><span class="nav-text">深入理解CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS%E5%8E%9F%E7%90%86"><span class="nav-text">CAS原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS%E7%BC%BA%E7%82%B9"><span class="nav-text">CAS缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ABA%E9%97%AE%E9%A2%98"><span class="nav-text">ABA问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-text">解决办法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF%E9%87%8D%E7%8E%B0"><span class="nav-text">场景重现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%A0%E7%A7%8D%E9%94%81"><span class="nav-text">几种锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JAVA%E4%BB%A3%E7%A0%81%E9%87%8D%E7%8E%B0%E6%AD%BB%E9%94%81%E5%9C%BA%E6%99%AF"><span class="nav-text">JAVA代码重现死锁场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3"><span class="nav-text">解决</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-text">可重入锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-text">自旋锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-text">缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%8C%E7%BB%93"><span class="nav-text">完结</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>



<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
