[{"title":"从设计层面上谈谈抽象类和接口的区别","url":"/Java基础/从设计层面上谈谈抽象类和接口的区别","content":"\n\n\n为什么想谈谈抽象类和接口呢？\n\n当我百度抽象类和接口的区别时，网上会有一堆千篇一律的回答，就像下面：\n\n1. 接口的方法默认是public，所有的方法在接口中不能有实现（JDK8开始方法可以实现，不过要增加static或者default修饰符）；而抽象类可以有非抽象的方法，也就是可以实现方法，也就是方法可以有方法体。\n2. 一个类能实现多个接口，但是一个类只能继承一个抽象类。\n3. 从方法上来说，接口中的方法默认以public abttact 修饰，而抽象类中的抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰）。\n4. 从属性上来说，抽象类中的属性可以用各种各样的修饰符去修饰，而接口中的属性默认是public static final。\n5. 抽象类可以含有构造方法，而接口不可以有构造方法。\n\n>JDK7~JDK9期间，接口发生的变化：\n>\n>1. 在 jdk7或更早版本中，接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。\n>2. jdk8的时候接口可以有默认方法和静态方法功能。\n>\n>![image-20201006221453185](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20201006221453.png)\n>\n>3. Jdk9在接口中引入了私有方法和私有静态方法。\n\n---\n\n以上回答都是基于接口和抽象类使用上的区别来说明的，当看到这么多区别的时候，我又觉得这两者是那么的相似，为什么有了接口还会有抽象类呢？什么时候会用到抽象类，什么时候又会用到接口呢？\n\n于是有了接口和抽象类在设计层面上的区别。\n\n先来举一个简单的例子：\n\n学生和老师都有吃饭、写字的本领吧，就下面这样：\n\n```java\nclass Student {\n    public void eat() { }\n\n    public void sleep() { }\n}\n\nclass Teacher {\n    public void eat() { }\n\n    public void sleep() { }\n}\n```\n\n这样Student和Teacher都有重复的代码，那么我们有两个办法：\n\n1. 可以定义一个接口，接口里面包含了eat()和sleep()方法，然后让Student和Teacher都实现这个方法就好了。\n2. 可以定义一个抽象类，抽象类里面包含了eat()和sleep()方法，然后让Student和Teacher都继承这个抽象类就好了。\n\n这样一看，抽象类和接口似乎没什么区别。\n\n但是如果给Teacher增加一个教书的方法teach()，而Student是不能教书的，也就没有teach()方法，那要怎么解决呢？\n\n1. 如果在接口中增加teach()，那学生实现了这个接口的话，也就具备了teach()，不可行！\t\n2. 如果在抽象类中增加teach()，那学生继承了这个抽象类的话，也就具备了teach()，不可行！\n\n试想一下eat()和sleep()都是学生和老师共有的方法，那我们可以将eat()和sleep()都写进一个抽象类Person，然后让老师和学生都继承Person，teach()是老师独有的方法，也就是对Person的一种拓展和延伸，那我们可以再定义一个teach接口，然后让老师去实现这个teach接口，总体解决方案如下：\n\n```java\nabstract class Person {\n    public abstract void eat();\n\n    public abstract void write();\n}\n\ninterface teach {\n    void teach();\n}\n\nclass Student extends Person {\n\n    @Override\n    public void eat() {\n    }\n\n    @Override\n    public void write() {\n    }\n}\n\nclass Teacher extends Person implements teach {\n    @Override\n    public void eat() {\n    }\n\n    @Override\n    public void write() {\n    }\n\n    @Override\n    public void teach() {\n    }\n}\n```\n\n写到这，应该大部分人能够明白接口和抽象类的区别了，总的来说：\n\n**继承是一个 \"是不是\"的关系，而 接口实现则是 \"有没有\"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如一个人是否能教书，能则可以实现这个接口，不能就不实现这个接口。**\n\n你以为这样就完了吗？\n\n细心的人会说，那为什么有抽象类，我用一个普通类Person也可以呀，然后让Student和Teacher继承这个Person就好了呀，是的， 没错，就像这样：\n\n```java\nclass Person {\n    public void eat() {\n    }\n\n    public void write() {\n    }\n}\n\ninterface teach {\n    void teach();\n}\n\nclass Student extends Person {\n\n}\n\nclass Teacher extends Person implements teach {\n\n    @Override\n    public void teach() {\n    }\n}\n```\n\n不知道你有没有忘，抽象类中既可以定义未实现的方法，也可以定义实现了的方法。\n\n当不同的类具有某些相同的行为时，且实现的方法一致时，比如说see()都是用眼睛看，hear()都是用耳朵听，那么see()和hear()都可以在抽象类中实现，其他的类都派生于这个抽象类，避免了see()和hear()的重复实现，反正大家see()和hear()都是一样的，这就达到了**代码复用**的目的。\n\n当不同的类具有某些相同的行为时，且实现的方法不一致时，比如说eat()，老师可能在教师餐厅吃，而学生可能在学生食堂吃，这就使得eat()的实现方式是不同的，所以eat()可以作为抽象类中的抽象方法，所有的派生类自己去实现这个eat()方法！\n\n这些，普通的类能做到吗？如果是普通的类，它的方法必须有方法体，那么所有派生于普通类的类的方法实现都是集成自父类的（除非方法重写）！\n\n```java\nabstract class Person {\n    public void see() {\n        System.out.println(\"see by eyes\");\n    }\n\n    public abstract void eat();\n}\n\ninterface teach {\n    void teach();\n}\n\nclass Student extends Person {\n\n    @Override\n    public void eat() {\n        System.out.println(\"eat in student's restaurant\");\n    }\n}\n\nclass Teacher extends Person implements teach {\n\n    @Override\n    public void teach() {\n    }\n\n    @Override\n    public void eat() {\n        System.out.println(\"eat in teacher's restaurant\");\n    }\n}\n```\n\n\n\n接口的设计目的，是对类的行为进行约束（更准确的说是一种“有”约束，因为接口不能规定类不可以有什么行为），也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无，但不对如何实现行为进行限制。\n\n抽象类的实现目的，是代码复用，可以让这些类都派生于一个抽象类。在这个抽象类中实现了共有的方法，避免让所有的子类来实现这个共有的方法，这就达到了代码复用的目的。\n\n---\n\n以上就是我对抽象类和接口的一些理解，如果有错误之处欢迎大家指出。","tags":["接口","抽象类"],"categories":["Java基础"]},{"title":"关于我对Socket的暂时理解","url":"/计算机网络/关于我对Socket的暂时理解","content":"\n\n\n为什么说是对Socket的暂时理解呢，因为Socket这玩意真要深入了解那可以很深很深，其涉及到的TCP/IP协议栈里面包含了太多内容了，而我之前是对Socket一无所知的，上次面试有面试官问：“你会Socket编程吗？”， 我一脸懵逼直摇头。于是此次，用这次博文，记录下自己对Socket的暂时理解，希望以后能在工作中通过这门技术去完成某项工作，然后在实践和尝试中去加深对Socket的理解。\n\n# 1. Socket原理\n\n要写网络程序就必须要用到Socket，甚至有句话说“一切皆Socket”，听起来夸张，其实事实如此。敲了那么多代码，其实很多地方都使用到了Socket，但是我以前一直觉得Socket是个遥远且深奥的东西，所以未曾去了解过它。\n\n## 1.1 Sokcet的位置\n\n<img src=\"https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20201002154703.jpeg\" alt=\"img\" style=\"zoom: 80%;\" />\n\n通过此图我们可以看到，Socket就如同一道门，从应用层通往传输层，处在应用层的用户进程不需要知道传输层发生了什么，他们只需要知道如何去开启Socket这道门即可。\n\n所以，Socket是应用层与TCP/IP协议族通信的中间软件抽象层，Socket是一组接口，它把复杂的TCP/IP协议族隐藏在Socket这道门后面，对于用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。\n\n## 1.2 Socket概念\n\n通过上文，我们知道网络中就是通过Socket来进行通信，应该对Socket的概念也有了一些抽象的理解。\n\nSocket就是通信的基石，是支持TCP/IP协议的路通信的基本操作单元。可以将套接字看作不同主机间的进程进行双间通信的端点，它构成了单个主机内及整个网络间的编程界面，这是一个逻辑上的概念。\n\n>  通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 Socket中，该 Socket通过与网络接口卡相连的传输介质将这段信息送到另外一台主机的 Socket中，使对方能够接收到这段信息。 Socket是由IP地址和端口结合的，提供向应用层进程传送数据包的机制\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20201002160113.jpeg)\n\n简单的来说，Socket是对TCP/IP协议的封装，Socket本身只是一个调用接口（API），方便程序员用Socket使用TCP/IP协议栈。\n\n# 2. Socket工作流程\n\nSocket的工作流程分为两个部分：\n\n* 服务端需要建立 socket 来监听指定的地址，等待客户端连接\n* 客户端则需要建立 socket 并与服务端的 socket 地址进行连接\n\n<img src=\"https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20201002173653.jpeg\" alt=\"img\" style=\"zoom:150%;\" />\n\n这图展示的就是建立 TCP/IP 连接的过程，经典的叫法为“**三次握手**”的过程。顾名思义，这个过程中来回产生了三次网络通信。\n\n建立连接后就可以进行数据传输了！\n\n![image-20201002174113494](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20201002174114.png)\n\n传输的过程涉及到数据 Copy，不过这些 Copy 是必不可少的。其中的发送缓冲区和接收缓冲区就是套接字缓存 (socket buffer)。\n\n![image-20201002174228848](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20201002174229.png)\n\n连接使用完之后需要关闭，不过 TCP/IP 连接关闭过程比创建更复杂一些，次数多了一次，这就是经典的“**四次握手**”过程。\n\n# 3. Socket的基本操作\n\nUnix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –> 读写write/read –> 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关\n\n## 3.1. socket()\n\n```\nint socket(int domain, int type, int protocol);\n```\n\nsocket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。\n\n正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：\n\n- domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。\n- type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（可以百度下Socket类型）。\n- protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议（这个协议我将会单独开篇讨论！）。\n\n注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。\n\n当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。\n\n## 3.2. bind()\n\n```\nint bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\n```\n\nbind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。\n\n- sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。\n- addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。\n- addrlen：对应的是地址的长度。\n\n## 3.3. listen()与connect()\n\n如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。\n\n```\nint listen(int sockfd, int backlog);\nint connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\n```\n\nlisten函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。\n\nconnect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。\n\n## 3.4. accept()\n\nTCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。**TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了**。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。\n\n```\nint accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);\n```\n\naccept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。\n\n注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。\n\n## 3.5. read()、write()\n\n万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：\n\n- read()/write()\n- recv()/send()\n- readv()/writev()\n- recvmsg()/sendmsg()\n- recvfrom()/sendto()\n\n推荐使用recvmsg()/sendmsg()函数，这两个函数是最通用的I/O函数，实际上可以把上面的其它函数都替换成这两个函数。\n\n## 3.6. close()\n\n在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。\n\n```\nint close(int fd);\n```\n\nclose一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。\n\n注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。\n\n# 4. 总结\n\nSocket编程基本就是listen，accept以及send，write等几个基本的操作。是的，就跟常见的文件操作一样。\n\n对于网络编程，我们也言必称TCP/IP，对于TCP/IP，我们还知道TCP和UDP，前者可以保证数据的正确和可靠性，后者则允许数据丢失。最后，我们还知道，在建立连接前，必须知道对方的IP地址和端口号。\n\n\n\n看资料的时候还看到一个大佬写的一段话，挺有感触的，也贴上来吧。\n\n> 不要去考虑这些形而上学的东西，什么本质，什么概念。\n> 这些东西都是理解了这些技术的人用语言表达的时候使用的说法。\n> 需要做的是到实践中去掌握这项技术能够完成什么工作，怎么使用它。\n> 当能够熟练使用的时候再去看就明白了。\n>\n> \n> 换句话说，那些文章是写给看得懂的人看的\n> 不能通过阅读这些文章学会这些技术\n> 最好通过实践和尝试学会这些技术\n>\n> \n>\n> 作者：王小明\n> 链接：https://www.zhihu.com/question/64316083/answer/218935997\n\n\n\n参考文章：\n\n1. https://blog.csdn.net/pashanhu6402/article/details/96428887\n2. https://www.zhihu.com/question/29637351/answer/534704474\n3. https://www.zhihu.com/question/64316083/answer/220480072","tags":["Socket"],"categories":["计算机网络"]},{"title":"浅谈远程过程调用——RPC","url":"/分布式/浅谈远程过程调用——RPC","content":"\n\n\n在复习SpringCloud的时候总是会遇到RPC这一词，但又不知道是何方神圣，上网冲浪了解了一下RPC，在此记录下对RPC的初步认识。\n\n# 1. 什么是RPC\n\n## 1.1 本地过程调用\n\n如果我们需要将本地的Student对象的age加1，那么就需要写一个Student addAge(Student student)方法，将student对象作为形参传入，将student的年龄进行+1，再返回student对象即可。这个过程我们称作**本地过程调用**。本地过程调用的函数体通过函数指针来指定。\n\n## 1.2 远程过程调用\n\n那么如果addAge()方法的方法体不在本地，而是在另外一台服务器上，该怎么办呢？\n\n也就是说有两台机器，一台服务器A，一台服务器B，一个应用部署在服务器A上，想要调用服务器B上的应用提供的方法，但是因为不在同一个服务器上，不能直接调用，这个时候就需要通过网络来表达调用的语义和需要传达的数据。\n\n这个过程称作**远程过程调用**，而RPC就是远程过程调用（Remote Procedure Call）的缩写形式。\n\n## 1.3 RPC概念总结\n\nRPC即远程过程调用，通过RPC，我们可以像调用本地方法一样去调用远程机器上的方法。\n\n# 2. RPC所解决的问题\n\n## 2.1 需要调用什么方法？\n\n### 2.1.1 Call ID映射\n\n我们怎么让远程机器知道我们要调用的是什么方法呢？为什么是addAge()而不是addMoney()？\n\n在本地调用中，我们通过函数指针去来指定对应的函数体，但是在远程调用中，函数指针是不可行的，因为我们所需要执行的函数体是在另外一台机器上的，也就是说addAge()是在另外一个进程中的，两个进程的内存空间是不一样的，所以函数指针不可行。\n\n在RPC中，所有的函数/方法都会存在一个自己的Call ID，这个Call ID在每个进程中的都是唯一确定的，而且每个进程需要维护一个{函数体 ↔ Call ID}的对应表。不同进程的表可以不同，但对应的函数的Call ID必须相同，也就是说 ，**同一个函数，同一个Call ID**。\n\n在远程调用的时候，当前进程进行查表，找出该函数对应的Call ID，然后把Call ID传递给远程机器，远程机器再通过查表，找出Call ID对应的函数，然后执行相应函数的函数体。\n\n## 2.2 参数值以什么形式传递？\n\n### 2.2.1 序列化和反序列化\n\n在上文中，我们提到了将Call ID传递给远程机器，而且大多数情况下我们还需要传递一些参数给远程机器，那么怎么传递呢？\n\n在本地过程调用中，我们只需要将参数压入栈中，然后函数再将参数从栈中弹出来即可，但是远程调用的时候，不同的进程，不同的内存空间，是无法通过内存进行参数传递的，甚至可能两个进程使用的不是同一种语言（一个为Python、一个为Java）。\n\n在PRC中，客户端会将参数序列化成一个字节流，传给服务端，服务端再将字节流反序列化为自己可以读取的格式，这个过程称作**序列化**和**反序列化**。\n\n简而言之：**客户端和服务端通过序列化和反序列化对参数进行处理**。\n\n## 2.3 怎么传递参数值？\n\n### 2.3.1 网络\n\n将参数值进行序列化后怎么传递给远程机器呢？\n\n远程调用往往用在网络上，客户端与服务端通过网络进行连接，所有的数据经过序列化成字节流后，通过网络传递给服务端。\n\n**所有的数据通过网络进行传递**，因此就需要一个网络传输层，网络传输层需要把 Call ID 和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。\n\n只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。\n\n尽管大部分 RPC 框架都使用 TCP 协议，但其实 UDP 也可以，而 gRPC 干脆就用了 HTTP2。\n\nTCP的连接是最常见的，大部分都通过TCP进行连接，简要分析下TCP连接：TCP连接可以是按需连接的（即需要调用的时候就先建立连接，调用结束后就立马断掉），也可以是长连接的（即维持连接的状态不变，不管是否有数据报的发送，可以配合心跳检测判定连接是否存活），多个远程过程调用共享同一个连接。\n\n![image-20200929201826064](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200929201826.png)\n\n# 3.网络传输协议\n\n上文说明了要实现一个 RPC，需要选择网络传输的方式。\n\n在 RPC 中可选的网络传输方式有多种，可以选择 TCP 协议、UDP 协议、HTTP 协议。\n\n每一种协议对整体的性能和效率都有不同的影响，我们需要选择一个正确的网络传输协议。\n\n## 3.1 基于 TCP 协议的 RPC 调用\n\n由服务的调用方与服务的提供方建立Socket连接，并且由服务的调用方通过Socket将调用的接口名称、参数、方法名称序列化后传递给服务的提供方，服务的提供方反序列化后利用反射去调用相关的方法。\n\n将结果返回给服务的调用方，整个基于 TCP 协议的 RPC 调用大致如此。\n\n但是在实例应用中则会进行一系列的封装，如 RMI 便是在 TCP 协议上传递可序列化的 Java 对象。\n\n## 3.2 基于HTTP协议的RPC调用\n\n该方法更像是访问网页一样，只是它的返回结果更加单一简单。\n\n其大致流程为：由服务的调用者向服务的提供者发送请求，这种请求的方式可能是 GET、POST、PUT、DELETE 等中的一种，服务的提供者可能会根据不同的请求方式做出不同的处理，或者某个方法只允许某种请求方式。\n\n而调用的具体方法则是根据 URL 进行方法调用，而方法所需要的参数可能是对服务调用方传输过去的 **XML 数据**或者 **JSON 数据**解析后的结果，返回 JOSN 或者 XML 的数据结果。\n\n由于目前有很多开源的 Web 服务器，如 Tomcat，所以其实现起来更加容易，就像做 Web 项目一样。\n\n## 3.2 两种方式的对比\n\n基于 TCP 的协议实现的 RPC 调用，由于 TCP 协议处于协议栈的下层，能够更加灵活地对协议字段进行定制，减少网络开销，提高性能，实现更大的吞吐量和并发数。（其实这一段我不太理解，源于我脆弱的计算机网络基础）\n\n但是需要更多关注底层复杂的细节，实现的代价更高。同时对不同平台，如安卓，iOS 等，需要重新开发出不同的工具包来进行请求发送和相应解析，工作量大，难以快速响应和满足用户需求。\n\n基于 HTTP 协议实现的 RPC 则可以使用 JSON 和 XML 格式的请求或响应数据。\n\n而 JSON 和 XML 作为通用的格式标准(使用 HTTP 协议也需要序列化和反序列化，不过这不是该协议下关心的内容，成熟的 Web 程序已经做好了序列化内容)，开源的解析工具已经相当成熟，在其上进行二次开发会非常便捷和简单。\n\n但是由于 HTTP 协议是上层协议，发送包含同等内容的信息，使用 HTTP 协议传输所占用的字节数会比使用 TCP 协议传输所占用的字节数更高。\n\n因此在同等网络下，通过 HTTP 协议传输相同内容，效率会比基于 TCP 协议的数据效率要低，信息传输所占用的时间也会更长，当然压缩数据，能够缩小这一差距。\n\n","tags":["RPC"],"categories":["分布式"]},{"title":"MySQL高级篇笔记（五）主从复制","url":"/MySQL/笔记/MySQL高级篇笔记（五）主从复制","content":"\n\n\n# 四、MySQL主从复制\n\n## 1. 复制的基本原理\n\n### 1.1. slave会从master读取binlog来进行数据同步\n\n### 1.2. 三步骤+原理图\n\n## 2. 复制的基本准则\n\n* 每个slave只有一个master\n* 每个slave只能有一个唯一的服务器ID\n* 每个master可以有多个salve\n\n## 3. 复制最大问题\n\n\n\n## 4. 一主一从常见配置","tags":["MySQL主从复制"],"categories":["MySQL"]},{"title":"MySQL高级篇笔记（四）锁机制","url":"/MySQL/MySQL高级篇笔记（四）锁机制","content":"\n\n\n# 四、MySQL锁机制\n\n## 1. 概述\n\n### 1.1. 定义\n\n锁是计算机协调多个进程或线程并发访问某一资源的机制。\n\n在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。\n\n### 1.2. 生活例子\n\n打个比方，我们到淘宝上买一件商品，商品只有一件库存，这个时候如果还有另一个人买，\n那么如何解决是你买到还是另一个人买到的问题？\n\n这里肯定要用到事务，我们先从库存表中取出物品数量，然后插入订单，付款后插入付款表信息，\n然后更新商品数量。在这个过程中，使用锁可以对有限的资源进行保护，解决隔离和并发的矛盾。\n\n## 2. 锁的分类\n\n### 2.1. 从对数据操作的类型分类\n\n* 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会相互影响。如果事务T对数据A加上读锁，那么其他事务只能对数据A再加读锁，不能加写锁。获取到读锁的事务只能读数据，不能写数据。\n* 写锁（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。\n\n### 2.2. 从对数据操作的颗粒度分类\n\n为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上只需要锁定当前操作的数据，这样会得到最高的并发度，但是管理锁是很耗资源的事情（涉及到锁的获取、检查、释放锁等动作），因此数据库需要在高并发响应和系统性能两方面进行平衡，这样就产生了“颗粒度”的概念。\n\n一种提高共享资源并发性的方式是让锁定对象更有选择性，尽量只锁定需要修改的部分，而不是所有的资源。更理想的是，只会对修改的数据片进行精确的锁定。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。\n\n* 表锁\n* 行锁\n\n## 3. 三锁\n\n### 3.1. 表锁（偏读）\n\n#### 3.1.1. 特点\n\n偏向MyISAM存储引擎，加锁快，开销小，无死锁。锁的粒度比较大，发生锁冲突的概率最高，并发度最低。\n\n#### 3.1.2. 案例分析\n\n**建表SQL**\n\n```\ncreate table mylock( \n id int not null primary key auto_increment， \n name varchar(20) \n) engine myisam; \n \ninsert into mylock(name) values('a'); \ninsert into mylock(name) values('b'); \ninsert into mylock(name) values('c'); \ninsert into mylock(name) values('d'); \ninsert into mylock(name) values('e'); \n \nselect * from mylock; \n```\n\n**手动增加表锁**\n\n```\nlock table 表名字1 read(write)， 表名字2 read(write)，其它 ;\n```\n\n**查看表上加过的锁**\n\n```\nshow open tables;\n```\n\n![image-20200904194621258](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200904194644.png)\n\nin_use列为1时，表示有锁\n\n**释放表锁**\n\n```\nunlock tables;\n```\n\n**加读锁**\n\n为mylock表加read锁，分别打开两个命令行session1和session2对同一个表进行操作。\n\n![在这里插入图片描述](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200904194844.png)\n\n加入读锁之后：\nsession1可以读已经加锁的表，但是不能改或者读其他没加锁的表，因为前面\"欠的账还没有清\"。\nsession2可以查看已锁定的表，可以查看其他未锁定的表，但是操作加锁的表会阻塞等待，会导致系统性能下降。\n\n**加写锁**\n\nmylock write(MyISAM)\n\n![在这里插入图片描述](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200904194943.png)\n\n注意session1去读取其他的表同样会报错，原因同读锁“欠的账还没有还清”\n\n**结论**\n\nMyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。\nMySQL的表级锁有两种模式：\n\n* 表共享读锁（Table Read Lock）\n* 表独占写锁（Table Write Lock）\n\n![image-20200904200653388](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200904200653.png)\n\n结合上表，所以对于MyISAM表进行操作，会有以下情况：\n\n* 加读锁，不会阻塞其他进程对加读锁的这一张表的读操作，但会阻塞对这张表的写操作。当读锁释放后，才会执行其他其他线程的写操作。\n* 加写锁，会阻塞其他进程对加写锁的这张表的读和写操作，只有当写锁释放后，其他进程的读写操作才能正常执行\n\n简而言之：**读锁会阻塞写，写锁会阻塞读和写。**\n\n#### 3.1.3. 分析表锁定\n\n可以通过检查 table_ locks waited和 table_ locks_immediate状态变量来分析系统上的表锁定\n\n```\nshow status like ‘table%’\n```\n\n![在这里插入图片描述](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200904201108.png)\n这里有两个状态变量记录 MySQL内部表级锁定的情况，两个变量说明如下:\n\n* Table_ locks_ immediate：产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加1;\n* Table_ locks_waited出现表级锁定争用而发生等待的次数(不能立即获取锁的次数，每等待一次锁值加1)，此值高则说明存在着较严重的表级锁争用情况。\n\n**此外，MyISAM的读写锁调度是写优先，这也是MyISAM不适合做写为主的引擎，因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞，所以表锁偏读。**\n\n### 3.2. 行锁（偏写）\n\n#### 3.2.1. 行锁特点\n\n偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。\nInnoDB与MyISAM的最大不同有两点：**一是支持事务（TRANSACTION）；二是采用了行级锁。**\n\n#### 3.2.2. 事务特点\n\n事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性。\n\n* 原子性（Atomicity） ：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。\n* 一致性（Consistent） ：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。\n* 隔离性（Isolation） ：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。\n* 持久性（Durable） ：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。\n\n#### 3.2.3. 并发处理事务带来的问题\n\n- 更新丢失(Lost Update)\n\n当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题，最后的更新覆盖了由其他事务所做的更新。\n\n例如，两个程序员修改同一java文件。每程序员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖前一个程序员所做的更改。\n\n如果在一个程序员完成并提交事务之前，另一个 程序员不能访问同一文件，则可避免此问题。\n\n- 脏读(Dirty Reads)\n\n一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做”脏读”。\n\n一句话：事务A读取到了事务B **已修改但尚未提交** 的的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取\n的数据无效，不符合一致性要求。\n\n- 不可重复读(Non-Repeatable Reads)\n\n在一个事务内，多次读同一个数据。在这个事务还没有结束时，另一个事务也访问该同一数据。那么，在第一个事务的两次读数据之间。由于第二个事务的**修改**，那么第一个事务读到的数据可能不一样，这样就发生了在一个事务内两次读到的数据是不一样的，因此称为不可重复读，即原始读取不可重复。\n\n一句话：一个事务范围内两个相同的查询却返回了不同数据。\n\n- 幻读(Phantom Reads)\n\n一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务**插入**了满足其查询条件的新数据，这种现象就称为“幻读”。\n\n一句话：事务A读取到了事务B提交的新增数据，不符合隔离性。\n\n#### 3.2.4. 事务隔离级别\n\n“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。\n\n![在这里插入图片描述](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200906145634.png)\n\n数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上 “串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。\n\n查看当前数据库的事务隔离级别：\n\n```\nshow variables like 'tx_isolation'\n```\n\n![image-20200906145848899](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200906150405.png)\n\n从图中可以看到MySQL默认的隔离级别是可重复读，也就说明MYSQL默认能够解决脏读和不可重复读的问题，但是不能解决幻读的问题。\n\n#### 3.2.5. 案例分析\n\n**建表SQL**（注意engine=innodb）\n\n```\ncreate table test_innodb_lock (a int(11),b varchar(16)) engine=innodb; \n\n\ninsert into test_innodb_lock values(1,'b2'); \ninsert into test_innodb_lock values(3,'3'); \ninsert into test_innodb_lock values(4,'4000'); \ninsert into test_innodb_lock values(5,'5000'); \ninsert into test_innodb_lock values(6,'6000'); \ninsert into test_innodb_lock values(7,'7000'); \ninsert into test_innodb_lock values(8,'8000'); \ninsert into test_innodb_lock values(9,'9000'); \ninsert into test_innodb_lock values(1,'b1'); \n\n\ncreate index test_innodb_a_ind on test_innodb_lock(a); \n\n\ncreate index test_innodb_lock_b_ind on test_innodb_lock(b); \n\n\nselect * from test_innodb_lock; \n\n```\n\n**行锁定基本演示**\n\n![在这里插入图片描述](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200906154555.png)\n\n为了测试行锁，先将自动提交关闭，每次都需要手动提交，set autocommit = 0\n\n![image-20200906154743780](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200906154744.png)\n\n因为关闭了自动提交，所以session2没有读到sessoin1中的修改，两边都需要进行commit，按照正常的如果sessioin1关闭了自动提交，session2没有关闭自动提交的话，只需要session1执行commit，但是这里的session2也是关闭自动提交的，所以session2也应该执行commit。\n\n![image-20200906154757777](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200906154758.png)\n\nsession1操作4005行 ， session2操作 9001 行，双方互不影响，都能成功。\n\n**无索引行锁升级为表锁（索引失效 ）**\n\n![在这里插入图片描述](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200906154920.png)\n\n![image-20200906155008012](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200906155008.png)\n\n原因分析：b是varchar类型，这里设置为4000，在mysql底层会自动做一次转换，转换为varchar，所以索引失效，行锁变成了表锁，导致seesion1操作a=41，session2操作a=9，session2会阻塞。所以生产环境中一定注意varchar加”“。\n\n**select也可以加锁**\n\n（1）读锁：select …lock in share mode\n\n（2）写锁：select… for update\n\n在查询语句后面增加 FOR UPDATE ，Mysql会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。\n\n**间隙锁的危害**\n\n![在这里插入图片描述](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200906160047.png)\n\n![在这里插入图片描述](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200906160059.png)\n\n注意原表中是没有a=2的，这个时候操作session1，session2设置a=2的值会阻塞，只有当session1 commit之后，session2才能操作成功。session1用的范围查询，a中1~6 虽然没有2，但是也认为2在里面，也给锁住，session2操作的时候就会阻塞。\n\n这就是MYSQL，宁可错杀一千，也不放过一个。\n\n> 什么是间隙锁？\n\n当我们使用范围条件而不是相等条件去检索数据时，并请求共享锁或者排他锁时，Innodb会给符合条件的数据记录的索引项加锁；对于键值不存在但是满足范围条件的记录，叫做“间隙”（GAP）\n\nInnodb会给这个间隙加锁，这个锁机制就是所谓的”间隙锁“（GAP LOCK）\n\n> 间隙锁的危害\n\n因为在Query执行过程中，MYSQL会锁定整个范围内的所有索引键值，即使这个键值不存在。\n\n间隙锁有一个致命的弱点，就是当锁定一个范围内的键值时，即使某个键值不存在也会被锁定，这就造成了在锁定的时候无法插入锁定范围内的任何数据，在某些场景下这可能会对性能造成极大的危害。\n\n**案例结论**\n\nInnodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。\n\n但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MyISAM高，甚至可能会更差。\n\n#### 3.2.6. 行锁分析\n\n**如何分析行锁定？**\n\n通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况\n\n```\nshow status like 'innodb_row_lock%';\n```\n\n![image-20200906161114317](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200906161114.png)\n\n**变量分析**\n\n对各个状态量的说明如下：\n\nInnodb_row_lock_current_waits：当前正在等待锁定的数量\nInnodb_row_lock_time：从系统启动到现在锁定总时间长度\nInnodb_row_lock_time_avg：每次等待所花平均时间\nInnodb_row_lock_time_max：从系统启动到现在等待最长的一次所花的时间\nInnodb_row_lock_waits：系统启动后到现在总共等待的次数\n对于这5个状态变量， 比较重要的主要是\n\nInnodb_row_lock_time_avg（等待平均时长）\nInnodb_row_lock_waits（等待总次数）\nInnodb_row_lock_time（等待总时长）\n\n当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。\n\n最后可以通过`SELECT * FROM information_schema.INNODB_TRX\\G;`来查询正在被锁阻塞的sql语句。\n\n#### 3.2.7. 面试题：如何锁定一行\n\n![image-20200906162325479](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200906162325.png)\n\n#### 3.2.8. 行锁总结\n\n* 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。\n* 尽可能较少检索条件，避免间隙锁。\n* 尽量控制事务大小，减少锁定资源量和时间长度。\n* 锁住某行后，尽量不要去调别的行或表，赶紧处理被锁住的行然后释放掉锁。\n* 涉及相同表的事务，对于调用表的顺序尽量保持一致。\n* 在业务环境允许的情况下,尽可能低级别事务隔离。\n* \n\n### 3.3. 页锁（了解）\n\n开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。\n\n","tags":["MySQL锁机制"],"categories":["MySQL"]},{"title":"快速理解脏读、不可重复读和幻读","url":"/MySQL/快速理解脏读、不可重复读和幻读","content":"\n\n\nMySQL的InnoDB引擎是支持事务的，但是并发事务的处理又会带来以下问题：\n\n* 脏读\n* 不可重复读\n* 幻读\n\n# 一、脏读\n\n脏读指事务A读取到了事务B更新了但是未提交的数据，然后事务B由于某种错误发生回滚，那么事务A读取到的就是脏数据。\n\n具体的说，一个数据原本是干净的，但是事务B将它进行修改使得其不再干净，此时事务A读取到事务B修改后的数据，也就是脏数据，称为脏读，后来事务B由于良心发现又将数据回滚为最初的样子，而事务A不知道事务B进行了回滚操作，最终事务A读取到的是脏数据，称为脏读。\n\n![image-20200904212452020](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200904212523.png)\n\n**结论：读取未提交的数据！**\n\n# 二、不可重复读\n\n不可重复读指在数据库访问时，一个事务在前后两次相同的访问中却读到了不同的数据内容。\n\n比如说事务A的执行周期较长，事务A在第一次读取某个数据时，此数据的值为100，读取完成后，事务A又去执行其他的事情，在这个过程中，事务B将这个数据的值修改为200，然后事务A做完其他的事情后，又来读取这个数据的值，发现这个值和第一次所读取的值不相同，这种现象称为不可重复读。\n\n![image-20200904212959873](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200904213000.png)\n\n**结论：前后多次读取，数据内容不一致！**\n\n# 三、幻读\n\n幻读指的是事务A在查询完记录总数后，事务B执行了新增数据的操作，事务A再次查询记录总数，发现两次查询的结果不一致，平白无故的多了几条记录，这种现象称为幻读。\n\n![image-20200904213414876](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200904213415.png)\n\n# 四、不可重复度和幻读的区别\n\n幻读和不可重复读的本质是一样的，两者都表现为两次读取的结果不一致。但是不可重复读指的是两次读取同一条记录的值不同，而幻读指的是两次读取的记录数量不同。\n\n**不可重复读重点在于update和delete，而幻读的重点在于insert。**\n\n如果使用锁机制来实现这两种隔离级别，在不可重复读中，事务A第一次读取到数据后，就将这些数据加行锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住新增的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以新增数据并提交，这时事务A就会 发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。\n\n**所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。**","tags":["事务"],"categories":["MySQL"]},{"title":"MySQL高级篇笔记（三）查询截取分析","url":"/MySQL/MySQL高级篇笔记（三）查询截取分析","content":"\n## 三、查询截取分析\n\n### 1、查询优化\n\n#### （1）小表驱动大表\n\n即小的数据集驱动大的数据集\n\n```\nselect * from A where id in (select id from B)\n等价于：\nfor select id from B\nfor select * from A where A.id=B.id\n```\n\n> 用in 还是 exists ？\n\n当B的数据集必须小于A表的数据集时，用in优于exists\n\n```\nselect * from A where exists (select 1 from B where B.id=A.id)\n等价于：\nfor select id from B\nfor select * from A where A.id=B.id\n```\n\n**EXISTS**\n\nSELECT ... FROM table WHERE EXISTS (subquery)\n\n该语法可以理解为：将主查询的数据，放到子查询中做条件验证，根据验证结果（TRUE OR FALSE）来决定主查询的数据结果是否得以保留\n\n> 提示\n\n1. EXSITS(subquery)只返回true或者false，因此子查询中的select *也可以是select 1或者select，官方说法是实际执行时会忽略select清单，因此没有区别\n2. EXISTS子查询的实际执行过程可能经过了优化而不是我们所理解的逐条对比，如果担忧效率问题，可进行实际检验以确定是否有效率问题\n3. EXISTS子查询往往也可以用条件表达式，其他子查询或者JOIN来替代，何种最优需要具体问题具体分析\n\n\n\n#### （2）order by关键字优化\n\n**1）ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序**\n\n建立索引\n\n```\ncreate index idx_A_ageBirth on tblA(age,birth);\n```\n\n进行分析\n\n![image-20200804104124775](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200804104124.png)\n\n* order by birth，缺失age，索引失效，产生了filesort\n* 同 （1）\n* order by age，age排在了前面，没有违背最左前缀原则，所以没有filesort\n* 一升一降导致之前建立索引时的排序无效，只能使用了mysql内排序了，所以产生了filesort\n\n> 小总结\n\n<img src=\"https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200829140257.png\" alt=\"image-20200829140257314\" style=\"zoom:67%;\" />\n\n> 结论\n\n以下两种情况会使用Index方式排序：\n\n* order by语句使用索引最左前列\n* 使用where子句与order by子句条件列组合满足索引最左前列\n\n**2）尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀**\n\n**3）如果不在索引列上，filesort有两种算法：双路排序和单路排序**\n\n* 双路排序：\n\n  MySQL4.1之前是使用双路排序，字面意思是两次扫描磁盘，最终得到数据\n\n  读取行指针和order by列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据传输\n\n  从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段\n\n  > 问题是：取一批数据，要对磁盘进行两次扫描，众所周知，I\\O是很耗时的，所以在mysql4.1之后，出现了第二张改进的算法，就是单路排序。\n\n* 单路排序：\n\n  从磁盘读取查询**需要的所有列**，按照orderby列在buffer区对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据，并且把随机IO变成顺序IO，但是它会使用更多的空间，因为它把每一行都保存在内存中了\n\n* 结论：\n\n  * 由于单路是后出来的，总体而言好过双路\n\n  * 但是用单路有问题：\n\n    ![image-20200804120103660](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200804120103.png)\n\n**4）优化策略**\n\n* 增大sort_buffer_size参数的设置\n* 增大max_length_for_sort_data参数的设置\n\n原因分析：\n\n![image-20200804140824337](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200804140824.png)\n\n#### （3）group by关键字优化\n\n1）group by实质是先排序后进行分组，遵循索引建的最佳左前缀\n\n2）当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置\n\n3）where高于having，能写在where限定的条件就不要去having限定了\n\n> 去重优化\n\n尽量不要使用 distinct 关键字去重\n\n```\nt_mall_sku 表\n  \tid    shp_id      kcdz                \n-------  ------- --------------------\n     3       1    北京市昌平区  \n     4       1    北京市昌平区  \n     5       5    北京市昌平区  \n     6       3       重庆              \n     8       8     天津    \n```\n\n例子：\n\nselect kcdz form t_mall_sku where id in( 3,4,5,6,8 ) 将产生重复数据，\nselect distinct kcdz form t_mall_sku where id in( 3,4,5,6,8 ) 使用 distinct 关键字去重消耗性能\n优化： \n\nselect kcdz form t_mall_sku where id in( 3,4,5,6,8 ) group by kcdz 能够利用到索引\n\n### 2、慢查询日志\n\n#### （1）慢查询日志是什么？\n\n- MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。\n- 具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值是10，意思是运行10秒以上的语句。\n- 由它来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒，我们就算慢SQL，希望能收集超过5秒的sql，结合之前的Explain进行分析。\n\n#### （2）慢查询日志的用法\n\n> 默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。\n> 当然，如果不是调优需要，一般不建议开启该参数，因为开启慢查询日志会或多或少带来一定的性能影响。\n> 慢查询日志支持将日志记录写入文件。\n\n**1）查看是否开启以及如何开启**\n\n![image-20200812135139444](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200812135154.png)\n\n默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的，可以通过设置slow_query_log的值来开启\n\n> 开启慢查询日志方法一\n\n![image-20200812135346509](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200812135346.png)\n\n<center>开启慢查询日志</center>\n\n使用SET GLOBAL slow_query_log=1;开启了慢查询日志只对当前数据库生效，如果重启MySQL后则会失效（或者使用\n\nSET GLOBAL slow_query_log=0;关闭）\n\n> 开启慢查询日志方法二\n\n![image-20200812135642829](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200812135642.png)\n\n\n\n**2）开启了慢查询日志后，怎样的SQL才会记录到慢查询日志里面呢**\n\n这个是由参数long_query_time控制的，默认情况下long_query_time的值为10秒\n\n![image-20200812140017736](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200812140017.png)\n\n\n\n可以使用命令修改该参数，也可以在my.cnf里修改\n\n加入时间正好等于long_query_time的情况，是不会被记录，也就是说在mysql源码里是判断大于long_query_time，而非大于等于\n\n\n\n**3）案例**\n\n①查看当前多少秒算慢\n\n![image-20200812141923788](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200812141923.png)\n\n②设置慢的时间阈值\n\n![image-20200812142048599](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200812142048.png)\n\n③为什么设置后看不出变化\n\n需要重新连接或重开一个会话才能看到修改值\n\n或者不用重开或连接，直接用命令：\n\n```\nSHOW GLOBAL VARIABLES LIKE '%long_query_time%';\n```\n\n![image-20200812142149303](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200812142149.png)\n\n④记录慢SQL并后续分析\n\n![image-20200812142709981](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200812142710.png)\n\n⑤查看当前系统有多少条慢查询记录\n\n![image-20200812142808530](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200812142808.png)\n\n**4）配置版**\n\n在【mysqld】下配置\n\n```\nslow_query_log=1;\nslow_query_log_file=/....(地址)\nlong_query_time=3;\nlog_output=FILE\n```\n\n这样就会永久生效\n\n### 3、日志分析工具mysqldumpslow\n\n在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow\n\n#### （1）查看mysqldumpslow的帮助信息\n\n![image-20200812143250127](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200829141156.png)\n\n```\ns：表示按照何种方式排序；\n\nc：访问次数；\n\nI：锁定时间\n\nr：返回记录\n\nt：查询时间\n\nal：平均锁定时间\n\nar：平均返回记录数\n\nat：平均查询时间\n\nt：返回前面有多少条数据\n\ng：后边搭配一个正则匹配模式，大小写不敏感\n```\n\n#### （2）工作常用参考\n\n得到返回记录集最多的10个SQL：\n\n```apache\nmysqldumpslow -s r -t 10 /DESKTOP-O360IRK-slow.log\n```\n\n得到访问次数最多的10个SQL：\n\n```apache\nmysqldumpslow -s c -t 10 /DESKTOP-O360IRK-slow.log\n```\n\n得到按照时间排序的前10条里面含有左连接的查询语句：\n\n```apache\nmysqldumpslow -s t -t 10 -g \"LEFT JOIN\" /DESKTOP-O360IRK-slow.log\n```\n\n另外建议在使用这些属性的时候结合 | 和more使用，否则可能出现爆屏的情况：\n\n```apache\nmysqldumpslow -s r -t 10 /DESKTOP-O360IRK-slow.log | more\n```\n\n### 4、批量数据脚本\n\n#### （1）创建表\n\n```\n# 新建库 \ncreate database bigData; \nuse bigData; \n \n \n#1 建表dept \nCREATE TABLE dept(   \nid INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,   \ndeptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,    \ndname VARCHAR(20) NOT NULL DEFAULT \"\",   \nloc VARCHAR(13) NOT NULL DEFAULT \"\"   \n) ENGINE=INNODB DEFAULT CHARSET=UTF8 ;   \n \n \n#2 建表emp \nCREATE TABLE emp   \n(   \nid INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,   \nempno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0, /*编号*/   \nename VARCHAR(20) NOT NULL DEFAULT \"\", /*名字*/   \njob VARCHAR(9) NOT NULL DEFAULT \"\",/*工作*/   \nmgr MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,/*上级编号*/   \nhiredate DATE NOT NULL,/*入职时间*/   \nsal DECIMAL(7,2) NOT NULL,/*薪水*/   \ncomm DECIMAL(7,2) NOT NULL,/*红利*/   \ndeptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0 /*部门编号*/   \n)ENGINE=INNODB DEFAULT CHARSET=UTF8 ;  \n```\n\n>  设置参数log_bin_trust_function_creators\n\n由于开启过慢查询日志， 因为我们开启了 bin-log，我们就必须为我们的function指定一个参数，否则会报错：This function has none of DETERMINISTIC...... \n\n我们可以通过设置参数log_bin_trust_function_creators来解决这个问题\n\n```mysql\nmysql> show variables like 'log_bin_trust_function_creators'; \n\n+---------------------------------+-------+\n| Variable_name                   | Value |\n+---------------------------------+-------+\n| log_bin_trust_function_creators | OFF   |\n+---------------------------------+-------+\n1 row in set\n\nmysql> set global log_bin_trust_function_creators=1; \nQuery OK, 0 rows affected\n\nmysql> show variables like 'log_bin_trust_function_creators'; \n+---------------------------------+-------+\n| Variable_name                   | Value |\n+---------------------------------+-------+\n| log_bin_trust_function_creators | ON    |\n+---------------------------------+-------+\n1 row in set\n\n# 这样添加了参数以后，如果mysqld重启，上述参数又会消失，永久方法： \nwindows下 修改my.ini，在[mysqld]中加上log_bin_trust_function_creators=1   \nlinux下 修改/etc/my.cnf下my.cnf[mysqld]加上log_bin_trust_function_creators=1 \n```\n\n#### （2）创建函数\n\n创建函数保证每条数据都不同（可用于压力测试）\n\n**随机产生字符串**\n\n```mysql\n// 这里的两个$$对应下面的end$$，可以是两个四个八个，也可以是其他的符号，表示函数的结束\n// 因为mysql默认的结尾是；但现在需要把多行写在一块，所有我们得改一下结尾，不再用；结束\n// 用两个$才表示这段程序结束\n// 也就是每次执行sql语句都需要通过$$才会结束\nDELIMITER $$ \n//减建立函数    使我们自定义的函数名字（rand_string）   RETURNS是返回值\nCREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255) \nBEGIN    ##方法开始 \n DECLARE chars_str VARCHAR(100) DEFAULT   'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';  \n ##声明一个 字符窜长度为 100 的变量 chars_str ,默认值  \n DECLARE return_str VARCHAR(255) DEFAULT ''; \n DECLARE i INT DEFAULT 0; \n##循环开始 \n WHILE i < n DO   \n SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1)); \n##concat 连接函数  ，substring(a,index,length) 从index处开始截取 \n SET i = i + 1; \n END WHILE; \n RETURN return_str; \nEND $$ \n \n#假如要删除函数\n#drop function rand_string; \n\n```\n\n![image-20200817195900797](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200817195931.png)\n\n**随机产生部门编号**\n\n```mysql\n#用于随机产生部门编号 \nDELIMITER $$ \nCREATE FUNCTION  rand_num( )  \nRETURNS INT(5)   \nBEGIN    \n DECLARE i INT DEFAULT 0;   \n SET i = FLOOR(100+RAND()*10);   \nRETURN i;   \n END $$ \n \n \n# 假如要删除 \n#drop function  rand_num ; \n```\n\n![image-20200817200043996](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200817200044.png)\n\n#### （3）创建存储过程\n\n> tip: 函数和存储过程的区别，函数有返回值，存储过程没有返回值\n\n**创建往emp表中插入数据的存储过程**\n\n```mysql\nDELIMITER $$ \n\n// 创建存储过程，第一个参数表示从多少id开始，第二个参数表示插入多少条数据\nCREATE PROCEDURE insert_emp(IN START INT(10),IN max_num INT(10))   \nBEGIN   \nDECLARE i INT DEFAULT 0;    \n#set autocommit =0 把autocommit设置成0  ；提高执行效率 ，例如，执行五十次insert，提交一次\n SET autocommit = 0;     \n REPEAT  ##重复 ，简而言之就是循环 相当于while true\n SET i = i + 1;   \n INSERT INTO emp(empno, ename ,job ,mgr ,hiredate ,sal ,comm ,deptno ) VALUES ((START+i) ,rand_string(6),'SALESMAN',0001,CURDATE(),FLOOR(1+RAND()*20000),FLOOR(1+RAND()*1000),rand_num());   \n UNTIL i = max_num   ##直到  上面定义的max_num也是一个循环 \n END REPEAT;  ##满足条件后结束循环 \n COMMIT;   ##执行完成后一起提交 \n END $$ \n \n#删除 \n# DELIMITER ; \n# drop PROCEDURE insert_emp; \n```\n\n**创建往dept表中插入数据的存储过程**\n\n```mysql\n#执行存储过程，往dept表添加随机数据 \n\nCREATE PROCEDURE insert_dept(IN START INT(10),IN max_num INT(10))   \nBEGIN   \nDECLARE i INT DEFAULT 0;    \n SET autocommit = 0;     \n REPEAT   \n SET i = i + 1;   \n INSERT INTO dept (deptno ,dname,loc ) VALUES (START +i ,rand_string(10),rand_string(8));   \n UNTIL i = max_num   \n END REPEAT;   \n COMMIT;   \n END $$  \n \n# 删除 \n# DELIMITER ; \n# drop PROCEDURE insert_dept; \n```\n\n#### （4）调用存储过程\n\n**对于dept表**\n\n```\n# 首先将结尾符号修改回；\nDELIMITER ; \n\n# 进行调用\nCALL insert_dept(100,10);  \n```\n\n![image-20200817200630167](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200817200630.png)\n\n**对于emp表**\n\n```mysql\n#执行存储过程，往emp表添加50万条数据\n\nDELIMITER ; #将结束标志换回;\nCALL insert_emp(100001,500000);\n\n\n# 演示\nmysql> DELIMITER ;\nmysql> CALL insert_emp(100001,500000);\nQuery OK, 0 rows affected\n```\n\n### 5、Show Profile\n\n是什么：是mysql提供可以用来分析当前会话中语句执行的资源消耗情况，可以用于SQL的调优的测量\n\n官网：http://dev.mysql.com/doc/refman/5.5/en/show-profile.html\n\n默认情况下，参数处于关闭状态，并保存最近15次的运行结果\n\n#### （1）分析步骤\n\n1）查看当前的mysql版本是否支持Show Profile\n\n```\nshow variables like 'profiling';\n\n# 默认是关闭，使用前需要开启\n```\n\n2）开启\n\n```\nset profiling=1;\n或者\nset profiling=on;\n```\n\n![image-20200818184112956](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200818184113.png)\n\n（3）运行SQL\n\n```\nselect * from emp group by id%20 order by 5;\nselect * from emp group by id%10 limit 150000;\n```\n\n（4）查看结果\n\n```\nshow profiles;\n```\n\n![image-20200818184530565](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200818184530.png)\n\n#### （2）参数说明\n\nDuratioin：持续的时间\nQuery：具体的操作\n\n> 诊断SQL\n\n```\nshow profile cpu,block io for query [n]\n\n# [n]为Query_ID\n```\n\n![image-20200818184840402](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200818184840.png)\n\n左边的status是sql语句的完整生命：连接、初始化、打开表、查找、缓存等\n\n若想查看其他的修改命令参数即可：\ntype:\n| ALL --显示所有的开销信息\n| BLOCK IO --显示块IO相关开销\n| CONTEXT SWITCHES --上下文切换相关开销\n| CPU --显示CPU相关开销信息\n| IPC --显示发送和接收相关开销信息\n| MEMORY --显示内存相关开销信息\n| PAGE FAULTS --显示页面错误相关开销信息\n| SOURCE --显示和Source_function，Source_file，Source_line相关的开销信息\n| SWAPS --显示交换次数相关开销的信息\n\n#### （3）日常开发\n\n如果status出现下面的就危险了\n\n- converting HEAP to MyISAM 查询结果太大，内存都不够用了往磁盘上搬了。\n- Creating tmp table 创建临时表\n\n> 如果你的SQL语句中有创建临时表的操作，数据量很大的话，创建临时表可能会使用较长的时间！\n\n![在这里插入图片描述](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200818185342.png)\n\n如上图，从创建临时表再到把临时表复制到磁盘中，占用了两秒多的时间\n\n### 6、全局查询日志\n\n#### （1）配置启用\n\n在mysql的my.cnf中，设置如下：\n\n```\n#开启 \ngeneral_log=1    \n# 记录日志文件的路径 \ngeneral_log_file=/path/logfile \n#输出格式 \nlog_output=FILE  \n```\n\n#### （2）编码启用\n\n命令\n\n```\nset global general_log=1; \n```\n\n全局日志可以存放到日志文件中，也可以存放到Mysql系统表中。存放到日志中性能更好一些，存储到表中的命令如下：\n\n```\nset global log_output='TABLE'; \n```\n\n此后 ，你所编写的sql语句，将会记录到mysql库里的general_log表，可以用下面的命令查看\n\n```\nselect * from mysql.general_log; \n```\n\n#### （3）永远不要在生产环境开启此功能\n\n","tags":["MySQL查询截取分析"],"categories":["MySQL"]},{"title":"MySQL高级篇笔记（二）索引优化分析","url":"/MySQL/MySQL高级篇笔记（二）索引优化分析","content":"### 1、性能下降、SQL慢、执行时间长、等待时间长的原因\n\n* 查询语句写的差\n* 索引失效\n  * 单值索引：新建索引的语句只实施在一列上\n  * 复合索引：在多个列上建立索引\n* 关联查询太多join(设计缺陷或不得已的需求)\n* 服务器调优及各个参数设置(缓冲\\线程数等)\n\n### 2、索引简介\n\n#### （1）索引是什么\n\nMySQL官方对索引的定义为：索引是帮助MySQL高效获取数据的数据结构，所以索引的本质是：**数据结构**，可以理解为排好序的快速查找数据结构\n\n> 索引的目的在于提高查询效率，可以类比字典，\n>\n> 如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。\n>\n> 如果没有索引，那么你可能需要a----z，如果我想找到Java开头的单词呢？或者Oracle开头的单词呢？\n> 是不是觉得如果没有索引，这个事情根本无法完成？\n\n在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式指向、引用数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是**索引**\n\n\n\n![image-20200731105450450](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODIwMTYwNDUxLnBuZw?x-oss-process=image/format,png)\n\n> 1. 左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址\n> 2. 为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录\n> 3. 一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上\n\n#### （2）索引的优势与劣势\n\n**优势：** \n\n* 类似图书馆对书本的检索，能够提高数据检索的效率，降低数据库的IO成本\n* 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗\n\n**劣势：** \n\n* 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息（改数据还得改索引）\n* 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间\n  的（索引也占空间）\n\n#### （3）MySQL索引分类\n\n##### a. 单值索引\n\n即一个索引只包含单个列，一个表可以由多个单列索引\n\n##### b. 唯一索引\n\n索引列的值必须唯一，但允许有空值\n\n##### c. 复合索引\n\n即一个索引包含多个列\n\n##### d. 基本语法\n\n![image-20200731111859847](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODIwMTYwOTQ3LnBuZw?x-oss-process=image/format,png)\n\n#### （4）MySQL索引结构\n\n**我们平常所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉的)结构组织的索引** 。其中聚集索引，次要索引，覆盖索引， 复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈希索引(hash index)等\n\n##### a. BTree索引\n\n![image-20200731113701252](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODIwMTYxMzEyLnBuZw?x-oss-process=image/format,png)\n\nMySQL使用的是Btree索引\n\n**初始化介绍：**\n\n一颗b树，黑框内的称之为一个磁盘块，每个磁盘块包含几个数据项（蓝色所示）和指针（黄色所示）\n\n如磁盘块 1 包含数据项 17 和 35，包含指针 P1、P2、P3， P1 表示小于 17 的磁盘块，P2 表示在 17 和 35 之间的磁盘块，P3 表示大于 35 的磁盘块。 真实的数据存在于叶子节点即 3、5、9、10、13、15、28、29、36、60、75、79、90、99。 **非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如 17、35 并不真实存在于数据表中**\n\n**查找过程：**\n\n如果要查找数据项 29，那么首先会把磁盘块 1 由磁盘加载到内存，此时发生一次 IO，在内存中用二分查找确定 29 在 17 和 35 之间，锁定磁盘块 1 的 P2 指针，内存时间因为非常短（相比磁盘的 IO）可以忽略不计，通过磁盘块 1 的 P2 指针的磁盘地址把磁盘块 3 由磁盘加载到内存，发生第二次 IO，29 在 26 和 30 之间，锁定磁盘块 3 的 P2 指 针，通过指针加载磁盘块 8 到内存，发生第三次 IO，同时内存中做二分查找找到 29，结束查询，总计三次 IO\n\n> 真实的情况是，3 层的 b+树可以表示上百万的数据，如果上百万的数据查找只需要三次 IO，性能提高将是巨大的， 如果没有索引，每个数据项都要发生一次 IO，那么总共需要百万次的 IO，显然成本非常非常高。\n\n##### b. B+Tree索引\n\n![image-20200820161403604](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODIwMTYxNjI1LnBuZw?x-oss-process=image/format,png)\n\n（1）B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；\n（2）B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；\n（3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。\n\n> 因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低\n\n##### c. full-text全文索引\n\n全文索引（也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用**分词技术**等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果\n\n##### d. Hash索引\n\nHash索引只有Memory，NDB两种引擎支持，Memory引擎默认支持Hash索引，如果多个hash值相同，出现哈希碰撞，那么索引以链表方式存储\nNoSql采用此中索引结构\n\n#### （5）索引创建时机\n\n##### a. 创建索引的情况\n\n* 主键自动建立唯一索引\n\n* 频繁作为查询条件的字段应该创建索引\n\n* 查询中与其他表关联的字段，外键关系应该建立索引\n\n* 单键/组合索引的选择问题， 组合索引性价比更高\n\n* 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度\n\n* 查询中统计或者分组字段\n\n##### b. 不适合创建索引的情况\n\n* 数据重复且分布平均的表字段，不应该为其建立索引（如“性别”字段只有男和女两种值，不应该建立索引，应该只为最经常查询和最经常排序的数据列建立索引）\n\n* 表记录太少\n* 经常增删改的表或者字段\n* Where 条件里用不到的字段不创建索引\n* 过滤性不好的不适合建索引\n\n### 3、性能分析\n\n#### （1）MySQL Query Optimizer\n\n![image-20200820164306500](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODIwMTY0MzA2LnBuZw?x-oss-process=image/format,png)\n\n#### （2）MySQL常见瓶颈\n\n##### a. CPU\n\nCPU饱和的时候，一般发生在数据装入内存或从磁盘中读取数据的时候\n\n##### b. IO\n\n实例内存满足不了缓存数据或排序等需要，导致产生大量 物理 IO\n查询执行效率低，扫描过多数据行\n\n##### c. 服务器\n\n服务器的性能瓶颈，可以使用top、free、iostat和vmstat来查看系统的性能状态\n\n#### （3）EXPLAIN 的使用\n\n> 概念\n\n使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈\n\n用法： Explain+SQL 语句\n\nExplain 执行后返回的信息：\n\n![image-20200731143742855](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwNzMxMTQzNzQyLnBuZw?x-oss-process=image/format,png)\n\n> Explain的作用\n\n表的读取顺序（id）\n哪些索引可以使用（select_type）\n数据读取操作的操作类型（possible_key）\n哪些索引被实际使用(key)\n表之间的引用\n每张表有多少行被优化器查询（rows）\n\n##### a. id\n\nselect 查询的序列号，包含一组数字，表示查询中执行 select 子句或操作表的顺序\n\n①id 相同，执行顺序由上至下\n\n![image-20200731144145586](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwNzMxMTQ0MTQ1LnBuZw?x-oss-process=image/format,png)\n\n注意此图中是t1、t3、t2\n\n②id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行\n\n![image-20200731144624316](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwNzMxMTQ0NjI0LnBuZw?x-oss-process=image/format,png)\n\n③有相同也有不同\n\n![image-20200731144705788](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwNzMxMTQ0NzA1LnBuZw?x-oss-process=image/format,png)\n\nid 如果相同，可以认为是一组，从上往下顺序执行；在所有组中， id 值越大，优先级越高，越先执行\n\n衍生 = DERIVED（临时表）\n\n关注点：id 号每个号码，表示一趟独立的查询。一个 sql 的查询趟数越少越好\n\n##### b. select_type\n\nselect_type 代表查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询\n\n| select_type 属性     | 含义                                                         |\n| -------------------- | ------------------------------------------------------------ |\n| SIMPLE               | 简单的 select 查询，查询中不包含子查询或者 UNION（简单的单表查询） |\n| PRIMARY              | 查询中若包含任何复杂的子部分，最外层查询则被标记为 Primary   |\n| DERIVED              | 在 FROM 列表中包含的子查询被标记为 DERIVED(衍生)<br>MySQL 会递归执行这些子查询， 把结果放在临时表里 |\n| SUBQUERY             | 在SELECT或WHERE列表中包含了子查询                            |\n| DEPEDENT SUBQUERY    | 在 SELECT 或 WHERE 列表中包含了子查询，子查询基于外层<br>都是 where 后面的条件，subquery 查询出来的是单个值，dependentsubquery 是一组值 |\n| UNCACHEABLE SUBQUREY | 使用了@@来引用系统变量的子查询，当使用了@@来引用系统变量的时候，不会使用缓存 |\n| UNION                | 若第二个 SELECT 出现在 UNION 之后，则被标记为 UNION；若 UNION 包含在 FROM 子句的子查询中，外层 SELECT 将被标记为：DERIVED。 |\n| UNION RESULT         | 从 UNION 表获取结果的 SELECT                                 |\n\n##### c. table\n\n这个数据是基于哪张表的\n\n##### d. type\n\ntype是查询的访问类型。是较为重要的一个指标，结果值从最好到最坏一次是：\n\n> system>const>eq_ref>ref>fulltext>ref_or_null>index_merge>unique_subquery>index_subquery>range>index>ALL\n\n一般来说，得保证查询至少达到 range 级别，最好能达到 ref\n\nALL表示全表扫描，所以结果值最差\n\n上面的比较关系比较难记，工作中常用的如下：\n\n> system>const>eq_ref>ref>range>index>ALL\n\n**（1）system**\n\n表只有一行记录（等于系统表） ，这是 const 类型的特列，平时不会出现，这个也可以忽略不计，实际系统中几乎不可能出现\n\n**（2）const**\n表示通过索引一次就找到了，const 用于比较 primarykey 或者 unique 索引。因为只匹配一行数据，所以很快\n\n因为where中查询条件为t1.id=1，所以该查询类型为const\n\n又因为这样查询出来的记录只有一条，所以上级查询为system\n\n![image-20200801184702595](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODAxMTg0NzAyLnBuZw?x-oss-process=image/format,png)\n\n**（4）eq_ref**\n\n唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。\n\n![image-20200801185415187](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODAxMTg1NDE1LnBuZw?x-oss-process=image/format,png)\n\n**（5）ref**\n\n非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。\n\n* 没用索引前：\n\n![image-20200801185525467](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODAxMTg1NTI1LnBuZw?x-oss-process=image/format,png)\n\n* 建立索引后：\n\n![image-20200801185546633](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODAxMTg1NTQ2LnBuZw?x-oss-process=image/format,png)\n\n**（6）range**\n\n只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引一般就是在你的 where 语句中出现 了 between、<、>、in 等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引\n\n![image-20200801185701967](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODAxMTg1NzAyLnBuZw?x-oss-process=image/format,png)\n\n**（7）index**\n\n出现index是sql使用了索引但是没有通过索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组\n\n![image-20200801185729063](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODAxMTg1NzI5LnBuZw?x-oss-process=image/format,png)\n\n**（8）all**\n\nFullTableScan，将遍历**全表**以找到匹配的行\n\n![image-20200801185802368](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODAxMTg1ODAyLnBuZw?x-oss-process=image/format,png)\n\n##### e. possible_keys\n\n显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用\n\n如果该值为NULL，则表示未使用到索引\n\n##### f. key\n\n实际使用的索引。如果为NULL，则没有使用索引\n\n##### g. key_len\n\n表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。 key_len 字段能够帮你检查是否充分的利用上了索引。ken_len 越长，说明索引使用的越充分\n\n**如何计算：**\n\n①先看索引上字段的类型+长度比如 int=4; varchar(20)=20;char(20)=20\n\n②如果是 varchar 或者 char 这种字符串字段，视字符集要乘不同的值，比如 utf-8 要乘 3，GBK 要乘 2\n\n③varchar 这种动态字符串要加 2 个字节 \n\n④允许为空的字段要加 1 个字节 \n\n第一组：key_len=age 的字节长度+name 的字节长度=4+1 +(20*3+2)=5+62=67\n\n第二组：key_len=age 的字节长度=4+1=5\n\n![image-20200801190921142](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODAxMTkwOTIxLnBuZw?x-oss-process=image/format,png)\n\n##### h. ref\n\n显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值\n\n![image-20200801191402036](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODAxMTkxNDAyLnBuZw?x-oss-process=image/format,png)\n\n##### i. row\n\nrows 列显示 MySQL 认为它执行查询时必须检查的行数，越少越好！\n\n##### j. Extra\n\n其他的额外重要的信息\n\n* **Usingfilesort**：说明 mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL 中无法利用索引完成的排序操作称为“文件排序”\n\n* **Using temporary**：使用了临时表来保存中间结果，MySQL在对查询结果排序时使用临时表，常见于排序 order by或者分组 group by\n  * **Using index**： 代表表示相应的 select 操作中使用了覆盖索引(CoveringIndex)，避免访问了表的数据行，效率不错！ 如果同时出现 using where，表明索引被用来执行索引键值的查找；如果没有同时出现 using where，表明索引只是用来读取数据而非利用索引执行查找。\n* **Using where**：表明使用了 where 过滤\n* **Using joinbuffer：**使用了连接缓存（select * from emp,dept where emp.id=dept.id)\n* **impossible where**：where 子句的值总是 false，不能用来获取任何元组\n* **select tables optimized away**：在没有 GROUPBY 子句的情况下，基于索引优化 MIN/MAX 操作或者对于 MyISAM 存储引擎优化 COUNT(*)操\n  作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。**myisam已经保存了记录的总数，直接返回结果，不需要再进行select查询，而innodb还需要全表扫描**\n\n#### （4）热身案例\n\n![image-20200820165303222](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODIwMTY1MzAzLnBuZw?x-oss-process=image/format,png)\n\n### 4、索引失效\n\n#### （1）全值匹配\n\n建立索引\n\n```\nCREATE INDEX idx_age_deptid_name ON emp(age,deptid,NAME);\n```\n\n进行查询，分别使用1、2、3个索引，查看情况\n\n![image-20200803104141518](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODAzMTA0MTQxLnBuZw?x-oss-process=image/format,png)\n\n结论：需要查询的字段和建立的索引越匹配，精度越高，全值匹配查询的字段按照顺序在索引中都可以匹配到\n\n#### （2）最佳左前缀法则\n\n查询字段与索引字段顺序的不同会导致，索引无法充分使用，甚至索引失效！\n\n原因：使用复合索引，需要遵循最佳左前缀法则，即如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。\n\n**结论：过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用**\n\n![image-20200803104605017](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODAzMTA0NjA1LnBuZw?x-oss-process=image/format,png)\n\n#### （3）不要在索引列上做任何计算\n\n不在索引列上做任何操作（计算、函数、(自动 or 手动)类型转换） ，会导致索引失效而转向全表扫描。\n\n（1）在查询列上使用了函数\n\n![image-20200803110243254](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODAzMTEwMjQzLnBuZw?x-oss-process=image/format,png)\n\n（2）在查询列上做了转换 \n\n虽然都能查询出结果，因为Mysql自动做了隐式类型转换，但是字符串不加单引号索引失效\n\n![image-20200803114904209](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODAzMTE0OTA0LnBuZw?x-oss-process=image/format,png)\n\n#### （4）索引列上不能有范围查询\n\n![image-20200803110539380](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODAzMTEwNTM5LnBuZw?x-oss-process=image/format,png)\n\n解决方案：将可能做范围查询的字段的索引顺序放在最后\n\n#### （5）尽量使用覆盖索引\n\n即查询列和索引列一直，不要写 select * !\n\n![image-20200803111018498](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODAzMTExMDE4LnBuZw?x-oss-process=image/format,png)\n\n#### （6）使用不等于(!= 或者<>)的时候\n\nmysql 在使用不等于(!= 或者<>)时，有时会无法使用索引会导致全表扫描\n\n![image-20200803111055235](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODAzMTExMDU1LnBuZw?x-oss-process=image/format,png)\n\n#### （7）字段的is not null 和 is null\n\n![image-20200803111118245](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODAzMTExMTE4LnBuZw?x-oss-process=image/format,png)\n\n![image-20200803111708585](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODAzMTExNzA4LnBuZw?x-oss-process=image/format,png)\n\nisnotnull 用不到索引，isnull 可以用到索引\n\n#### （8）like的前后模糊匹配\n\n前缀不能出现模糊匹配\n\n![image-20200803111813716](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODAzMTExODEzLnBuZw?x-oss-process=image/format,png)\n\n> 如何解决%在前缀的时候导致的索引失效？\n\n使用覆盖索引，即建的索引和查询的字段尽量一致\n\n#### （9）减少使用or\n\n![image-20200803111850277](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODAzMTExODUwLnBuZw?x-oss-process=image/format,png)\n\n使用 union all 或者 union 来替代：\n\n![image-20200803112008501](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODAzMTEyMDA4LnBuZw?x-oss-process=image/format,png)\n\n#### （10）字符串不加单引号索引失效\n\n底层进行转换使索引失效，使用了函数造成索引失效\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODIwMTY1ODA0LnBuZw?x-oss-process=image/format,png)\n例如：\nselect * from staffs where name=‘2000’\nselect * from staffs where name=2000\nmysql都能查出来，mysql引擎会自动做类型转换，但是索引会失效\n\n#### （11）结论\n\n全职匹配我最爱，最左前缀要遵守；\n\n带头大哥不能死，中间兄弟不能断；\n\n索引列上少计算，范围之后全失效；\n\nLIKE 百分写最右，覆盖索引不写*； \n\n不等空值还有 OR，索引影响要注意； \n\nVAR 引号不可丢，SQL 优化有诀窍。\n","tags":["索引优化"],"categories":["MySQL"]},{"title":"MySQL高级篇笔记（一）MySQL存储引擎","url":"/MySQL/MySQL高级篇笔记（一）MySQL存储引擎","content":"\n## 一、存储引擎介绍\n### 1、MyISAM\nMyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM 不支持事务和行级锁(MyISAM改表时会将整个表全锁住) ，有一个毫无疑问的缺陷就是崩溃后无法安全恢复\nMyISAM管理非事务表，所以关注点在于性能上，可以提供高速存储和检索，支持全文搜索\n\n> 那么为什么MyISAM会比InnoDB快呢？\t[待做]\n\n### 2、InnoDB\nInnoDB是MySQL的默认事务型引擎 ，它被设计用来处理大量的短期(short-lived)事务。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。\nInnoDB支持事务，支持主键和外键，支持提交、回滚和紧急恢复功能来保护数据，它还支持行锁\n\n> 阿里巴巴、淘宝用什么引擎呢？\n\n![image-20200804110259010](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwODA0MTEwMjU5LnBuZw?x-oss-process=image/format,png)\n### 3、两种存储引擎的对比\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly96aGVuZ2hhb3l1bi5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vaW1nLzIwMjAwNzI5MTU1ODE3LnBuZw?x-oss-process=image/format,png)\nInnodb的索引使用 B+Tree，MyISAM索引使用B-Tree\nInnodb主键为聚簇索引，基于聚簇索引的增删改查效率非常高","tags":["MySQL存储引擎"],"categories":["MySQL"]},{"title":"JVM（一）内存与垃圾回收篇","url":"/JVM/JVM（一）内存与垃圾回收篇","content":"\nJVM的学习笔记分为四个篇章：\n\n1. JVM（一）内存与垃圾回收篇\n2. JVM（二）字节码与类的加载篇\n3. JVM（三）性能监控与调优篇\n4. JVM（四）大厂面试篇\n\n学习视频来源：尚硅谷宋红康JVM教程\n\n本篇为JVM（一）内存与垃圾回收篇\n\n<!--more-->\n\n# 一、JVM体系结构\n\n先来了解两个概念，**字节码**和**多语言混合编程**。\n\n## 1. 字节码\n\n我们平时所说的java字节码是指用java语言编译成的字节码。**准确的说任何能在jvm平台上执行的字节码格式都是一样的**。所以应该统称为：**jvm字节码**。\n\n不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。\n\n## 2. 多语言混合编程\n\nJava平台上的多语言混合编程正成为主流。\n\n如一个项目：\n\n* 并行处理使用Cloujure\n* 展示层使用JRuby/Rails\n* 中间层则是Java\n\n每个应用层都将使用不同的编程语言来完成。\n\n**原因：**因为各种语言最终都运行在一个虚拟机上，所以各种语言之间的交互不存在任何困难，就像使用自己语言原生的API一样方便。\n\n## 3. 虚拟机与Java虚拟机\n\n>  在了解Java虚拟机前，你是否懂得虚拟机是什么？\n\n所谓虚拟机，就是一台虚拟计算机。它是一款**软件**，用来执行一些列虚拟计算机指令。\n\n可以分为：\n\n* 系统虚拟机，如**VMware**就属于系统虚拟机，它完全是对物理计算机的仿真。\n* 程序虚拟机，如**Java虚拟机**，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。\n\n> 了解了虚拟机，继续了解Java虚拟机。\n\nJVM是Java Virtual Machine（Java虚拟机）的缩写，用来执行**Java字节码**。Java字节码又可以成为JVM字节码，引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。\n\n**作用**\n\nJava虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。\n\n**特点**\n\n1. 一次编译，到处运行。\n2. 自动内存管理\n3. 自动垃圾回收功能\n\n## 4. JVM的位置\n\n![Image](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200601160809.png)\n\n\n\n从图中可以看出JVM没有和硬件打交道，它是运行在操作系统之上的。\n\n## 5. JVM的整体结构\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200601161251.jpg)\n\n<center>JVM整体架构图</center>\n\n以上这个图为JVM整体架构图，之后的学习就是按照这个图来。\n\n**补充：**\n\n* Java栈是以前的叫法，现在叫做虚拟机栈。\n* 方法区和堆是多线程共享的，Java堆、本地方法栈、程序计数器是每个线程独享的。\n* 执行引擎的作用：操作系统只能识别机器指令，不能识别字节码指令，所以执行引擎的作用是翻译字节码指令。\n\n<img src=\"https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200601162424.png\" alt=\"image-20200601162422306\" style=\"zoom:50%;\" />\n\n<center>JVM架构详细图</center>\n\n## 6. JVM的架构模型\n\nJava编译器输入的指令基本上是一种基于**栈的指令集架构**，另外一种指令架构则是基于**寄存器的指令集架构。**\n这两种架构之间的区别：\n\n* 栈式架构\n  * 设计和实现简单\n  * 使用零地址指令方式分配（没有地址，只有操作数）从而避开了寄存器的分配难题，因为是采用栈式的，永远只对栈顶进行操作，所有是不需要地址的。\n  * 指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器更容易实现。\n  * 不需要硬件支持，**可移植性更好**，更好实现跨平台。\n* 寄存器架构\n  * 典型的是x86的二进制指令集完全依赖硬件（指令要有CPU来执行），**可移植性差**。\n  * 性能优秀、执行更高效\n  * 栈式架构指令集小，但是指令多；寄存器架构指令集大，但是指令少。所以能够花费更好的指令去完成一项操作。\n  * 大部分情况下，寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主。\n\n**总结**：\n\n* 由于跨平台性的设计，Java的指令都是根据栈来设计的。不同的平台CPU架构不同，所以不能设计基于寄存器的。  \n* 栈式架构：跨平台、指令集小、指令多；执行性能比寄存器差。\n\n**实例：**\n\n```java\n// 这是三条java指令\nint i = 3;\nint j = 2;\nint k = i + j;\n\n//基于栈的计算流程，翻译成java字节码指令后，变成了8条。\n0 iconst_3\n1 istore_1\n2 iconst_2\n3 istore_2\n4 iload_1\n5 iload_2\n6 iadd\n7 istore_3\n8 return\n\n//而基于寄存器的计算流程，只有2条指令。\nmov eax,2\t//将eax寄存器的值设为2\nadd eax,3\t//将eax寄存器的值加3\n```\n\n## 7. JVM的生命周期\n\n**虚拟机的启动**\n\nJava虚拟机的启动是通过引导类加载器（ bootstrap class loader）创建一个初始类（initial class）来完成的，这个类的名称我们不清楚，这个类是由虚拟机的具体实现指定的。\n\n比如说你想要吃苹果，但是你没有苹果树，所以我们先种一棵苹果树，这个苹果树就是JVM。\n\n**虚拟机的执行**\n\n一个运行中的虚拟机有着清晰的任务，那就是执行Java代码。\n\n 程序开始执行时他才开始运行，程序结束时他就停止。执行一个Java程序的时候，真真正正执行的是一个叫做Java虚拟机的进程。\n\n**虚拟机的退出**\n\n有以下几种情况会导致虚拟机退出：\n\n1. 程序正常执行结束\n2. 遇到异常或者错误\n3. 操作系统错误导致Java虚拟机进程异常终止\n4. 调用System的exit方法或者Runtime类的halt方法，并且Java安全管理器也允许这次exit或者halt操作。\n\n# 二、类加载子系统\n\n## 1. 内存结构概述\n\n<img src=\"https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200601213922.png\" alt=\"image-20200601213921809\" style=\"zoom:50%;\" />\n\n再来看看这张JVM架构细节图。通过这种图我们可以大概了解JVM的内存结构。\n\n## 2. 类加载子系统的作用\n\n<img src=\"https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200601214118.png\" alt=\"image-20200601214117793\" style=\"zoom：80%;\" />\n\n1. 类加载子系统负责从文件系统或 网络中加载clss文件，class文件在文件开头有特定的文件标识（CAFEBABE（咖啡宝贝？），后面会提到）。\n2. ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。\n3. 加载的类信息被存放于一块称为方法区的内存空间中，字节码文件是物理磁盘上的一个文件，类的加载器将字节码文件加载到内存中，生成Class的实例。\n4. 除了类的本身信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）\n\n## 3. 类加载器ClassLoader角色\n\n![Image](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200603164236.png)\n\n* getClassLoader()获取加载去\n* Car Class调用构造器进行实例化，实例化出car1、car2、car3\n\n## 4. 类的加载过程\n\n<img src=\"https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200603164519.png\" alt=\"image-20200603164515825\" style=\"zoom:50%;\" />\n\nHelloLoader是一个类，目的是调用main()方法。\n\n1. 要想调用main方法，首先检测HelloLoader是否装载，如果没有装载，就使用ClassLoader进行装载。\n2. 装载成功，生成对应的字节码文件HelloLoader.class\n3. 链接\n4. 初始化\n5. 调用main()\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200603172437.png)\n\n<center>类加载过程图</center>\n\n这个图是类的加载总过程，其中也有个加载，不过这个加载是类的加载过程中的一个“加载”过程，注意不要混淆。\n\n接下来来讲讲具体的过程\n\n### （1）加载\n\n![Image](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200603172514.png)\n\n**补充：加载.class的方式**\n\n* 从本地系统中加载\n* 网络获取，如：Web Applet\n* zip压缩包读取\n* 运行时计算生成，如：动态代理\n* 由其他文件生成，如：JSP\n* 从专有数据库提取，比较少见\n* 从加密文件中获取，反编译的保护措施\n\n### （2）链接\n\n![Image](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200603215648.png)\n\n**验证**\n\n检查class文件的头部是否有`cafebaby`的标识等等，用特定的软件可以看见。\n\n**准备**\n\n1. 为类变量赋值为0或者其他初值，再后来的**初始化**阶段再赋值为自定义的值。\n2. final修饰的static直接被赋值为我们自定义的值，也就是显示初始化。\n3. 实例变量不会初始化\n\n**解析**\n\n1. 符号引用 转化为 直接引用\n2. 直接引用就是直接指向目标的指针\n3. 在这里简要的阐述，后面会详细学习。\n4. 往往**初始化**之后执行\n\n### （3）初始化\n\n![Image](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200603220717.png)\n\n**补充说明：**\n\n1. clinit()是类的构造器方法，它会完成所有类变量的赋值动作和执行静态代码块。\n\n<img src=\"https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200603222050.png\" alt=\"image-20200603222050037\" style=\"zoom：67%;\" />\n\n2. 如果没有静态变量和静态代码块，就不会有clinit方法。\n3. 注意到还有个\\<init\\>，这个是我们自己定义的构造器方法，如`public Customer(){}`\n4. 任何一个类都有对应的\\<init\\>\n\n## 5. 类加载器的分类\n\n### （1）分类\n\n1. JVM支持两种类型的加载器，分别为**引导类加载器C/C++实现（BootStrap ClassLoader）和自定义类加载器由Java实现**\n\n2. 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是java虚拟机规范却没有这么定义，而是**将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器**。\n\n![Image](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604121847.png)\n\n3. 上面的蓝色框内为引导类加载器，下面的蓝色框内皆为自定义类加载器。查看源码可以看到ExtClassLoader和AppClassLoader都派生于ClassLoader，所以他们都是自定义类加载器。\n4. 注意上图中的加载器划分关系为包含关系，并不是继承关系。\n\n**代码具体实践**\n\n```java\n/**\n * ClassLoader加载\n */\npublic class ClassLoaderTest {\n    public static void main(String[] args) {\n        //获取系统类加载器\n        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\n        System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2\n\n        //获取其上层  扩展类加载器\n        ClassLoader extClassLoader = systemClassLoader.getParent();\n        System.out.println(extClassLoader);//sun.misc.Launcher$ExtClassLoader@610455d6\n\n        //获取其上层 获取不到引导类加载器\n        ClassLoader bootStrapClassLoader = extClassLoader.getParent();\n        System.out.println(bootStrapClassLoader);//null\n\n        //对于用户自定义类来说：使用系统类加载器进行加载\n        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();\n        System.out.println(classLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2\n\n        //String 类使用引导类加载器进行加载的  -->java核心类库都是使用引导类加载器加载的\n        ClassLoader classLoader1 = String.class.getClassLoader();\n        System.out.println(classLoader1);//null获取不到间接证明了String 类使用引导类加载器进行加载的\n\n    }\n}\n```\n\n通过上面代码我们发现个问题：获取引导类加载器返回的都是null！\n\n原因是：这个类加载使用**C/C++语言实现的**，嵌套在JVM内部，所以我们是获取不到它的对象的。\n\n### （2）虚拟机自带的加载器\n\n**启动类加载器（引导类加载器，BootStrap ClassLoader）**\n\n1.这个类加载使用**C/C++语言实现的**，嵌套在JVM内部\n\n2.它用来加载java的核心库（JAVA_HOME/jre/lib/rt.jar/resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类\n\n3.并不继承自java.lang.ClassLoader,没有父加载器\n\n4.加载拓展类和应用程序类加载器，并指定为他们的父加载器，即ClassLoader\n\n5.出于安全考虑，BootStrap启动类加载器只加载包名为java、javax、sun等开头的类（即只加载核心内库）\n\n**拓展类加载器（Extension ClassLoader）**\n\n1.**java语言**编写 ，由sun.misc.Launcher$ExtClassLoader实现。\n\n2.派生于ClassLoader类\n\n3.从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。**如果用户创建的JAR放在此目录下，也会由拓展类加载器自动加载**\n\n**应用程序类加载器（系统类加载器，AppClassLoader）**\n\n1. java语言编写， 由sun.misc.Launcher$AppClassLoader实现。\n\n2. 派生于ClassLoader类\n3. 它的父类加载器是扩展类加载器\n\n4. 它负责加载环境变量classpath或系统属性 java.class.path指定路径下的类库\n\n5. 该类加载器是程序中默认的类加载器，一般来说，java应用的类都是由它来完成加载\n\n6. 通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器\n\n**代码演示**\n\n```java\n/**\n * 虚拟机自带加载器\n */\npublic class ClassLoaderTest1 {\n    public static void main(String[] args) {\n        System.out.println(\"********启动类加载器*********\");\n        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();\n        //获取BootStrapClassLoader能够加载的api路径\n        for (URL e:urls){\n            System.out.println(e.toExternalForm());\n        }\n\n        //从上面的路径中随意选择一个类 看看他的类加载器是什么\n        //Provider位于 /jdk1.8.0_171.jdk/Contents/Home/jre/lib/jsse.jar 下，引导类加载器加载它\n        ClassLoader classLoader = Provider.class.getClassLoader();\n        System.out.println(classLoader);//null\n\n        System.out.println(\"********拓展类加载器********\");\n        String extDirs = System.getProperty(\"java.ext.dirs\");\n        for (String path ：extDirs.split(\";\")){\n            System.out.println(path);\n        }\n        //从上面的路径中随意选择一个类 看看他的类加载器是什么:拓展类加载器\n        ClassLoader classLoader1 = CurveDB.class.getClassLoader();\n        System.out.println(classLoader1);//sun.misc.Launcher$ExtClassLoader@4dc63996\n    }\n}\n```\n\n知识扩展：启动类加载器BootStrapClassLoader能够加载的api路径有\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604221415.png)\n\n最近看java.util.concurrent包的内容，发现java.time.*、java.util.*、java.nio.*、java.lang.*、java.text.*、java.sql.*、java.math.*等等都在rt.jar包下。\n\n### （3）用户自定义类加载器\n\n> 为什么要自定义类加载器\n\n1. 隔离加载类（有些类的路径名、类名都是一样的，避免类冲突，许多框架都会自定义类加载器）\n\n2. 修改类加载的方式\n\n3. 拓展加载源\n\n4. 防止源码泄漏\n\n> 怎么去自定义类加载器呢？\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604221442.png)\n\n### （4）关于ClassLoader\n\nClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）\n\n**ClassLoader的常用方法**\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604221757.png)\n\n其中有一个是loadClass，一个是findClass。调用了findClass()后再调用defineClass()的效果等效于直接调用loadClass()。\n\n**如何获取ClassLoader**\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604222006.png)\n\n**代码示例**\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604222021.png)\n\n## 6. 双亲委派机制\n\n### （1）原理\n\nJava虚拟机加载某个类的Class文件时，采用的是**双亲委派机制。**那么什么是双亲委派机制呢？也就是把请求交给父类去处理，父类再交给父类的父类处理，以此类推，直至没有父类为止。\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604222410.png)\n\n举一个很形象的例子：当桌子上有一个苹果的时候，出于礼仪，儿子会问妈妈要不要吃苹果，妈妈又会问奶奶要不要吃苹果，如果奶奶要吃，那这个苹果就给奶奶吃了。如果奶奶不吃，妈妈再决定吃不吃这个苹果，依次类推。\n\n### （2）双亲委派机制示例\n\n#### 保护程序安全\n\n如图，虽然我们自定义了一个java.lang包下的String尝试覆盖核心类库中的String，但是由于双亲委派机制，启动加载器会加载java核心类库的String类（BootStrap启动类加载器只加载包名为java、javax、sun等开头的类），而核心类库中的String并没有main方法\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604223048.png)\n\n#### 双亲委派机制在SPI中的应用\n\n1.某个应用程序由双亲委派机制找到引导类加载器，首先调用rt.jar包中的SPI核心，但由于SPI核心当中有各种各样的接口需要被实现（这里指具体的服务提供商），这里我们已JDBC.jar为例，jdbc.jar可以为我们提供具体的实现。\n\n2.那么这时我们需要反向委托，找到线程上下文类加载器去加载jdbc.jar\n\n3.线程上下文类加载器属于系统类加载器\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604223146.png)\n\n### （3）双亲委派机制的优势\n\n1.避免类的重复加载，如上面String类的例子。\n\n2.保护程序安全，防止核心API被随意修改\n\n启动类加载器可以抢在标准扩展类装载器之前去装载类，而标准扩展类装载器可以抢在类路径加载器之前去装载那个类，类路径装载器又可以抢在自定义类加载器之前去加载它。所以Java虚拟机先从最可信的Java核心API查找类型，这是为了防止不可靠的类扮演被信任的类，试想一 下，网络上有个名叫java.lang.Integer的类，它是某个黑客为了想混进java.lang包所起的名字，实际上里面含有恶意代码，但是这种伎俩在双亲模式加载体系结构下是行不通的，因为类加载器在加载它的时候，它首先启用双亲委派机制，这样一直向上委托，直到启动类加载器，而启动类加载器在java.lang（jdk中的核心库）包里发现了这个名字的类，所以它就直接加载java.lang的Integer类，然后将这个类返回，所以自始至终我们伪装的 java.lang.Integer的类是不会被加载的。\n\n3.保证核心API包的访问权限\n\n但是如果这个移动代码不是去试图替换一个被信任的类（就是前面说的那种情况），而是想在一个被信任的包中插入一个全新的类型，情况会怎样呢？比如我们自己定义个一个名为 java.lang.Virus的类，试图将它伪装到java核心库里面的java.lang包下，但是执行main()方法的时候，却报错了，提示没有访问权限，试想如果成功了，我们是不是可以去破坏引导类加载器。\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604223837.png)\n\n## 7. 沙箱安全机制\n\n![Image](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604224001.png)\n\n## 8. 类的主动使用与被动使用\n\n**java程序对类的使用方式分为：主动使用和被动使用，即是否调用了clinit()方法**\n\n主动使用在类加载系统中的第三阶段initialization即初始化阶段调用了clinit()方法\n\n而被动使用不会去调用\n\n主动使用，分为七种情况\n\n1. 创建类的实例\n\n2. 访问某各类或接口的静态变量，或者对静态变量赋值\n\n3. 调用类的静态方法\n\n4. 反射 比如Class.forName(com.dsh.jvm.xxx)\n\n5. 初始化一个类的子类\n\n6. java虚拟机启动时被标明为启动类的类\n\n7. JDK 7 开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化\n\n除了以上七种情况，其他使用java类的方式都被看作是对**类的被动使用，都不会导致类的初始化。**\n\n## 9. 其他\n\n1.在jvm中表示两个class对象是否为同一个类存在的两个必要条件\n\n类的完整类名必须一致，包括包名\n\n即使类的完整类名一致，同时要求加载这个类的ClassLoader（指ClassLoader实例对象）必须相同；是引导类加载器、还是定义类加载器\n\n2.换句话说，在jvm中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的.\n\n3.对类加载器的引用，JVM必须知道一个类型是有启动类加载器加载的还是由用户类加载器加载的。如果一个类型由用户类加载器加载的，那么jvm会**将这个类加载器的一个引用作为类型信息的一部分保存在方法区中**。当解析一个类型到另一个类型的引用的时候，JVM需要保证两个类型的加载器是相同的。\n\n# 三、运行时数据区\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604225107.png)\n\n运行时数据区就是蓝色框内的内容，接下来开始这部分的学习。内存是非常重要的系统资源，是硬盘和cpu的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了JAVA在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。**不同的jvm对于内存的划分方式和管理机制存在着部分差异**（对于Hotspot主要指方法区）\n\nJDK8的**元数据区+JIT编译产物** 就是JDK8以前的**方法区**\n\n> JavaAPI中的Runtime\n\n```java\npublic class Runtime extends Object\n```\n\nEvery Java application has a single instance of class Runtime that allows the application to interface with theenvironment in which the application is running. The current runtime can be obtained from the getRuntime method.\n\n每个Java应用程序都有一个Runtime类的实例，该实例允许该应用程序与运行该应用程序的环境进行交互。 当前运行时可以从getRuntime方法获得。\n\n## 1. Java内存分区介绍\n\njava虚拟机定了了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604225307.png)\n\n如图，灰色的区域为单独线程私有的，红色的为多个线程共享的。\n\n> Java中的线程与进程\n\n1. 每个线程：独立包括程序计数器、栈、本地栈\n\n2. 线程间共享：堆、堆外内存（方法区、永久代或元空间、代码缓存）\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200604225618.png)\n\n图片说明：严格对照Java内存分区\n\nPC即程序计数器\n\nVMS即虚拟机栈\n\nNMS即本地方法栈\n\n一般来说，jvm优化95%是优化堆区，5%优化的是方法区，至于栈区无非出入栈操作所以优化较少\n\n**线程**\n\n1.线程是一个程序里的运行单元，JVM允许一个程序有多个线程并行的执行；\n\n2.在HotSpot JVM，每个线程都与操作系统的本地线程直接映射。\n\n* 当一个java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。java线程执行终止后。本地线程也会回收。\n\n3.操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用java线程中的run（）方法。\n\n**JVM系统线程分类**\n\n如果你使用jconsole或者任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用main方法的main线程以及所有这个main线程自己创建的线程；\n\n这些主要的后台系统线程在HotSpot JVM里主要是以下几个（了解）：\n\n1.虚拟机线程：这种线程的操作时需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行包括“stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销\n\n2.周期任务线程：这种线程是时间周期事件的提现（比如中断），他们一般用于周期性操作的调度执行。\n\n3.GC线程：这种线程对于JVM里不同种类的垃圾收集行为提供了支持\n\n4.编译线程：这种线程在运行时会降字节码编译成本地代码\n\n5.信号调度线程：这种线程接收信号并发送给JVM,在它内部通过调用适当的方法进行处理。\n\n## 2. 程序计数器\n\nJVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。\n\n一个线程对应一个 JVM Stack。JVM Stack 中包含一组 Stack Frame。当 JVM 调用一个 Java 方法时，它从对应类的类型信息中得到此方法的局部变量区和操作数栈的大小，并据此分配栈帧内存，然后压入 JVM 栈中。\n\n在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法。\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200605105745.png)\n\n### （1）作用\n\nPC寄存器是用来存储指向下一条指令的地址，也即将将要执行的指令代码。由执行引擎读取下一条指令。\n\n1. 它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域\n\n2. 在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致\n\n3. 任何时间一个线程都只有一个方法在执行，也就是所谓的**当前方法**。程序计数器会存储当前线程正在执行的java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefined）,因为程序计数器不负责本地方法栈。\n\n4. 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成\n\n5. 字节码解释器工作时就是通过改变这个计数器的值来选取下一跳需要执行的字节码指令\n\n6. 它是唯一一个在java虚拟机规范中**没有规定任何OOM（Out Of Memery）情况**的区域,而且没有垃圾回收\n\n### （2）举例说明\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200605114858.png)\n\n如图，数字是指令偏移地址，指令后面的#2、#3啊等等是常量池的地址。如#2对应的就是常量池的String abc，#3对应的PrintStream。\n\n### （3）相关问题\n\n>  使用PC寄存器存储字节码指令地址有什么用呢（为什么使用PC寄存器记录当前线程的执行地址呢）\n\n（1）多线程宏观上是并行（多个事件在同一时刻同时发生）的，但实际上是并发交替执行的\n\n（2）因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行\n\n（3）JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令\n\n> PC寄存器为什么会设定为线程私有？\n\n（1）众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。\n\n（2）为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是**为每一个线程都分配一个PC寄存器,**这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。\n\n## 3. 虚拟机栈\n\n### （1）虚拟机背景\n\n由于跨平台性的设计，java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。\n根据栈设计的**优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。**\n\n> 内存中的堆与栈\n>\n> ![Image](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200605173935.png)\n>\n> 1.栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿。\n>\n> 2.一般来讲，对象主要都是放在堆空间的，是运行时数据区比较大的一块\n>\n> 3.栈空间存放基本数据类型的局部变量，以及引用数据类型的对象的引用\n>\n> 总结为：**栈是运行时的单位，而堆是存储的单位。**\n>\n> 这句话的意思即栈解决程序的运行问题，即程序如何执行或者说如何处理数据。而堆解决的是数据存储的问题，即数据怎么放、放在哪儿。\n\n### （2）虚拟机栈基本内容\n\n>  Java虚拟机栈是什么\n\njava虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。 每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应这个一次次的java方法调用。它是线程私有的。\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200605174503.png)\n\n>  虚拟机栈的作用\n\n主管java程序的运行，它保存方法的局部变量、8种基本数据类型、对象的引用地址、部分结果，并参与方法的调用和返回。\n\n**优点：**\n\n1.速度快，仅次于程序计数器。 \n\n2.操作简单：出栈、入栈。  \n\n3.不存在垃圾回收问题，但是栈存在OOM。（因为出栈入栈就可了，栈溢出的时候就直接挂掉了）\n\n>  栈中可能出现的异常\n\n**StackOverFlowError**与**OutOfMemoryError**！\n\njava虚拟机规范允许**Java栈的大小是动态的或者是固定不变的**\n\n如果采用固定大小的Java虚拟机栈，那每一个线程的java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量，java虚拟机将会抛出一个 **StackOverFlowError**异常。\n\n```java\n/**\n * 演示栈中的异常\n */\npublic class StackErrorTest {\n    public static void main(String[] args) {\n        main(args);\n    }\n}\n```\n\n\n\n如果java虚拟机栈可以动态拓展，并且在尝试拓展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那java虚拟机将会抛出一个 **OutOfMemoryError异常。**\n\n### （3）设置栈的内存大小\n\n我们可以使用参数-Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。 （IDEA设置方法：Run-EditConfigurations-VM options 填入指定栈的大小-Xss256k）\n\n```java\n/**\n * 演示栈中的异常\n *\n * 默认情况下：count 10818\n * 设置栈的大小： -Xss256k count 1872\n */\npublic class StackErrorTest {\n    private static int count = 1;\n    public static void main(String[] args) {\n        System.out.println(count);\n        count++;\n        main(args);\n    }\n}\n```\n\n疑问：如果try-catch会怎样？（未解决）\n\n### （4）栈的存储结构和运行原理\n\n1.每个线程都有自己的栈，栈中的数据都是以**栈帧(Stack Frame)**的格式存在\n\n2.在这个线程上正在执行的每个方法都对应各自的一个栈帧\n\n3.栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息\n\n4.JVM直接对java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循先进后出/后进先出的和原则。\n\n5.在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为**当前栈帧(Current Frame)**,与当前栈帧对应的方法就是**当前方法（Current Method）**\n\n6.执行引擎运行的所有字节码指令只针对当前栈帧进行操作\n\n7.如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前栈帧。\n\n8.不同线程中所包含的栈帧是不允许相互引用的，即不可能在另一个栈帧中引用另外一个线程的栈帧\n\n9.如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧\n\n10.Java方法有两种返回函数的方式，**一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。**\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200605180921.png)\n\n**代码演示：**\n\n```java\n/**\n * 栈帧\n */\npublic class StackFrameTest {\n    public static void main(String[] args) {\n        StackFrameTest test = new StackFrameTest();\n        test.method1();\n        //输出 method1（）和method2（）都作为当前栈帧出现了两次，method3（）一次\n//        method1()开始执行。。。\n//        method2()开始执行。。。\n//        method3()开始执行。。。\n//        method3()执行结束。。。\n//        method2()执行结束。。。\n//        method1()执行结束。。。\n    }\n\n    public void method1(){\n        System.out.println(\"method1()开始执行。。。\");\n        method2();\n        System.out.println(\"method1()执行结束。。。\");\n    }\n\n    public int method2(){\n        System.out.println(\"method2()开始执行。。。\");\n        int i = 10;\n        int m = (int) method3();\n        System.out.println(\"method2()执行结束。。。\");\n        return i+m;\n    }\n\n    public double method3(){\n        System.out.println(\"method3()开始执行。。。\");\n        double j = 20.0;\n        System.out.println(\"method3()执行结束。。。\");\n        return j;\n    }\n\n}\n```\n\n### （5）栈帧的内部结构\n\n每个栈帧中存储着\n\n**1.局部变量表**（Local Variables）\n\n**2.操作数栈**（Operand Stack）(或表达式栈)\n\n3.动态链接（Dynamic Linking）(或执行\"运行时常量池\"的方法引用)----深入理解Java多态特性必读！！\n\n4.方法返回地址（Return Adress）（或方法正常退出或者异常退出的定义）\n\n5.一些附加信息\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606144912.png)\n\n其中部分参考书目上，称方法返回地址、动态链接、附加信息为帧数据区。\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606145038.png)\n\n#### 局部变量表\n\n1.局部变量表也被称之为局部变量数组或本地变量表\n\n**2.定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量**这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddressleixing\n\n3.由于局部变量表是建立在线程的栈上，是线程私有的数据，因此不存在数据安全问题\n\n**4.局部变量表所需的容量大小是在编译期确定下来的**,并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的\n\n**5.方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。**对一个函数而言，他的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间。\n\n**6.局部变量表中的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。**当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。**\n\n> 查看帧的局部变量表\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606155050.png)\n\n![image-20200606155202155](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606155202.png)\n\n![image-20200606160025218](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606160026.png)\n\nStartPC：变量开始作用的起始行（声明的下一行）\n\nLength：有效的长度\n\nIndex：局部变量的索引，有四个局部变量，分别是0、1、2、3。\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606160407.png)\n\n> 变量槽slot的理解与演示\n\n1.参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束\n\n2.局部变量表，**最基本的存储单元是Slot(变量槽)**\n\n3.局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。\n\n4.在局部变量表里，**32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。**\n\n* byte、short、char、float在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true；\n\n* long和double则占据两个slot。\n\n<img src=\"https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606160759.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n5.JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值\n\n6.当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照声明顺序被复制到局部变量表中的每一个slot上\n\n**7.如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。**（比如：访问long或者double类型变量）\n\n8.如果当前帧是由构造方法或者实例方法创建的（意思是当前帧所对应的方法是构造器方法或者是普通的实例方法），那么**该对象引用this将会存放在index为0的slot处**,其余的参数按照参数表顺序排列。\n\n9.静态方法中不能引用this，是因为静态方法所对应的栈帧当中的局部变量表中不存在this\n\n![](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606162106.png)\n\n![](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606162126.png)\n\n通过index我们可以发现b、c、d都占了两个槽位，因为他们都是64位的变量！\n\n> slot的重复利用\n\n栈帧中的局部变量表中的槽位是可以重复利用的，如果一个局部变量过了其作用域，那么在其作用域之后声明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。\n\n```java\nprivate void test2() {\n    int a = 0;\n    {\n        int b = 0;\n        b = a+1;\n    }\n    //变量c使用之前以及经销毁的变量b占据的slot位置\n    int c = a+1;\n}\n```\n\n上述代码对应的栈帧中局部变量表中一共有3个slot（也就是局部变量表的长度是3）\n\n因为变量b的作用域是：\n\n```java\n{\n     int b = 0;\n     b = a+1;\n}\n```\n\n除了这个括号，b就失效了，然后c重复使用了b的槽号。\n\n所以最终局部变量表中this占0号、a单独占1号，c为2号（之前b也是2号，b失效后，c占用b的槽）\n\n> 静态变量与局部变量的对比及小结\n\n变量的分类：\n\n- 按照数据类型分：\n  - ①基本数据类型;\n  - ②引用数据类型；\n- 按照在类中声明的位置分：\n  - ①成员变量：在使用前，都经历过默认初始化赋值\n    - static修饰：类变量：类加载链接的准备preparation阶段给类变量默认赋0值——>初始化阶段initialization给类变量显式赋值即静态代码块赋值；\n    - 不被static修饰：实例变量：随着对象的创建，会在堆空间分配实例变量空间，并进行默认赋值\n  - ②局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。\n\n> 补充\n\n- 在栈帧中，与性能调优关系最为密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递\n- **局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收**。\n\n#### 操作数栈\n\n1.栈 ：可以使用数组或者链表来实现\n\n2.每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出的操作数栈，也可以成为表达式栈\n\n**3.操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）或出栈（pop）**\n\n* 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈，使用他们后再把结果压入栈。（如字节码指令bipush操作）\n\n* 比如：执行复制、交换、求和等操作\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606164511.png)\n\n> 操作数栈特点\n\n- 操作数栈，**主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。**\n- 操作数栈就是jvm执行引擎的一个工作区，当一个方法开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的\n- 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译器就定义好了，保存在方法的code属性中，为max_stack的值。\n- 栈中的任何一个元素都是可以任意的java数据类型\n  - 32bit的类型占用一个栈单位深度\n  - 64bit的类型占用两个栈深度单位\n- 操作数栈**并非采用访问索引的方式来进行数据访问**的，而是只能通过标准的入栈push和出栈pop操作来完成一次数据访问\n- **如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，**并更新PC寄存器中下一条需要执行的字节码指令。\n- 操作数栈中的元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类验证阶段的数据流分析阶段要再次验证。\n- 另外，我们说Java虚拟机的**解释引擎是基于栈的执行引擎**,其中的栈指的就是操作数栈\n\n> 操作数栈代码追踪\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606170228.png)\n\n①15入栈；②存储15，15进入局部变量表\n\n注意：局部变量表的0号位被this占用，所以15从局部变量表1号开始。\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606170251.png)\n\n③压入8进入操作数栈；④8出栈，存储8进入局部变量表；\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606170339.png)\n\n⑤从局部变量表中把索引为1和2的是数据取出来，放到操作数栈；⑥iadd相加操作\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606170419.png)\n\n⑦iadd操作结果23出栈⑧将23存储在局部变量表索引为3的位置上istore_3。\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606170439.png)\n\n> 栈顶缓存技术ToS(Top-of-Stack Cashing)\n\n- 基于栈式架构的虚拟机所使用的零地址指令（即不考虑地址，单纯入栈出栈）更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数\n- 由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存技术，**将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率**\n\n#### 动态链接\n\n> 什么是运行时常量池\n\n运行时常量池位于方法区（注意： JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。）\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606213344.png)\n\n> 常量池的作用是什么\n\n常量池的作用，就是为了提供一些符号和常量，便于指令的识别。\n\n下面提供一张测试类的运行时字节码文件格式。\n\n![image-20200606213452872](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606213453.png)\n\n> 动态链接\n\n1.每一个栈帧内部都包含一个指向运行时常量池Constant pool或该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如invokedynamic指令\n\n2.在Java源文件被编译成字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Refenrence）保存在class字节码文件（javap反编译查看）的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用（#）最终转换为调用方法的直接引用。**\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606214126.png)\n\n> 方法的调用（重要）\n\n在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关\n\n- **静态链接**\n  当一个 字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。\n- **动态链接**\n  如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。\n\n对应的方法的绑定机制为：早起绑定（Early Binding）和晚期绑定（Late Bingding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。\n\n- **早期绑定**\n  早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。\n- **晚期绑定**\n  如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。\n\n随着高级语言的横空出世，类似于java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装，集成和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。\nJava中任何一个普通的方法其实都具备虚函数（即编译期无法确定）的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。\n\n> 虚方法与非虚方法\n\n子类对象的多态性使用前提：\n①类的继承关系（父类的声明）②方法的重写（子类的实现）\n\n\n非虚方法\n\n- 如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法\n- **静态方法、私有方法、final方法、实例构造器（实例已经确定，this()表示本类的构造器）、父类方法（super调用）都是非虚方法**\n\n虚方法\n\n* 其他所有体现多态特性的方法称为虚方法\n\n**虚拟机中提供了以下几条方法调用指令**：\n\n**普通调用指令：**\n\n* invokestatic：调用静态方法，解析阶段确定唯一方法版本；\n* invokespecial：调用\\<init\\>方法、私有及父类方法，解析阶段确定唯一方法版本\n* invokevirtual：调用所有虚方法；\n* invokeinterface：调用接口方法；\n\n**动态调用指令**（Java7新增）：\n\n* invokedynamic：动态解析出需要调用的方法，然后执行 。\n\n```\n关于invokedynamic指令\n\n1. JVM字节码指令集一直比较稳定，一直到java7才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。\n\n2. 但是java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令.直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在java中才有了直接生成方式。\n\n3. Java7中增加的动态语言类型支持的本质是对java虚拟机规范的修改，而不是对java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在java平台的动态语言的编译器。\n```\n\n```\n关于动态类型语言和静态类型语言\n\n动态类型语言和静态类型语言两者的却别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之则是动态类型语言。\n\n直白来说 静态语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息,这是动态语言的一个重要特征\n\nJava是静态类型语言（尽管lambda表达式为其增加了动态特性），js，python是动态类型语言。\n\nJava：String info = \"硅谷\";//静态语言\nJS：var name = \"硅谷“；var name = 10;//动态语言\nPythom：info = 130;//更加彻底的动态语言\n```\n\n前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。\n\n**其中invokestatic指令和invokespecial指令调用的方法称为非虚方法**。\n\n**其中invokevirtual（final修饰的除外，JVM会把final方法调用也归为invokevirtual指令，但要注意final方法调用不是虚方法）、invokeinterface指令调用的方法称称为虚方法。**\n\n> 方法的调用：方法重写的本质\n\n**Java语言中方法重写的本质：**\n\n- 1 找到操作数栈的第一个元素所执行的对象的实际类型，记作C。\n- 2.如果在类型C中找到与常量池中的描述符、简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。\n- 3.否则，按照继承关系从下往上依次对c的各个父类进行第二步的搜索和验证过程。\n- 4.如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。\n\n**IllegalAccessError介绍** ：\n\n程序视图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。\n\n> 方法的调用：虚方法表\n\n- 在面向对象编程中，会很频繁期使用到动态分派，如果在每次动态分派的过程中都要重新在累的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，jvm采用在类的方法区建立一个虚方法表（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。\n- 每个类中都有一个虚方法表，表中存放着各个方法的实际入口。\n- 那么虚方法表什么时候被创建？ 虚方法表会在类加载的链接阶段被创建 并开始初始化，类的变量初始值准备完成之后，jvm会把该类的虚方法表也初始化完毕。\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606222935.png)\n\n如果是自己的方法，就指向自己，如果是父类的或者Object类型的，就指向父类或者Object。\n\n#### 方法返回地址\n\n- 存放调用该方法的PC寄存器的值。\n- 一个方法的结束，有两种方式：\n  - 正常执行完成\n  - 出现未处理的异常，非正常退出\n- 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，**调用者（方法的调用者可能也是一个方法）的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。**而通过异常退出时，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。\n- 本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。\n- **正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。**\n\n> 当一个方法开始执行后，只有两种方式可以退出这个方法。\n\n1.执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；\n\n- 一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定\n- 在字节码指令中，返回指令包含ireturn（当返回值是boolena、byte、char、short和int类型时使用）、lreturn、freturn、dreturn以及areturn(引用类型的)\n- 另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606224313.png)\n\n2.在方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中**没有搜素到匹配的异常处理器（try-catch)**，就会导致方法退出，简称**异常完成出口**\n而如果存在方法执行过程中抛出异常时的**异常处理**，它会存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606224518.png)\n\nmethod1发生异常，method2进行处理。\n\n在method2中可以看到字节码当中的异常处理表：下表的行号不是上图的代码的行号，而是其对应字节码当中的行号。\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200606224604.png)\n\n 在字节码当中的4~11行是存在异常的代码行号，对应Java中70~73行，11代表字节码中能够处理该异常的位置是第11行也就是上图中的第72行。\n\n#### 一些附加信息\n\n栈帧中还允许携带与java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。（很多资料都忽略了附加信息）\n\n### （6）虚拟机栈的五道面试题\n\n> 1. 举例栈溢出的情况（StackOverlowError）\n\n* 使用了大量递归或者无限递归\n* 使用了大量循环或者死循环\n* 全局变量过多\n* 数组、List、map数据过大\n\n> 2. 调整栈大小，就能保证不会溢出吗？\n\n不能保证，假如无限递归，就算调整栈大小，也还是会溢出。\n\n> 3. 分配栈内存越大越好吗？\n\n肯定不是，栈内存分配的越大，其他程序的内存就变小，我们需要找到一个平衡点。\n\n> 4. 垃圾回收是否会涉及到虚拟机栈？\n\n不会，栈内存是一次次的方法调用产生的栈帧内存，一次方法调用后就会弹出栈，就会被自动的回收掉，所以根本不需要垃圾回收来管理栈内存，垃圾回收只是回收堆内存中的无用对象。\n\n> 5. 方法中定义的局部变量是否线程安全？\n\n如果局部变量不是方法的形参或者不是作为方法的返回值，那么它就是线程安全的。\n\n## 4. 本地方法栈\n\n### （1）本地方法概述\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200914105226.png)\n\n简单来讲，**一个Native Method就是一个java调用非java代码的接口**，一个Native Method 是这样一个java方法：该方法的底层实现由非Java语言实现，比如C。这个特征并非java特有，很多其他的编程语言都有这一机制，比如在C++ 中，你可以用extern “C” 告知C++ 编译器去调用一个C的函数。\n在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。\n本地接口的作用是融合不同的编程语言为java所用，它的初衷是融合C/C++程序。\n标识符native可以与其他所有的java标识符连用，但是abstract除外（因为抽象方法没有方法体）。\n\n**代码示例**\n\n```java\n/**\n * 本地方法\n */\npublic  class IHaveNatives {\n\n    //abstract 没有方法体\n    public abstract void abstractMethod(int x);\n\n    //native 和 abstract不能共存，native是有方法体的，由C语言来实现\n    public native void Native1(int x);\n\n    native static public long Native2();\n\n    native synchronized private float Native3(Object o);\n\n    native void Native4(int[] array) throws Exception;\n\n}\n```\n\n> 为什么要使用Native Method？\n\njava使用起来非常方便，然而有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。\n\n* **与java环境外交互**\n  有时java应用需要与java外面的环境交互，这是本地方法存在的主要原因。 你可以想想java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样的一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐细节。\n* **与操作系统交互**（比如线程最后要回归于操作系统线程）\n  JVM支持着java语言本身和运行库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至jvm的一些部分就是用C写的。还有，如果我们要使用一些java语言本身没有提供封装的操作系统特性时，我们也需要使用本地方法。\n* **Sun’s Java**\n  Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的事该类里的本地方法setPriority0（）。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setPriority()API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。\n\n> 现状\n\n现在的Java已经非常强大了，目前该方法的是用越来越少了，除非是与硬件有关的应用，比如通过java程序驱动打印机或者java系统管理生产设备，在企业级应用已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以是用Web Service等等，不多做介绍。\n\n### （2）本地方法栈概述\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200608222608.png)\n\n1. Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法（一般非Java实现的方法）的调用。\n\n2. 本地方法栈，也是线程私有的。\n\n3. 允许被实现成固定或者是可动态拓展的内存大小。（和Java虚拟机栈在内存溢出方面情况是相同的）\n\n   * 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverFlowError异常。\n   * 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么java虚拟机将会抛出一个OutOfMemoryError异常。\n\n4. 本地方法是用C语言实现的。\n\n5. 要想使用本地方法，它的具体做法是**Native Method Stack**中登记native方法，在**Execution Engine**执行时加载本地方法库。\n\n6. **当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限**\n\n   * 本地方法可以通过本地方法接口来 **访问虚拟机内部的运行时数据区**\n\n   * 它甚至可以直接使用本地处理器中的寄存器\n\n   * 直接从本地内存的堆中分配任意数量的内存\n\n7. .并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈（如上面那个图是Hostpot JVM，它就是支持本地方法栈的）。\n\n## 5. 堆空间\n\n### （1）堆的核心概述\n\n1. 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。\n2. Java 堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。\n   * 注意：堆内存的大小是可以调节的\n3. 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑思维它应该被视为连续的。（涉及到物理内存和虚拟内存）\n4. 所有的线程共享Java堆（线程不安全），在这里还可以划分**线程私有**的缓冲区。\n5. 《Java虚拟机规范》中对Java堆的描述是:所有的对象实例以及数组都应当在运行时分配在堆上。| (The heap is the run-time data area fromwhich memory for **all class** instances and arrays is allocated )\n   * 我要说的是:“几乎”所有的对象实例都在这里分配内存。从实际使用角度看的。\n6. 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。\n7. 堆，是GC ( Garbage Collection, 垃圾收集器)执行垃圾回收的重点区域。\n8. 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。\n\n![image-20200523213852303](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610173835)\n\n如上图代码，s1、s2是main方法里面的局部变量，s1、s2指向堆中创建的两个对象。\n\n![image-20200523213906307](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610173917)\n\n注意：当main方法结束后，这两个对象不会被立即回收！\n\nmain方法结束后，s1，s2就被弹出栈，堆中的s1，s2实例就没有被引用了，当GC进行判断的时候，发现s1,s2没有被引用，就判断为垃圾.**如果栈中的引用刚弹出，堆中的对象就被回收，那么GC的频率将特别高！**\n\n![image-20200523214532877](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610174050)\n\n<center>创建对象的字节码指令</center>\n\n#### 内存细分\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610174211)\n\n![image-20200523214917451](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610174353)\n\n\n\n### （2）设置堆内存大小与OOM\n\n#### 堆内存\n\n1. Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项\"-XmX\"和\"-Xms\"来进行设置。\n   * “-Xms\"用于表示堆区（**年轻代+老年代（不包括元空间）**）的起始内存**，等价于-XX：Ini tialHeapSize\n   * “-Xmx\"则用于表示堆区的最大内存，等价于-XX ：MaxHeapSize\n2. 一旦堆区中的内存大小超过“-Xmx\"所指定的最大内存时，将会抛出OutOfMemoryError异常。\n   通常会将-Xms 和-Xmx两个参数配置相同的值，其**目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。**\n\n\n\n场景一：计算堆空间大小和系统内存大小\n\n```java\n/**\n * 1. 设置堆空间大小的参数\n * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小\n * -X 是jvm的运行参数\n * ms 是memory start\n * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小\n * 2. 默认堆空间的大小\n * 初始内存大小：物理电脑内存大小 / 64\n * 最大内存大小：物理电脑内存大小 / 4\n * 3. 手动设置：-Xms600m -Xmx600m\n * 开发中建议将初始堆内存和最大的堆内存设置成相同的值。\n * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id\n * 方式二：-XX:+PrintGCDetails\n **/\n\npublic class Test {\n\n    public static void main(String[] args) {\n        // 返回Java虚拟机中的堆内存总量\n        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;\n        // 返回Java虚拟机视图使用的最大堆内存量\n        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;\n\n        System.out.println(\"-Xms:\" + initialMemory + \"M\");\n        System.out.println(\"-Xmx:\" + maxMemory + \"M\");\n        System.out.println(\"系统内存大小\" + initialMemory * 64.0 / 1024 + \"G\");\n        System.out.println(\"系统内存大小\" + maxMemory * 4.0 / 1024 + \"G\");\n    }\n}\n\n\n```\n\n> 运行结果\n\n![image-20200610211628051](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610211628.png)\n\n> 问题：为什么通过两种方式得到的系统内存大小不一致？（我的电脑内存是8G，按道理计算出来的系统内存大小也是8G）\n\n原因一：物理内存为8G，但是必须加载的数据会占据一定空间，所以可用空间比8G少。\n\n原因二：之后说明\n\n---\n\n**场景二：自定义JVM参数**\n\n1. 设置初始堆内存大小与最大内存大小\n\n![image-20200610211003917](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610211004.png)\n\n> 问题：为什么将初始堆内存和最大的堆内存设置成相同的值？\n\n如果内存不够，我们会进行扩容，如果内存多余，会进行内存释放。那么将初始堆内存和最大的堆内存设置成相同的值，就不必进行频繁的内存扩容与释放，给系统造成额外压力。\n\n2. 再次测试\n\n```java\npublic static void main(String[] args) {\n    // 返回Java虚拟机中的堆内存总量\n    long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;\n    // 返回Java虚拟机视图使用的最大堆内存量\n    long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;\n\n    System.out.println(\"-Xms:\" + initialMemory + \"M\");\n    System.out.println(\"-Xmx:\" + maxMemory + \"M\");\n    //        System.out.println(\"系统内存大小\" + initialMemory * 64.0 / 1024 + \"G\");\n    //        System.out.println(\"系统内存大小\" + maxMemory * 4.0 / 1024 + \"G\");\n}\n\n运行结果：\n-Xms:575M\n-Xmx:575M\n```\n\n> 问题：为什么比我们设置的600m小呢？\n\n![image-20200914110436721](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200914110437.png)\n\n1. 原理\n\n新生代分为Eden空间、Survivor0空间和Survivor1空间 (有时也叫做from区、to区)，因为有两个Survivor区，也叫幸存区，用的是标记拷贝的GC算法，实际分配时，永远有一个幸存区是不能被使用的，所以最大堆内存没有包含这一部分。\n\n2. 实践\n\n（1）修改代码，让main线程休眠1000秒。\n\n```java\npublic class Test {\n\n    public static void main(String[] args) {\n        // 返回Java虚拟机中的堆内存总量\n        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;\n        // 返回Java虚拟机视图使用的最大堆内存量\n        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;\n\n        System.out.println(\"-Xms:\" + initialMemory + \"M\");\n        System.out.println(\"-Xmx:\" + maxMemory + \"M\");\n//        System.out.println(\"系统内存大小\" + initialMemory * 64.0 / 1024 + \"G\");\n//        System.out.println(\"系统内存大小\" + maxMemory * 4.0 / 1024 + \"G\");\n        try {\n            Thread.sleep(1000000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n（2）S0与S1是两个幸存区，C后缀的表示总容量大小，U后缀的表示已用大小，从图中可以看出两个S0与S1的总大小都为25600（我截图没截好，S0C也是25600）\n\n我们计算总堆空间大小：（25600+153600+409600）÷1024=575，刚好是我们通过代码计算出来的堆空间大小。\n\n如果将两个幸存区大小都加进去，那就是（25600+25600+153600+409600）÷1024=600，是我们所设置的堆空间的大小。\n\n从而得出结论：永远有一个幸存区是不能被使用的，所以最大堆内存没有包含这一部分。\n\n![image-20200610221322956](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610221323.png)\n\n（3）另外一种方式证明：\n\n1）去掉休眠的代码\n\n2）增加参数\n\n![image-20200610222306548](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610222306.png)\n\n3）重新运行程序，打印结果如下：\n\n![image-20200610222559969](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610222600.png)\n\n#### OOM\n\nOOM - Out of Memory，内存溢出。\n\n1. 代码：在堆区新建很多对象，形成OOM场景。\n\n```\n\nimport java.util.ArrayList;\nimport java.util.Random;\n\n/**\n * -Xms600m -Xmx600m\n */\npublic class OOMTest {\n    public static void main(String[] args) {\n        ArrayList<Picture> list = new ArrayList<>();\n        while (true) {\n            try {\n                Thread.sleep(20);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            list.add(new Picture(new Random().nextInt(1024 * 1024)));\n        }\n    }\n}\n\nclass Picture {\n    private byte[] pixels;\n\n    public Picture(int length) {\n        this.pixels = new byte[length];\n    }\n}\n\n```\n\n2. 运行\n\n3. 打开jvisualvm，可以看到Old在逐渐上升！\n\n   ![image-20200610223936140](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610223936.png)\n\n   \n\n4. 当Old满了的时候，就会出现OOM，再返回IDEA，发现控制台也确实报了OOM。\n\n   ![image-20200610224021882](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610224022.png)\n\n![image-20200610224127107](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610224127.png)\n\n5. 查看抽样器，可以查看OOM的原因：byte[]太多。\n\n![image-20200610224232596](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200610224232.png)\n\n### （3）年轻代与老年代\n\n存储在JVM中的Java对象可以被划分为两类:\n\n* 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速\n* 另外一类对象的生命周期却非常长，在某些服端的情况下还能够与JVM的生命周期保持一致。\n\nJava堆区进一步细分的话， 可以划分为**年轻代**(YoungGen)和**老年代**(OldGen)\n其中年轻代又可以划分为**Eden空间**、**Survivor0**空间和**Survivor1**空间 (有时也叫做from区、to区)。\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200614220215.jpg)\n\n#### 参数设置\n\n**新生代与老年代的比例**\n\n我们可以自行配置新生代与老年代在堆结构的占比。\n\n* 默认：-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3\n\n* 可以修改为：-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5\n\n一般情况下，我们不会去修改这个比例，如果我们明确知道生命周期较长或者较短的对象多，我们就可以调下这个新生代与老年代的比例。\n\n**Eden空间、Survivor0空间和Survivor1空间的比例**\n\n在HotSpot中，Eden 空间和另外两个Survivor空间缺省所占的比例是8:1:1，我们可以通过“-XX:SurvivorRatio”调整这个空间比例，比如-XX：SurvivorRatio=8。\n\n> 问题：默认是8:1:1，但是我们通过jvisualvm查看的时候，发现真实情况不是如此！\n\n真实情况是6:1:1，原因是这中间存在一个东西：**自适应的机制**。\n\n<img src=\"https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200614221025.png\" alt=\"image-20200614221024839\" style=\"zoom：67%;\" />\n\n> 解决方案一：-XX:-UseAdaptiveSizePolicy：关闭自适应的内存分配策略（无效！）\n\n-UseAdaptiveSizePolicy表示关闭自适应机制，+UseAdaptiveSizePolicy表示开启自适应机制。我们设置好-XX:-UseAdaptiveSizePolicy这个参数后，发现还是无效！还是6:1:1！\n\n![image-20200614221254586](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200614221254.png)\n\n> 解决方案二：用到-XX:SurvivorRatio=8，表示8:1:1，显式声明后有效！\n\n![image-20200614221505280](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200614221505.png)\n\n![image-20200524112228284](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200614221516)\n\n> 补充知识：\n\n- **几乎所有**的Java对象都是在Eden区被new出来的。\n- 绝大部分的Java对象的销毁都在新生代进行了。\n  ➢IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。\n- 可以使用选项\"-Xmn\"设置新生代最大内存大小\n  - 这个参数一般使用默认值就可以了。\n  - 如果又有-XX:NewRatio，又有-Xmn参数，两个就会矛盾，最终以Xmn为主。\n\n### （4）图解对象分配过程\n\n为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。\n\n**对象分配过程：**\n\n1. 新建对象放在Eden区（此区有大小限制）\n2. 当Eden区满时，此时触发垃圾回收机制（Minor GC或Young GC），将Eden区中不再被其他对象引用的对象进行回收，再加载新的对象放入Eden区\n\n3. 将Eden区中仍然被引用的对象移动到幸存者0区。\n\n   * 注意：当Eden区满了出发Minor GC的时候，Minor GC也会回收幸存者0区的无效对象。\n\n   ![image-20200615115014074](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200615115201.png)\n\n   红色的是需要进行回收的，绿色的表示不需要回收，从图中可以看到，它被移入S0。\n\n4. 如果Eden区又满了，再次触发MinorGC，然后回收Eden区与幸存者0区的无效对象，那么幸存者0区有效的对象就不会被回收，我们会将它移动到幸存者1区。\n\n![image-20200615115340461](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200615115341.png)\n\n​\tEden区满了，又进行一次Minor GC，是放在S0还是S1呢？是放在S1当中。因为S1为空，就称为to（表示空）。将Eden的绿色对象放入s1中后，此时S0中的绿色对象也要进行判断，当发现这俩还被占用，还不能被销毁，就把S0区的也放入S1区并增长为2。此时S0空了变为to区，s1变为from区，以此类推。\n\n> 什么时候能去老年代呢？\n\n可以设置参数-XX:MaxTenuringThreshold=<N>，默认是15。\n\n什么意思呢？每个在新生代的对象有一个计数值，在垃圾回收的时候，如果他活下来了，他的计数值就会加1，当达到15的时候，它就会被移动到老年区。\n\n![image-20200615115937322](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200615115937.png)\n\nEden又满了，就继续放入S0，S1进行判断，1号还用就放入S0。我们发现S1中有两个已经达到15了，就晋升至老年代，放入Old，此时就不进行判断它了。只有当有柱子再进入老年代的时候才进行判断。15称为阈值（临界值，默认的）\n\n注意：**幸存者区不会主动触发GC，它会被动回收**！原因是：Eden区满时触发YGC，Eden触发GC的时候会将Eden与S区（属于被动）一起进行垃圾回收。\n\n老年代一般很少有垃圾回收机制，当内存不足时，触发GC：Major GC，进行老年区的内\n存清理。\n\n执行了Major GC之 后发现依然无法进行对象的保存，**就会产生OOM异常java.lang. OutOfMemoryError：Java heap space**\n\n> 总结：\n\n- 针对幸存者s0,s1区的总结:复制之后有交换，谁空谁是to。\n- 关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集。\n\n> 对象分配的特殊情况\n\n![image-20200524145910809](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200618105633)\n\n通过图片可以很清楚的了解当Eden区放不下对象的时候，会怎么办。\n\n需要注意的是：\n\n* 放不下就扔Old区。\n* 当Old放不下的时候，会启动FGC。\n* 当FGC后，Old还是放不下后，就会报OOM。\n\n> 常用调优工具\n\n- JDK命令行\n- Eclipse ：Memory Analyzer Tool\n- Jconsole\n- VisualVM\n- Jprofiler\n- Java Flight Recorder\n- GCViewer\n- GC Easy\n\n### （5）Minor GC、Major GC、Full GC\n\nJVM在进行GC时，并非每次都对上面三个内存区域(新生代、老年代；方法区)一起回收的，大部分时候回收的都是指新生代（80%）。\n\n针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是**部分收集**(Partial GC)，一种是**整堆收集**(Full GC)。\n\n**部分收集(Partial GC)：**是完整收集整个Java堆的垃圾收集。其中又分为:\n\n* 新生代收集(Minor GC / Young GC) :只是新生代(Eden/S0,S1)的垃圾收集\n* 老年代收集(Major GC / Old GC) :只是老年代的垃圾收集。\n  * 目前，只有CMS GC会有单独收集老年代的行为。\n  * 注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代\n    回收还是整堆回收。\n* 混合收集(Mixed GC)：收集整个新生代以及部分老年代的垃圾收集。\n  * 目前，只有G1 GC会有这种行为。\n\n**整堆收集(Full GC)**：收集整个java堆和方法区的垃圾收集。\n\n> 年轻代GC触发条件\n\n* 当年轻代空间不足时，就会触发Minor GC， 这里的年轻代满指的是Eden代满，Survivor满不会引发GC。( 每次Minor GC会清理年轻代的内存。)\n* 因为Java 对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。\n* Minor GC会引发STW， 暂停其它用户的线程，等垃圾回收结束，用户线\n  程才恢复运行。\n\n> 老年代GC触发条件\n\n* 指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”\n  发生了。\n* 出现了Major GC，经常会伴随至少一次的Minor GC (但非绝对的，Parallel\n  Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。\n  * 也就是在老年代空间不足时，会先尝试进行触发 Minor GC。如果之后空间还不足，则触发Major GC。\n* Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。\n* 如果Major GC后，内存还不足，就报OOM了。\n\n> Full GC触发条件\n\n* 调用System.gc()时，系统建议执行Full GC，但是不必然执行\n* 老年代空间不足\n* 方法区空间不足\n* 通过Minor GC后进入老年代的平均大小大于老年代的可用内存\n* 由Eden区、survivor space0 ( From Space) 区向survivor space1 (To Space)区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小\n\n\n\n我们实际上希望出现GC情况少一些。GC也是垃圾回收的线程来做的，对应的另一个线程是用户线程（我们真正要执行代码所用到的线程）。GC的线程在判断哪些是垃圾的时候，会让用户线程做一个暂停，用户线程一暂停，程序执行的一个吞吐量就会差一些。减少GC就减少了这个STW的频率，用户就会被较少的干预到。重点关注Major GC和Full GC，因为他们两个所产生的暂停时间比Minor GC长\n\n\n\n\n### （6）堆空间的分代思想\n\n> 为什么需要把Java堆分代?不分代就不能正常工作了吗?\n\n* 经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。\n  * 新生代：有Eden、两块大小相同的Survivor(又称为from/to， s0/s1)构成，to总为空。\n  * 老年代：存放新生代中经历多次GC仍然存活的对象。\n\n![image-20200527161159646](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200618145216)\n\n* 其实不分代完全可以，**分代的唯一理由就是优化GC性能**。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的 候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。\n\n\n\n\n\n### （7）内存分配策略\n\n内存分配策略也叫做对象提升（Promotion）原则\n\n如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor\n容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor区中每熬过一次MinorGC，年龄就增加1 岁，当它的年龄增加到一定程度(默认为15岁，其实每个JVM、每个GC都有所不同)时，就会被晋升到老年代中。\n对象晋升老年代的年龄阈值，可以通过选项**-XX：MaxTenuringThreshold**来设置。\n\n针对不同年龄段的对象分配原则如下所示:\n● 优先分配到Eden\n\n● 大对象直接分配到老年代\n\n​\t➢尽量避免程序中出现过多的大对象\n\n● 长期存活的对象分配到老年代\n\n● 动态对象年龄判断\n\t➢如果Survivor 区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。\n\n● 空间分配担保\n\t➢ -XX：HandlePromotionFailure\n![image-20200527164220614](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200618154954)\n如图所示，新建一个20M的对象，Eden区为16M，放不下，直接放到老年代。\n\n### （8）为对象分配内存：TLAB\n\n>  为什么有TLAB（Thread Local Allocation Buffer ）？\n\n* 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据\n* 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内\n  存空间是线程不安全的\n* 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。\n\n> 什么是TLAB？\n\n* 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为\n  每个线程分配了一个私有缓存区域，它包含在Eden空间内。\n* 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。\n* 据说所有OpenJDK衍生出来的JVM都提供了TLAB的设计。\n  ![image-20200527164854508](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200618155604)\n\n> TLAB的说明：\n\n1. 尽管不是所有的对象实例都能够在TLAB中成功分配内存（因为TLAB的空间相对来说还是比较小的），**但JVM确实是TLAB作为内存分配的首选。**\n   * 在程序中，开发人员可以通过选项“-XX:UseTLAB”设置是否开启TLAB空间（默认开启）。\n2. 默认情况下，TLAB空间的内存非常小，**仅占有整个Eden空间的1%**，当然我们可以通过选项“-XX:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。\n3. 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过**使用加锁机制**确保数据操作的原子性，从而直接在Eden空间中分配内存。\n\n![image-20200527170706159](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200618160009)\n\n### （9）小结堆空间的参数设置\n\n官网说明\n\n* -XX：+PrintFlagsInitial：查看所有的参数的默认初始值\n\n* -XX：+PrintFlagsFinal ：查看所有的参数的最终值(可能会存在修改,\n  不再是初始值)\n  * 具体查看某个参数的指令：jps （ 查看当前运行的进程）\n  * jinfo -flag SurviorRation 进程id\n* -Xms：初始堆空间内存 (默认为物理内存的1/64)\n* -Xmx：最大堆空间内存(默认为物理内存的1/4)    \n* -Xmn：设置新生代的大小。(初始值及最大值)\n* -XX：NewRatio:配置新生代与老年代在堆结构的占比\n* -XX：SurvivorRatio:设置新生代中Eden和S0/S1空间的比例\n* -XX：MaxTenuri ngThreshold:设置新生代垃圾的最大年龄\n* -XX：+PrintGCDetails:输出详细的GC处理日志\n  * 打印gc简要信息（两种方式）：①-XX：+PrintGC. ②-verbose:gc\n* -XX：HandlePromotionFalilure:是否设置空间分配担保\n\n> 关于SurvivorRatio的说明\n\n如果SurvivorRatio的值过大，那么Eden空间大，S区小，每经过一次Minor GC，S区都放不下存活的对象，这些对象就被直接转入老年代。这样Monor GC就失去了意义。因为S区一直是空的。\n\n> 关于空间分配担保的说明\n\n在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。\n\n* 如果大于，则此次Minor GC是安全的\n* 如果小于，则虚拟机会查看-XX: HandlePromotionFai lure设置值是否允许担保失败\n* 如果HandlePromotipnFailure=true，那么会继续检查老年代最大可\n  用连续空间是否大于历次晋升到老年代的对象的平均大小。\n  * 如果大于，则尝试进行一次Minor GC， 但这次Minor GC依然是有风险的;\n  * 如果小于，则改为进行一次Full GC。\n* 如果HandlePromotionFailure=false， 则改为进行一次Full GC。\n\n在JDK6 Update24之后（JDK7），HandlePromot ionFailure参数不会再影响到虚拟机的空间分配担保策略，观察OpenJDK中的源码变化，虽然源码中还定义了HandlePromot ionFailure参数，但是在代码中已经不会再使用它。JDK6 Update24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。也就是默认为true。\n\n### （10）堆是分配对象的唯一选择吗\n\n在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述:\n随着JIT编译期的发展与**逃逸分析技术**逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，**所有的对象都分配到堆上也渐渐变得不那么“绝对”了**。\n\n在Java虛拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是**如果经过逃逸分析(Escape Analysis) 后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。**这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。\n\n此外，前面提到的基于openJDK深度定制的TaoBaoVM，其中创新的GCIH (GC invisible heap) 技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低Gc的回收频率和提升GC的回收效率的目的。\n\n如何将堆上的对象分配到栈，需要使用逃逸分析手段。这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。\n\n通过逃逸分析，JavaHotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。\n\n逃逸分析的基本行为就是分析对象动态作用域:\n\n* 当一个对象在方法中被定义后，**对象只在方法内部使用，则认为没有**\n  **发生逃逸。**\n* 当一个对象在方法中被定义后，**它被外部方法所引用，则认为发生逃**\n  逸。例如作为调用参数传递到其他地方中。\n\n\n\n> 逃逸分析的参数设置\n\n在JDK 6u23（JDK7）版本之后，HotSpot中默认就已经开启了逃逸分析。\n如果使用的是较早的版本，开发人员则可以通过:\n\n* 选项“-XX: +DoEscapeAnalysis\" 显式开启逃逸分析\n* 通过选项“-XX: +PrintEscapeAnalysis\"查看逃逸分析的筛选结果\n\n> 代码优化：逃逸分析之栈上分配\n\nJIT编译器在编译期间根据逃逸分析的结果，发现如果一一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。\n\n> 代码优化：逃逸分析之同步省略\n\n* 线程同步的代价是相当高的，同步的后果是降低并发性和性能。\n* 在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。\n\n<img src=\"https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619152221\" alt=\"image-20200528133246945\" style=\"zoom:50%;\" />\n\n但是我们查看字节码文件，会发现同步代码块的字节码还是存在的。\n\n![image-20200528134535753](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619152351)\n\n> 代码优化：逃逸分析之标量替换\n\n**标量**是指一个无法分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，可以再分解的叫做**聚合量，Java中的对象就是聚合量。**\n\n在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来替代。这个过程就是标量替换。\n\n![image-20200619152903517](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619152903.png)\n\n![image-20200528134905654](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619152912)\n\n用两个标量去替换了原来的对象，就不需要在堆上给对象分配空间了，直接在栈中的局部变量表分配空间就好了，也就没有了GC，因为虚拟机栈是没有垃圾回收的。\n\n> 总结\n\n关于逃逸分析，可能会使用到以下参数：\n\n![image-20200619153753537](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619153753.png)\n\n注意-server可以省略掉，因为我的JVM本身就是在Server模式的。\n\n![image-20200619153931366](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619153931.png)\n\n\n\n**开发中能使用局部变量的，就不要使用在方法外定义。**从而避免逃逸。\n\n关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也**不成熟**。\n其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是**逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。**\n一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。\n虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。\n注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据所知，**Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上**。\n\n目前很多书籍还是基于JDK 7以前的版本，JDK已经发生了很大变化，字符串常量和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，字符串常量和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论:对象实例都是分配在堆上。\n\n### （11）堆空间总结\n\n* 年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。\n* 老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上;\n* 如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。\n* 当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGC。当GC发生在老年代时则被称为MajorGC或者FullGC。 一般的，MinorGC的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。\n\n---\n\n## 6. 方法区\n\n### （1）栈、堆、方法区的交互关系\n\n![image-20200604135724895](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619171053)\n\n![image-20200619171228915](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619171229.png)\n\nJdk 1.8之后用元空间取代了永久代（方法区的实现，方法区是一种规范，永久代是方法区的实现）\n\n![image-20200604145945327](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619172614)\n\n上图已经很清晰明了了！\n\n### （2）方法区的理解\n\n[官方文档地址](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4)\n\n![image-20200619172857191](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619172857.png)\n\n<center>官方文档对方法区的解释</center>\n\n\n\n> 翻译：\n\nJava虚拟机有一个在所有Java虚拟机线程之间共享的方法区。方法区类似于传统语言编译代码的存储区域，或类似于操作系统进程中的“文本”段。它存储每个类的结构，比如运行时常量池、属性和方法数据，以及方法和构造函数的代码，包括在类、实例接口初始化中使用的特殊方法。\n\n方法区是在虚拟机启动时创建的。虽然方法区在逻辑上是堆的一部分，但一些简单的实现可能不会去选择进行垃圾收集或压缩。该规范没有规定方法区的位置或用于管理已编译代码的策略。方法区可以是固定大小，也可以根据计算的需要进行扩展，如果不需要更大的方法区，则可以缩小。方法区的内存不需要是连续的。\n\nJava虚拟机实现可以为程序员或用户提供对方法区初始大小的控制，以及在方法区大小可变的情况下，可以控制最大和最小方法区的大小。\n\n以下异常情况与方法区相关:\n\n* 如果方法区中的内存无法满足分配请求，Java虚拟机将抛出OutOfMemoryError错误。\n\n> 方法区在哪里？\n\n《Java虚拟机规范》中明确说明:“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap (非堆)，目的就是要和堆分开。\n\n所以，方法区看做是一块独立于Java堆的内存空间。\n\n![image-20200604152637450](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619174517)\n\n> 方法区的基本理解\n\n* 方法区(MethodArea)与Java堆一样，是各个线程共享的内存区域。（意思是既然是一个共享区域，如果这个类没有加载的话，只能有一个线程去调用ClassLoader，其他线程想要使用这个类的话就必须得等待。即我们只需要加载一次）\n* 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。\n* 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误: java. lang .OutofMemoryError:PermGen space 或者java. lang.OutOfMemoryError:Metaspace\n* 关闭JVM就会释放这个区域的内存。\n\n### （3）设置方法区大小与OOM\n\n### （4）方法区的内部结构\n\n### （5）方法区使用实例\n\n### （6）方法区的演进细节\n\n* 在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始， 使用元空间取代了永久代。（可以把方法区当成接口，永久带或者元空间当作实现）\n\n  > In JDK 8, casses metadata is now stored in the native heap and this space is called Metaspace.\n\n* 本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java 虚拟规范》对如何实现方法区，不做统一要求。例如: BEA JRockit/ IBM J9中不存在永久代的概念。\n\n  * 现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOM （超过-XX :MaxPermSize.上限）\n\n![image-20200604154937740](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619175839)\n\n而到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在**本地**\n**内存中**实现的元空间(Metaspace)来代替。\n\n![image-20200604155221247](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200619175917)\n\n元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：**元空间不在虚拟机设置的内存中，而是使用本地内存。**\n\n永久代、元空间二者并不只是名字变了，内部结构也调整了。\n\n根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。\n\n### （7）方法区的垃圾回收\n\n### （8）总结\n\n","tags":["JVM内存与垃圾回收"],"categories":["JVM"]},{"title":"Docker一探究竟","url":"/Docker/Docker一探究竟","content":"\n本篇是Docker学习笔记，基本上深入了解了Docker！\n\n<!--more-->\n\n# Docker概述\n\n## Docker为什么会出现?\n\n如何让你的项目带上环境在别人的电脑上也能运行？\n\n如何避免超级麻烦的各种环境的配置？\n\n如何跨平台开发？\n\nDocker的出现解决了以上难题！\n\n**实现步骤：**\n\n1. 本地开发项目\n2. 打包项目带上环境（镜像）\n3. 发布到Docker仓库：商店\n4. 别人下载我们发布的镜像\n5. 直接运行即可\n\n**Docker的思想**：\n\n![image-20200706120115805](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200706120116.png)\n\nDocker的图标是一个鲸鱼上面有很多集装箱，所以Docker的思想来源于集装箱。\n\n**隔离**：打包装箱，每个箱子是互相隔离的。（不用担心端口冲突环境冲突等！）\n\nDocker通过隔离机制，将服务器利用到机制。\n\n**Docker网址：**\n\n[Docker官方文档](https://docs.docker.com/)\n\n[Docker官网](https://www.docker.com/)\n\n## Docker历史\n\n未记录\n\n## Docker能干嘛\n\n### 容器化技术\n\n1. 容器内的应用直接运行在宿主机的内核上，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了。\n2. 每个容器间是相互隔离的，每个容器内部都有一个属于自己的文件系统，互不影响。\n\n### DevOps\n\nDevOps即开发与运维\n\nDevOps有以下特点：\n\n**1. 应用更快速的交付和部署**\n\n传统：一堆帮助文档，安装程序。\n\nDocker：打包镜像发布测试，一键运行。\n\n**2. 更便捷的升级和扩缩容**\n\n使用了Docker之后，我们部署应用就和搭积木一样。\n\n如果我们将一个项目打包为一个镜像，比如说服务器A上的项目出现问题了，我们可以在服务器上B直接运行镜像，进行水平扩展。\n\n**3. 更简单的系统运维系统**\n\n在容器化之后，我们的开发，测试环境都是高度一致的。\n\n不会出现在我的电脑上能跑，在你的电脑上就不能用了的问题。\n\n**4. 更高效的计算资源利用**\n\n使用Docker可以实现1核2g的服务器 ，可以同时运行几十个tomcat！！\n\nDocker是内核级别的虚拟化，可以在一个物理机上运行很多的容器实例。\n\n服务器的性能可以被发挥到极致！\n\n# Docker安装\n\n## Docker架构\n\n![image-20200622121648799](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200622121649.png)\n\n#### 镜像(image):\n\ndocker镜像就好比是一个模板，可以通过这个模板来创建容器服务。\n\n比如：\n\ntomcat镜像-->run--->tomcat01容器(提供服务器)\n\n通过这个镜像可以创建多个容器(最终服务运行或者项目运行就是在容器中的)。\n\n#### 容器(container):\n\nDocker利用容器技术，独立运行一个或者一个组应用 ，通过镜像来创建容易。\n\n容器基本命令包括：启动，停止，删除。\n目前就可以把这个容器理解为就是一个简易的linux系统。\n\n#### 仓库(repository):\n\n仓库就是存放镜像的地方，仓库分为公有仓库和私有仓库。\n\n1. Docker Hub(默认是国外的)\n\n2. 像阿里云之类的大型企业都有容器服务器(配置镜像加速)\n\n## 安装Docker\n\n### 环境查看\n\n```shell\n[root@zhenghaoyun ~]$ uname -r \t#查看内核版本\n3.10.0-1062.18.1.el7.x86_64\n[root@zhenghaoyun ~]$ cat /etc/os-release \nNAME=\"CentOS Linux\"\nVERSION=\"7 (Core)\"\nID=\"centos\"\nID_LIKE=\"rhel fedora\"\nVERSION_ID=\"7\"\nPRETTY_NAME=\"CentOS Linux 7 (Core)\"\nANSI_COLOR=\"0;31\"\nCPE_NAME=\"cpe:/o:centos:centos:7\"\nHOME_URL=\"https://www.centos.org/\"\nBUG_REPORT_URL=\"https://bugs.centos.org/\"\n\nCENTOS_MANTISBT_PROJECT=\"CentOS-7\"\nCENTOS_MANTISBT_PROJECT_VERSION=\"7\"\nREDHAT_SUPPORT_PRODUCT=\"centos\"\nREDHAT_SUPPORT_PRODUCT_VERSION=\"7\"\n\n```\n\n### 安装\n\n可以查看[帮助文档]( https://docs.docker.com/engine/install/centos/)\n\n```shell\n# 1.卸载旧版本\n$ yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n# 2.需要的安装包\n$ yum install -y yum-utils\n\n# 3.设置镜像仓库\n$ yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo\t\t# 默认是国外的!很慢!\n    \n$ yum-config-manager \\\n    --add-repo \\\n    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 阿里云镜像 快\n\n# 更新yum软件包索引\n$ yum makecache fast\n\n# 4.安装docker\tdocker-ce 社区版 ee 企业版\n$ yum install docker-ce docker-ce-cli containerd.io\n\n# 5.启动docker\n$ systemctl start docker\n\n# 6.使用docker version查看是否安装成功\n$ docker version\n\n# 7.使用hello owrld测试\n$ docker run hello-world\n\n# 判断images是否下载成功，可以看到hello-world镜像。\n$ docker images\n```\n\n### 卸载\n\n```shell\n# 卸载依赖\n$ yum remove docker-ce docker-ce-cli containerd.io\n# 删除资源\n$ rm -rf /var/lib/docker\n# /var/lib/docker docker的默认工作路径\n```\n\n## 阿里云镜像加速\n\n登录阿里云找到容器服务\n\n![image-20200622121734748](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200706120130.png)\n\n\n\n配置使用\n\n![image-20200526121645455](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200530235624.png)\n\n```shell\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-'EOF'\n{\n  \"registry-mirrors\": [\"https://owqdaahd.mirror.aliyuncs.com\"]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n```\n\n## Docker run流程\n\nrun的流程图\n\n![image-20200622122233453](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200622122233.png)\n\n# Docker底层原理\n\nDocker是一个Client -Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问！\n\nDockerServer接收到DockerClient的信息，就会执行这条命令。\n\n![image-20200706120201339](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200706120201.png)\n\n**Docker为什么比VM块？**\n\n1. Docker有比虚拟机更少的抽象层\n2. Docker利用的是宿主机的内核，vm是需要Guest OS（需要再搭建一个环境）\n\n![image-20200622122255917](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200622122256.png)\n\n所以说，新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免了引导过程，虚拟机是加载Guest OS，是分钟级别的。而Docker是利用宿主机的操作系统，省略了这个复杂的过程，是秒级的！\n\n# Docker命令\n\n## 帮助命令\n\n```shell\ndocker version # 显示docker版本信息\ndocker info    # 显示docker的的系统信息，包括镜像和容器的数量\ndocker 命令 --help # 帮助命令\n```\n\n不会的时候就查[帮助文档地址](https://docs.docker.com/reference/)吧！\n\n## 镜像命令\n\n### docker images查看本机所有镜像\n\n```shell\n[root@zhenghaoyun ~]$ docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nhello-world         latest              bf756fb1ae65        4 months ago        13.3kB\n```\n\n**名词解释：**\n\n* REPOSITORY  镜像的仓库源\n* TAG\t\t\t镜像的标签\n* IMAGE ID\t镜像的id\n* CREATED\t\t镜像的创建时间\n* SIZE\t\t镜像的大小\n\n**参数解释：**\n\n```shell\n-a，  --all\t\t# 列出所有镜像\n-q，  --quiet\t# 列出所有镜像id，一般-ap连用\n```\n\n```shell\n[root@zhenghaoyun ~]$ docker images -a\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nhello-world         latest              bf756fb1ae65        4 months ago        13.3kB\n[root@zhenghaoyun ~]$ docker images -aq\nbf756fb1ae65\n```\n\n### docker search搜索镜像\n\n![image-20200706120239505](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200706120239.png)\n\n**可选项：通过\\*\\*过滤**\n\n例：`docker search mysql --filter=stars=3000`搜索出来的镜像就是STARS大于3000的 \n\n### **docker pull下载镜像**\n\n```shell\n# 下载镜像 docker pull 镜像名[:tag]\n[root@zhenghaoyun ~]$ docker pull mysql\nUsing default tag: latest\t# 如果不写[tag]默认就是latest\nlatest: Pulling from library/mysql\t# 分层下载. docker image核心 联合文件系统\n5b54d594fba7: Pull complete \n07e7d6a8a868: Pull complete \nabd946892310: Pull complete \ndd8f4d07efa5: Pull complete \n076d396a6205: Pull complete \ncf6b2b93048f: Pull complete \n530904b4a8b7: Pull complete \nfb1e55059a95: Pull complete \n4bd29a0dcde8: Pull complete \nb94a001c6ec7: Pull complete \ncb77cbeb422b: Pull complete \n2a35cdbd42cc: Pull complete \nDigest: sha256:dc255ca50a42b3589197000b1f9bab2b4e010158d1a9f56c3db6ee145506f625 # 签名\nStatus: Downloaded newer image for mysql:latest\t\ndocker.io/library/mysql:latest \t# 真实地址\n\n# 等价\ndocker pull mysql\ndocker pull docker.io/library/mysql:latest\n\n# 指定版本下载\n[root@zhenghaoyun ~]$ docker pull mysql:5.7\n5.7: Pulling from library/mysql\n5b54d594fba7: Already exists \t# 联合文件系统特性，已存在的直接复用 Already exists表示已经存在\n07e7d6a8a868: Already exists \nabd946892310: Already exists \ndd8f4d07efa5: Already exists \n076d396a6205: Already exists \ncf6b2b93048f: Already exists \n530904b4a8b7: Already exists \na37958cbebcf: Pull complete \n04960017f638: Pull complete \ne1285def0d2a: Pull complete \n670cb3a9678e: Pull complete \nDigest: sha256:e4d39b85118358ffef6adc5e8c7d00e49d20b25597e6ffdc994696f10e3dc8e2\nStatus: Downloaded newer image for mysql:5.7\ndocker.io/library/mysql:5.7\n```\n\n### docker rmi删除镜像\n\nrmi中的i代表images\n\n```\n[root@zhenghaoyun ~]$ docker rmi -f 镜像id  # 删除指定的镜像\n[root@zhenghaoyun ~]$ docker rmi -f 镜像id 镜像id 镜像id \t# 删除多个容器\n[root@zhenghaoyun ~]$ docker rmi -f $(docker images -aq)  # 删除全部镜像\n```\n\n`$()`中可以写命令，`docker images -aq`是查出所有镜像的id，`$(docker images -aq)`就可以得到所有id并作为`docker rmi -f`命令要删除的对象。\n\n##  容器命令\n\n有了镜像后，通过镜像可以创建容器。\n\n```\ndocker pull centos #下载一个centos镜像\n```\n\n### docker run新建容器并启动\n\n```shell\ndocker run [可选参数] image\n# 参数说明\n--name=\"Name\" \t容器名字 tomcat01 tomcat02 用来区分容器\n-d\t\t\t\t后台方式运行(nohup)\n-it\t\t\t\t使用交互方式运行，进入容器查看内容\n-p\t\t\t\t指定容器的端口  -p 8080:8080\n\t-p ip:主机端口:容器端口\n\t-p 主机端口:容器端口 (常用)\n\t-p 容器端口\n\t容器端口\n-P\t\t\t\t随机指定端口\n```\n\n测试\n\n```shell\n[root@zhenghaoyun ~]$ docker run -it centos /bin/bash\n#进入容器\n[root@2c235d59bdbb /]# ls\nbin  etc   lib\t  lost+found  mnt  proc  run   srv  tmp  var\ndev  home  lib64  media       opt  root  sbin  sys  usr\n#从容器中退回主机\n[root@2c235d59bdbb /]# exit\nexit\n\n```\n\n可以看到进入了centos容器\n\n### docker ps列出所有运行的容器\n\ndocker ps\n\n```shel\ndocker ps\t# 列出当前正在运行的容器\n-a\t# 列出当前正在运行的容器+历史运行过的容器\n-n=? # 显示最近创建的容器\n-q\t# 只显示容器的编号\n```\n\n### 退出容器\n\n```shell\nexit \t# 直接停止容器并退出\nCtrl + p + q # 容器不停止退出\n```\n\n### 删除容器\n\n```shell\ndocker rm 容器id  \t\t\t\t# 删除指定的容器，不能删除正在运行的容器\ndocker rm -f 容器id\t\t\t    # 强制删除容器\ndocker rm -f $(docker ps -aq)\t # 递归删除所有的容器\ndocker ps -aq|xargs docker rm \t # 通过管道命令删除所有的容器\n```\n\n### 启动容器和停止容器\n\n```shell\ndocker start 容器id\t\t# 启动容器\ndocker restart 容器id\t\t# 重启容器\ndocker stop 容器id\t\t# 停止容器\ndocker kill 容器id\t\t# 强制停止容器\ndocker run -d 镜像名\t   # 后台启动\n```\n\n常见的坑：docker容器使用后台运行就必须要有一个前台进程，docker发现没有应用，就会自动停止！\n\n如nginx容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了。\n\n### 查看日志\n\n```shell\ndocker logs -f -t --tail 10 容器id\t# 显示10条日志\n\t-tf \t\t\t# 显示日志\n\t--tail number \t# 要显示的日志条数\n```\n\n### 查看容器中进程信息\n\n```shell\ndocker top 容器id\n```\n\n### 查看容器元数据\n\n```shell\ndocker inspect 容器id\n```\n\n```shell\n[root@zhenghaoyun ~]$ docker inspect be9f24ac2472\n[\n    {\n        \"Id\": \"be9f24ac24725cbcf7b0a0495c3d9590d3d158994e0a1029542675711908aacd\"，\n        \"Created\": \"2020-05-26T09:41:19.843651451Z\"，\n        \"Path\": \"/bin/bash\"，\n        \"Args\": []，\n        \"State\": {\n            \"Status\": \"running\"，\n            \"Running\": true，\n            \"Paused\": false，\n            \"Restarting\": false，\n            \"OOMKilled\": false，\n            \"Dead\": false，\n            \"Pid\": 8235，\n            \"ExitCode\": 0，\n            \"Error\": \"\"，\n            \"StartedAt\": \"2020-05-26T09:41:20.356642351Z\"，\n            \"FinishedAt\": \"0001-01-01T00:00:00Z\"\n...\n```\n\n### 进入当前正在运行的容器\n\n```shell\n# 通常容器都是使用后台方式运行的，需要进入容器，修改一些配置\n\n# 命令\ndocker exec -it 容器id bashShell\n\n# 方式二\ndocker attach 容器id\n正在执行的代码....\n\n# docker exec\t\t\t# 进入容器后开启一个新的终端，可以在里面操作(常用)\n# docker attach\t\t\t# 进入容器正在执行的终端，不会启动新的进程\n```\n\n测试\n\n```shell\n[root@zhenghaoyun ~]$ docker exec -it be9f24ac2472 /bin/bash\n[root@be9f24ac2472 /]# exit\t\t#进入到了一个新的终端\nexit\n[root@zhenghaoyun ~]$ docker attach be9f24ac2472\n[root@be9f24ac2472 /]# \t\t\t#进入容器正在执行的终端\n```\n\n### 从容器内拷贝文件到主机上\n\n```shell\ndocker cp 容器id:/文件路径\t/目标主机路径 \t# 拷贝文件到主机\n# 拷贝是一个手动过程，未来我们使用\t-v\t卷的技术，可以实现\n```\n\n## 小结\n\n![image-20200622122410348](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200622122411.png)\n\n```\nattach \tAttach to a running container\t\t\t\t\t\t#当前sheil卜attach住按指定您行谎你\nbuild\tBuild an image from a Dockerfile\t\t\t\t\t#通过Dockerfile定制镜像\ncommit\tCreate a new image from a container changes\t\t\t#提交当前容器为新的镜像\ncp\tCopy files/folders from the containers filesystem to the host path\t#从容器中拷贝指定文件或者目录到宿主机中\ncreate\tCreate a new container\t\t\t\t\t\t\t\t#创建一个新的容器，同run，但不启动容器\ndiff\tInspect changes on a containers filesystem\t\t\t#查看docker容器变化\nevents\tGet real time events from the server\t\t\t\t#从docker 服务获取容器实时事件\nexec\tRun a command in an existing container \t\t\t\t#在已存在的容器上运行命令\nexport\tStream the contents of a container as a tar archive\t#导出容器的内容流作为一个tar归档文件[对应import ]\nhistory\tShow the history of an image\t\t\t\t\t\t#展示一个镜像形成历史\nimages\tList images\t\t\t\t\t\t\t\t\t\t\t#列出系统当前镜像\nimport\tCreate a new filesystem image from the contents of a tarball #从tar包中的内容创建一个新的文件系统映僧[对应export]\ninfo\tDisplay system-wide information\t\t\t\t\t\t#显示系统相关信息\ninspect Return 1ow-leve1 information on a container\t\t\t#查看容器详细信息\nki11\tKi11 a running container\t\t\t\t\t\t\t# ki11 指定docker 容器\nload\tLoad an image from a tar archive\t\t\t\t\t#从一个tar包中加载-一个镜像[对应save]\nlogin\tRegister or Login to the docker registry server\t\t#注册或者登录一个docker 源服务器\nlogout\tLog out fromLa Docker registry server\t\t\t\t#从当前Docker registry 退出\n1ogs\tFetch the 1ogs of a container\t\t\t\t\t\t#输出当村容器日志信息\nport\tLookup the public- facing port which is NAT-ed to PRIVATE PORT\t#查看映射端口对应的容器内郵源端\npause\tPause a11 processes within a container\t\t\t\t#暂停容器\nps\tList containers\t\t\t\t\t\t\t\t\t\t\t#列出容器列表\npull\tPull an image or a repository from the docker registry server #从docker境像源原 务器拉取指定镜像或者库镜像\npush\tPush an image or a repository to the docker registry server\t#推送指定镜像或者库镜像至docker源服务器\nrestart\tRestart a running container\t\t\t\t\t\t\t#重启运行的容器\nrm\tRemove one or more containers\t\t\t\t\t\t\t#移除一个或者多个容器\nrmi\tRemove one or more images\t\t\t\t\t\t\t\t#移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或-个强制删除]\nrun\tRun a command in a new container\t\t\t\t\t\t#创建一个新的容器并运行一个命令\nsave\tSave an image toa tar archive\t\t\t\t\t\t#保存一个镜像为一个tar包[对应load]\nsearch\tSearch for an image on the Docker Hub\t\t\t\t#在docker hub中搜索镜像\nstart\tStart a stopped containers\t\t\t\t\t\t\t#启动容器\nstop\tstop a running containers\t\t\t\t\t\t\t#停止容器\ntag\tTag an image into a reposi tory\t\t\t\t\t\t\t#给源中镜像打标签\ntop\tLookup the running processes of a container\t\t\t\t#查看容器中运行的进程信息\nunpause\tUnpause a paused container\t\t\t\t\t\t\t#取消暂停容器\nversion\tShow the docker vers ion information\t\t\t\t#查看docker 版本号\nwait\tB1ock until a container stops， then print its exit code # 截取容器停止时的退出状态值\n```\n\n## 练习\n\n### docker安装nginx\n\n```shell\n# 搜索镜像 search 建议去docker hub上搜索\n# 下载镜像 pull\n# 运行测试\n\n[root@zhenghaoyun ~]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nnginx               latest              602e111c06b6        3 weeks ago         127MB\ncentos              latest              470671670cac        3 months ago        237MB\n\n# -d 后台执行\n# --name 给容器命名\n# -p 宿主机端口:容器内部端口  (映射)\n[root@zhenghaoyun ~]# docker run -d --name nginx01 -p 3344:80 nginx\n83505a20805b0891e43e895097a7c84a1450a65b0d1b83e54880fafa7b8ef8a5\n[root@zhenghaoyun ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES\n83505a20805b        nginx               \"nginx -g 'daemon of…\"   9 seconds ago       Up 8 seconds        0.0.0.0:3344->80/tcp   nginx01\n\n# 进入容器\n[root@zhenghaoyun ~]# docker exec -it nginx01 /bin/bash\nroot@83505a20805b:/# ls\nbin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var\nroot@83505a20805b:/# whereis nginx\nnginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx\nroot@83505a20805b:/# cd /etc/nginx\nroot@83505a20805b:/etc/nginx# ls\nconf.d  fastcgi_params  koi-utf  koi-win  mime.types  modules  nginx.conf  scgi_params  uwsgi_params  win-utf\n\n# 退出容器\nroot@83505a20805b:/etc/nginx# exit\nexit\n[root@zhenghaoyun ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES\n83505a20805b        nginx               \"nginx -g 'daemon of…\"   8 minutes ago       Up 8 minutes        0.0.0.0:3344->80/tcp   nginx01\n\n# 停止容器运行\n[root@zhenghaoyun ~]# docker stop 83505a20805b\n83505a20805b\n```\n\n**如何理解端口暴露（宿主机端口：容器内部端口）？**\n\n<img src=\"https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200706120335.png\" alt=\"image-20200706120334523\" style=\"zoom:80%;\" />\n\n即通过宿主机的3344端口可以访问到nginx01容器内部的80端口\n\n> 问题：每次改动nginx配置文件，都需要进入容器内部，十分麻烦\n>\n> 解决：数据卷技术（后面会学习到）\n\n### docker安装tomcat\n\n1.官方的使用方式\n\n```shell\n# 官方的使用\ndocker run -it --rm tomcat:9.0\n\n# 我们之前的启动都是后台启动，停止了容器后，容器还是可以查到  而docker run -it --rm 一般用来测试，用完就删除了。\n```\n\n2.一般方式\n\n```shell\n# 下载再启动\ndocker pull tomcat\n\n# 启动运行\ndocker run -d -p 80:8080 --name tomcat01 tomcat\n\n# 下载的tomcat没有webapps，阿里云镜像默认是最小镜像，所有不必要的东西都会被剔除\n# 测试访问没有问题，但是404，因为webapps中没有项目，需要把webapps.dist下的东西拷贝到webapps中\n```\n\n\n\n### docker安装ES+Kibana\n\n>es 暴露的端口很多！\n>\n>es 十分耗内存！\n>\n>es 的数据一般要放置到安全的目录！使用挂载！\n\n1.下载并启动es\n\n```shell\n$ docker network create somenetwork\n$ docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearch:7.7.0\n```\n\n2.测试启动是否成功\n\n```shell\n$ curl localhost:9200\n```\n\n3.如果不成功，可能是内存不够，因为docker非常的耗内存。查看容器日志寻找错误原因。\n\n```shell\n$ docker logs -ft 8cb65d8a1627\n\n# 错误原因\n2020-05-27T10:13:57.587645924Z OpenJDK 64-Bit Server VM warning: INFO: os::commit_memory(0x000000008a660000， 1973026816， 0) failed; error='Cannot allocate memory' (errno=12)\n2020-05-27T10:13:57.587716355Z #\n2020-05-27T10:13:57.587722244Z # There is insufficient memory for the Java Runtime Environment to continue.\n2020-05-27T10:13:57.587725840Z # Native memory allocation (mmap) failed to map 1973026816 bytes for committing reserved memory.\n2020-05-27T10:13:57.587729419Z # An error report file with more information is saved as:\n2020-05-27T10:13:57.587732980Z # /tmp/hs_err_pid1.log\n```\n\n4.删除容器，增加对内存的限制。\n\n```shell\n#先删除容器\n[root@zhenghaoyun ~]# docker ps -a\nCONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS                     PORTS               NAMES\n67550d49d74e        elasticsearch:7.7.0   \"/tini -- /usr/local…\"   4 minutes ago       Exited (1) 4 minutes ago                       elasticsearch\n[root@zhenghaoyun ~]# docker rm 67550d49d74e\n67550d49d74e\n\n#启动容器，使用 -e ES_JAVA_OPTS=\"-Xms64m -Xmx512m\"增加了对内存的限制\n[root@zhenghaoyun ~]# docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms64m -Xmx512m\" elasticsearch:7.7.0\n1147b24344a98d01bb894d5b5cee7ab3867b7c8a0962fb778ae406de8e7aef31\n\n#查看容器是否启动\n[root@zhenghaoyun ~]# docker ps\nCONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                                            NAMES\n1147b24344a9        elasticsearch:7.7.0   \"/tini -- /usr/local…\"   5 seconds ago       Up 4 seconds        0.0.0.0:9200->9200/tcp， 0.0.0.0:9300->9300/tcp   elasticsearch\n```\n\n5.再次测试\n\n```java\n[root@zhenghaoyun ~]# curl localhost:9200\n{\n  \"name\" : \"1147b24344a9\"，\n  \"cluster_name\" : \"docker-cluster\"，\n  \"cluster_uuid\" : \"v4t6u-mdQ1iA5HvImqPn_Q\"，\n  \"version\" : {\n    \"number\" : \"7.7.0\"，\n    \"build_flavor\" : \"default\"，\n    \"build_type\" : \"docker\"，\n    \"build_hash\" : \"81a1e9eda8e6183f5237786246f6dced26a10eaf\"，\n    \"build_date\" : \"2020-05-12T02:01:37.602180Z\"，\n    \"build_snapshot\" : false，\n    \"lucene_version\" : \"8.5.1\"，\n    \"minimum_wire_compatibility_version\" : \"6.8.0\"，\n    \"minimum_index_compatibility_version\" : \"6.0.0-beta1\"\n  }，\n  \"tagline\" : \"You Know， for Search\"\n}\n```\n\n> 问题：不可以使用kibana直接连接ES，因为他们是互相隔离的，那么如何解决呢?\n\n![image-20200706120410384](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200706120410.png)\n\n# Docker可视化\n\n**potainer**是Docker图形化界面管理工具，提供了一个后台面板供我们操作。\n\n```sbell\ndocker run -d -p 8088:9000 \\\n--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer\n```\n\n访问测试: http://ip:8088/ (阿里云安全组需要开放8088端口)\n\n![image-20200706120428943](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200706120429.png)\n\n# Docker镜像详解\n\n## 镜像是什么\n\n镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量以及配置文件等。\n\n所有的应用，直接打包成docker镜像。就直接可以跑起来。\n\n如何得到镜像:\n\n- 从远程仓库下载\n- 朋友拷贝给你\n- 自己制作一个DockerFile\n\n## Docker镜像加载原理\n\n> UnionFS（联合文件系统）\n\nUnionFs（联合文件系统）：union文件系统（UnionFs）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件下。\n\nUnion文件系统是Docker镜像的基础，镜像可以通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像。\n\n特性：一次同时加载多个文件系统，但从外面看来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。\n\n> 镜像加载原理\n\nDocker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统称作UnionFs。\n\nBootfs（boot-file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs，这一层与我们典型的Linux/unix系统是一样的，包含boot加载器和内核，当boot加载完成之后整个内核就能在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。\n\nRootfs（root-file system），在bootfs之上，包含的就是典型Linux系统中的/dev、/proc、/bin、/etc等标准目录和文件，rootfs就是各种不同操作系统的发行版，比如Ubuntu，Centos等等。\n\n对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序就可以了（像我从docker上下载的centos只包含了一点点基本命令），因为底层直接用宿主机的内核，自己只需要提供rootfs就可以了，因此可见，对于不用的Linux发行版，bootfs基本是一致的，而rootfs会有差别，因此不同的发行版可以公用bootfs。\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200530235921.jpg)\n\n\n\n## 分层理解\n\n我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层一层的在下载!\n\n![image-20200706120450104](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200706120450.png)\n\n> Docker为什么采用分层结构呢？\n\n**共享资源！**\n\n多个镜像从相同的基础镜像构建而来，那么宿主机只需在磁盘上保存一份基础镜像，同时内存中也只需加载一份基础镜像就可以为所有容器服务了，并且镜像的每一层都可以被共享。\n\n![img](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200530235958.png)\n\n> 特点\n\nDocker镜像都是只读的，当容器启动时， 一个新的可写层被加载到镜像的顶部！\n\n这一层就是我们通常说的容器层，容器之下的都叫镜像层！\n\n## 镜像提交\n\n```shell\n# 提交容器成为一个新的副本\ndocker commit \n# 命令和git基本类似\ndocker commit -m=\"提交的描述信息\" -a=\"作者\" 容器id 目标镜像名:[TAG]\n```\n\n**实战**：做一个有webapps的tomcat镜像\n\n1. 启动一个默认的tomcat\n\n2. 发现这个默认的tomcat webapps下没有项目，官方的默认镜像下就是没有文件的\n\n3. 我们自己拷贝进去基本的文件，然后提交\n\n4. 将我们操作过的容器通过commit提交为新的镜像，我们以后就用我们修改过的镜像就可以，这就是我们一个修改过的镜像\n\n![image-20200706120512964](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200706120513.png)\n\n5. 以后就可以直接用这个镜像了\n\n# 容器数据卷\n\n## 什么是容器数据卷\n\n> 问题：如果数据都在容器中，如果我们将容器删除，数据就会丢失，希望可以做到容器删除，数据不丢失，做到数据持久化。\n\n容器之间可以有一个数据共享的技术，Docker容器中产生的数据，可以同步到本地。\n\n这就是卷技术，说白了就是目录的挂载，将我们容器内的目录，挂载到Linux上面。\n\n> 总结\n\n* 容器的持久化和同步操作\n* 容器间数据也是可以共享的\n\n## 使用容器数据卷\n\n```shell\ndocker run -it -v 主机目录：容器内目录\n```\n\n**测试**\n\n```shell\n[root@zhenghaoyun home]# mkdir test\n[root@zhenghaoyun home]# docker run -it -v /home/test:/home centos /bin/bash\n[root@d0686ec1c489 /]# cd /home\n[root@d0686ec1c489 home]# ls\n# 没有任何东西\n```\n\n```shell\n# 新开一个终端，创建test.java文件\n[root@zhenghaoyun home]# cd test\n[root@zhenghaoyun test]# touch test.java\n[root@zhenghaoyun test]# \n```\n\n```shell\n# 发现容器内也有test.java了\n[root@d0686ec1c489 home]# ls\ntest.java\n```\n\n使用`docker inspect`查看挂载信息\n\n```shell\n[root@zhenghaoyun test]# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\nd0686ec1c489        centos              \"/bin/bash\"         4 minutes ago       Up 4 minutes                            silly_kepler\n[root@zhenghaoyun test]# docker inspect d0686ec1c489\n```\n\n慢慢翻可以看到以下信息：\n\n![image-20200527225426184](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200528153813.png)\n\n可以看到成功绑定了\n\n之后不管是修改宿主机内文件还是修改容器内文件，都会自动同步。\n\n## 实战：安装MySQL\n\n> 实现MySQL的数据持久化问题\n\n```shell\n# 获取镜像\n[root@zhenghaoyun /]# docker pull mysql:5.7\n\n# 运行容器，需要做数据挂载 . 安装启动mysql时，一定要有密码\n# 官方运行实例\n$ docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag\n\n# 启动mysql\n-d 后台运行\n-p 映射端口\n-v 卷挂载\n-e 环境配置\n--name 容器名字\n[root@zhenghaoyun /]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name=mysql01 mysql:5.7 \n\n# 启动成功之后，在本地使用Navicat连接测试一下\n# Navicat连接到服务器的3310 --- 3310与容器内的3306映射，连接成功\n\n# 在本地测试创建一个数据库，查看一下我们映射的路径是否ok\n# 成功\n```\n\n![image-20200528155817964](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200528155818.png)\n\n如果连接失败，查看下安全组是否开放端口。\n\n当mysql容器删掉的时候，宿主机的数据库文件仍然存在，实现了数据持久化，数据不会丢失。\n\n## 具名挂载和匿名挂载\n\n### 匿名挂载\n\n挂载的时候可以不指定主机目录\n\n```shell\n# 匿名挂载\n# -v 容器内路径 \t-P 随机映射端口\n[root@zhenghaoyun ~]#  docker run -d -P --name nginx01 -v /etc/nginx nginx\na3aea776a59f7568950d5eb822e65b32a6f9cd42e2c985a58c31d4dfec3e00d4\n\n# 查看所有卷的情况\n[root@zhenghaoyun ~]# docker volume ls\nDRIVER              VOLUME NAME\nlocal               3fbc02b34b7db4bca1558728d8edea592541e748f6f898464a465331000e7c04              \n\n# 这里发现，这种就是就是匿名挂载，我们在-v的时候，只写了内部路径，没有写容器外的路径\n# 会自动创建一个名字由字符和数字组成的数据卷\n# 通过docker volume ls可以查看数据卷列表\n```\n\n### 具名挂载\n\n挂载的时候创建一个自定义名称的数据卷\n\n```shell\n# 将/etc/nginx nginx挂载到juming-nginx这个数据卷上\n[root@zhenghaoyun ~]# docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx\n79a2190e4658af610cf76635980f7176e1daf443a43f612fb418ca559880891f\n\n[root@zhenghaoyun ~]# docker volume ls\nDRIVER              VOLUME NAME\nlocal               juming-nginx\n\n#查看下这个卷的具体信息\n[root@zhenghaoyun ~]# docker volume inspect juming-nginx\n[\n    {\n        \"CreatedAt\": \"2020-05-28T16:25:24+08:00\"，\n        \"Driver\": \"local\"，\n        \"Labels\": null，\n        \"Mountpoint\": \"/var/lib/docker/volumes/juming-nginx/_data\"，\n        \"Name\": \"juming-nginx\"，\n        \"Options\": null，\n        \"Scope\": \"local\"\n    }\n]\n\n```\n\n所有的docker容器内的卷，没有指定目录的情况下都是在`/var/lib/docker/volumes/xxx/_data`。\n\n我们通过具名挂载可以方便的找到我们的一个卷，大多数情况下我们使用**具名挂载**。\n\n> 如何确定是具名挂载还是匿名挂载\n\n* -v 容器内路径\t \t\t \t# 匿名挂载\n* -v 卷名:容器内路径\t\t\t# 具名挂载\n* -v /宿主机路径:容器内路径   # 指定路径挂载，一般是/开头的，指绝对路径\n\n> 拓展\n\n```shell\n# 通过 -v 容器内路径:ro或者rw 改变读写权限\nro\t\treadonly\t# 只读\nrw\t\treadwrite\t# 可读可写\n\n# 一旦设置了这个容器权限，容器对我们挂载出来的内容就限定了\ndocker run -d -P --name=nginx02 -v juming-nginx:/etc/nginx:ro nginx\ndocker run -d -P --name=nginx02 -v juming-nginx:/etc/nginx:rw nginx\n\n# 只要看到ro，就说明这个路径只能通过宿主机来操作，容器内无法操作\n# 默认rw\n```\n\n## 初识DockerFile\n\nDockerFile就是用来构建Docker镜像的构建文件，它其实就是一个命令脚本。\n\n通过这个脚本可以生成镜像，镜像是一层一层的，脚本一个个的命令，每个命令都是一层。\n\n**编写DokcerFile**\n\n创建一个dockerfile文件，名字可以随意，建议还是dockerfile。\n\n```shell\nFROM centos\n\n# 在容器中创建两个数据卷目录，这是匿名挂载，在宿主机上通过docker inspect 容器id 可以查看到这两个目录挂载在哪里。\nVOLUME [\"volume01\"，\"volume02\"]\n\nCMD echo \"----end----\"\nCMD /bin/bash\n```\n\n**通过DockerFile生成镜像**\n\n`zhy/centos:1.0`为生成的`镜像名:tag`\n\n```shell\ndocker build -f /home/docker-test-volume/dockerfile -t zhy/centos:1.0 .\n```\n\n通过这种方式就生成了一个镜像，通过这个镜像生成一个容器的时候，这个容器的挂载和我们再DockerFile文件内设置的是一样的。volume01和volume01匿名挂载的时候，挂载在`/var/lib/docker/volumes/xxx/_data`。\n\n**启动自己的镜像**\n\n```shell\n[root@zhenghaoyun docker-test-volume]# docker run -it zhy/centos\nUnable to find image 'zhy/centos:latest' locally\n^Z\n[1]+  Stopped                 docker run -it zhy/centos\n[root@zhenghaoyun docker-test-volume]# docker run -it e53d4f7b84cd\n[root@cc887d7eecc0 /]# ls\nbin  home   lost+found\topt   run   sys  var\ndev  lib    media\tproc  sbin  tmp  volume01\netc  lib64  mnt\t\troot  srv   usr  volume02\n```\n\n**查看挂载目录**\n\n```shell\n$ docker inpect 容器id\n\n# 查看mounts项可以看到挂载信息\n\"Mounts\": [\n            {\n                \"Type\": \"volume\"，\n                \"Name\": \"aab60727df7805eb76d78f0ddfdc0fa8cab7d16d5090d85ca0dcea28419742b8\"，\n                \"Source\": \"/var/lib/docker/volumes/aab60727df7805eb76d78f0ddfdc0fa8cab7d16d5090d85ca0dcea28419742b8/_data\"，\n                \"Destination\": \"volume01\"，\n                \"Driver\": \"local\"，\n                \"Mode\": \"\"，\n                \"RW\": true，\n                \"Propagation\": \"\"\n            }，\n            {\n                \"Type\": \"volume\"，\n                \"Name\": \"a99afe0b7a935a8f0834e294df7e4b9506d9ba6c637d9b3f19a45fea1c9d448a\"，\n                \"Source\": \"/var/lib/docker/volumes/a99afe0b7a935a8f0834e294df7e4b9506d9ba6c637d9b3f19a45fea1c9d448a/_data\"，\n                \"Destination\": \"volume02\"，\n                \"Driver\": \"local\"，\n                \"Mode\": \"\"，\n                \"RW\": true，\n                \"Propagation\": \"\"\n            }\n        ]\n```\n\n\n\n## 数据卷容器\n\n如果用户需要在容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器，数据卷容器其实是一个普通的容器，专门用来提供数据卷供其它容器挂载。\n\n![image-20200706120536765](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200706120537.png)\n\n**启动三个容器**\n\n```shell\ndocker run -it --name=docker01 zhy/centos:1.0\ndocker run -it --name docker02 --volumes-from docker01 zhy/centos:1.0\ndocker run -it --name docker03 --volumes-from docker02 zhy/centos:1.0\n```\n\n**分别进入docker01、docker02、docker03后发现都含有volumes01、volumes02这两个数据卷。**\n\n```shell\n[root@8fff8e978165 /]# ls\nbin  home   lost+found\topt   run   sys  var\ndev  lib    media\tproc  sbin  tmp  volume01\netc  lib64  mnt\t\troot  srv   usr  volume02\n```\n\n**进入docker01的volume01后创建文件test.java**\n\n```shell\n[root@zhenghaoyun _data]# docker attach docker01\n[root@e73760697aea /]# ls\nbin  home   lost+found\topt   run   sys  var\ndev  lib    media\tproc  sbin  tmp  volume01\netc  lib64  mnt\t\troot  srv   usr  volume02\n[root@e73760697aea /]# cd volume01\n[root@e73760697aea volume01]# ls\n[root@e73760697aea volume01]# touch test.java\n```\n\n**然后再进docker02和docker03发现docker01创建的文件同步到了docker02和docker03上**\n\n```shell\n[root@zhenghaoyun _data]# docker attach docker02\n[root@8fff8e978165 /]# cd volume01\n[root@8fff8e978165 volume01]# ls\ntest.java\n[root@8fff8e978165 volume01]# read escape sequence\n[root@zhenghaoyun _data]# docker attach docker03\n[root@26c6fd5d06e9 /]# cd volume01\n[root@26c6fd5d06e9 volume01]# ls\ntest.java\n```\n\n**删掉容器docker02后，在docker01的volume01中新增文件test2.java**\n\n测试结果发现docker03中也有test2.java\n\n说明删掉了一个容器，剩余的容器仍然能实现数据共享！\n\n因为docker的数据共享是基于拷贝机制的！\n\n**结论:**\n\n容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止，但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的。\n\n# DockerFile\n\ndockerfile 是用来构建docker镜像的文件，它是一个命令参数脚本。\n\n## 构建步骤\n\n1. 编写一个dockerfile文件\n2. docker build 构建成为一个镜像\n3. docker run 运行镜像\n4. docker push 发布镜像(DockerHub，阿里云镜像仓库)\n\n## **构建过程**\n\n**Dockerfile基础知识**\n\n1. 每个保留关键字(指令)都必须是大写字母\n2. 从上到下顺序执行\n3. #表示注释\n4. 每一个指令都会创建一个新的镜像层，并提交\n\n![image-20200516233824923](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200531000124.png)\n\ndockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单。 \n\nDocker镜像逐渐成为了企业交付的标准，必须要掌握。\n\n## 指令\n\n### 常用指令\n\n```shell\nFROM \t\t\t\t# 基础镜像，一切从这里开始构建\nMAINTAINER\t\t\t# 镜像是谁写的，姓名+邮箱\nRUN\t\t\t\t\t# 镜像构建的时候需要运行的命令\nADD\t\t\t\t\t# 步骤: tomcat镜像，这个tomcat压缩包，添加内容\nWORKDIR\t\t\t\t# 镜像的工作目录\nVOLUME\t\t\t\t# 挂载的目录\nEXPOSE\t\t\t\t# 暴露端口配置\t\nCMD\t\t\t\t\t# 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代\nENTRYPOINT\t\t\t# 指定这个容器启动的时候要运行的命令，可以追加命令而CMD不可以追加\nONBUILD\t\t\t\t# 当构建一个被继承 DockerFile 这个时候就会运行ONBUILD指令，触发指令\nCOPY\t\t\t\t# 类似ADD\t将我们的文件拷贝到镜像中\nENV\t\t\t\t\t# 构建的时候设置环境变量\n```\n\n![image-20200516234710747](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200531000229.png)\n\n### CMD和ENTRYPOINT的区别\n\n```shell\nCMD\t\t\t\t\t# 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代\nENTRYPOINT\t\t\t# 指定这个容器启动的时候要运行的命令，可以追加命令\n```\n\n**测试CMD**\n\n```shell\n# 编写dockerfile文件\n[root@zhenghaoyun dockerfile]# vim dockerfile-cmd-test\nFROM centos\nCMD [\"ls\"，\"-a\"]\n\n# 构建镜像\n[root@zhenghaoyun dockerfile]# docker build -f dockerfile-cmd-test -t cmdtest .\n\n# run运行，发现我们的ls -a生效\n[root@zhenghaoyun dockerfile]# docker run cmdtest\n.\n..\n.dockerenv\nbin\ndev\netc\nhome\nlib\nlib64\n\n# 想追加一个命令 -l 发现报错 (ls -al)\n[root@zhenghaoyun dockerfile]# docker run cmdtest -l\ndocker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused \"exec: \\\"-l\\\": executable file not found in $PATH\": unknown.\nERRO[0000] error waiting for container: context canceled \n\n# CMD的情况下 -l 替换了CMD [\"ls\"，\"-a\"]\t\t-l不是命令所以就会报错\n```\n\n**测试ENTRYPOINT**\n\n```shell\n[root@zhenghaoyun dockerfile]# vim dockerfile-cmd-entrypoint\nFROM centos\nENTRYPOINT [\"ls\"，\"-a\"]\n\n[root@zhenghaoyun dockerfile]# docker build -f dockerfile-cmd-entrypoint -t entrypoint-test .\n[root@zhenghaoyun dockerfile]# docker run entrypoint-test\n.\n..\n.dockerenv\nbin\ndev\netc\nhome\nlib\nlib64\nlost+found\n\n# 我们的追加命令，是直接拼接在我们的ENTRYPOINT命令的后面\n[root@zhenghaoyun dockerfile]# docker run entrypoint-test -l\ntotal 56\ndrwxr-xr-x   1 root root 4096 May 17 02:13 .\ndrwxr-xr-x   1 root root 4096 May 17 02:13 ..\n-rwxr-xr-x   1 root root    0 May 17 02:13 .dockerenv\nlrwxrwxrwx   1 root root    7 May 11  2019 bin -> usr/bin\ndrwxr-xr-x   5 root root  340 May 17 02:13 dev\ndrwxr-xr-x   1 root root 4096 May 17 02:13 etc\ndrwxr-xr-x   2 root root 4096 May 11  2019 home\nlrwxrwxrwx   1 root root    7 May 11  2019 lib -> usr/lib\nlrwxrwxrwx   1 root root    9 May 11  2019 lib64 -> usr/lib64\ndrwx------   2 root root 4096 Jan 13 21:48 lost+found\n```\n\nDockerfile中很多命令都十分的相似，我们需要了解他们的区别，最好的学习就是对比然后测试。\n\n\n## 实战\n\n`FROM scratch`\n\nDockerhub中99%的镜像都是从这个基础镜像过来的，然后根据需要的软件和配置来进行的构建。\n\n![image-20200706120602087](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200706120602.png)\n\n### 创建一个自己的centOS\n\n```shell\n# 编写dockerfile文件\n[root@zhenghaoyun ~]# vim mydockerfile-centos\n[root@zhenghaoyun ~]# cat mydockerfile-centos \nFROM centos\nMAINTAINER zhy<123456@qq.com>\n\nENV MYPATH /usr/local\nWORKDIR $MYPATH\n\nRUN yum -y install vim\nRUN yum -y install net-tools\n\nEXPOSE 80\n\nCMD $MYPATH\nCMD \"----end----\"\nCMD /bin/bash\n\n# 开始构建\n[root@zhenghaoyun ~]# docker build -f mydockerfile-centos -t mycentos:0.1 .\nSending build context to Docker daemon  231.5MB\nStep 1/10 : FROM centos\n ---> 470671670cac\nStep 2/10 : MAINTAINER zhy<123456@qq.com>\n ---> Running in 81104dc1bf58\nRemoving intermediate container 81104dc1bf58\n ---> 5083be5d9e3d\n...\nRemoving intermediate container 1dd935006a10\n ---> 863e1e9a99df\nSuccessfully built 863e1e9a99df\nSuccessfully tagged mycentos:0.1\n\n# 查看我们自己制作的镜像\n[root@zhenghaoyun ~]# docker images\nREPOSITORY            TAG                 IMAGE ID            CREATED             SIZE\nmycentos              0.1                 863e1e9a99df        29 seconds ago      321MB\nzhy/centos            1.0                 e53d4f7b84cd        About an hour ago   237MB\nmysql                 5.7                 a4fdfd462add        8 days ago          448MB\nnginx                 latest              9beeba249f3e        13 days ago         127MB\nelasticsearch         7.7.0               7ec4f35ab452        2 weeks ago         757MB\nportainer/portainer   latest              2869fc110bf7        2 months ago        78.6MB\ncentos                latest              470671670cac        4 months ago        237MB\n\n# 运行镜像\n[root@zhenghaoyun ~]# docker run -it mycentos:0.1\n# 查看工作目录\n[root@222c4f170311 local]# pwd\n/usr/local\n\n```\n\n通过`docker history`查看镜像历史\n\n```shell\n[root@zhenghaoyun ~]# docker history mycentos:0.1\nIMAGE               CREATED             CREATED BY                                      SIZE                COMMENT\n863e1e9a99df        4 minutes ago       /bin/sh -c #(nop)  CMD [\"/bin/sh\" \"-c\" \"/bin…   0B                  \n3630bf4d4b65        4 minutes ago       /bin/sh -c #(nop)  CMD [\"/bin/sh\" \"-c\" \"\\\"--…   0B                  \nbd395ab3f210        4 minutes ago       /bin/sh -c #(nop)  CMD [\"/bin/sh\" \"-c\" \"$MYP…   0B                  \n539ddae94271        4 minutes ago       /bin/sh -c #(nop)  EXPOSE 80                    0B                  \na44756b81bb3        4 minutes ago       /bin/sh -c yum -y install net-tools             24.1MB              \n9125de5f6a9b        4 minutes ago       /bin/sh -c yum -y install vim                   59.8MB              \nc44e45342f97        5 minutes ago       /bin/sh -c #(nop) WORKDIR /usr/local            0B                  \n1b747b2ad94b        5 minutes ago       /bin/sh -c #(nop)  ENV MYPATH=/usr/local        0B                  \n5083be5d9e3d        5 minutes ago       /bin/sh -c #(nop)  MAINTAINER zhy<123456@qq.…   0B                  \n470671670cac        4 months ago        /bin/sh -c #(nop)  CMD [\"/bin/bash\"]            0B                  \n<missing>           4 months ago        /bin/sh -c #(nop)  LABEL org.label-schema.sc…   0B                  \n<missing>           4 months ago        /bin/sh -c #(nop) ADD file:aa54047c80ba30064…   237MB   \n```\n\n### 制作一个tomcat镜像\n\n```shell\n# Dockerfile内容\nFROM centos\nMAINTAINER zhy<123456@qq.com>\n\nCOPY readme.txt /usr/local/readme.txt\n\nADD jdk-8u152-linux-x64.tar.gz /usr/local/\nADD apache-tomcat-8.5.24.tar.gz /usr/local/\n\nRUN yum -y install vim\n\nENV MYPATH /usr/local\nWORKDIR $MYPATH\n\nENV JAVA_HOME /usr/local/jdk1.8.0_152\nENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nENV CATALINA_HOME /usr/local/apache-tomcat-8.5.24\nENV CATALINA_BASH /usr/local/apache-tomcat-8.5.24\nENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin\n\nEXPOSE 8080\n\nCMD /usr/local/apache-tomcat-8.5.24/bin/startup.sh && tail -F /usr/local/apache-tomcat-8.5.24/bin/logs/catalina.out\n\n# 构建镜像\n$ docker build -t diytomcat . \n\n# 启动镜像\n$ docker run -d -p 3030:8080 --name zhytomcat\n-v /root/dockertest/test:/usr/local/apache-tomcat-8.5.24/webapps/test \n-v /root/dockertest/tomcatlogs/:/usr/local/apache-tomcat-8.5.24/logs diytomcat\n```\n\n# 发布自己的镜像\n\n## 发布到DockerHub\n\n1. 去[DockerHub](https://hub.docker.com/ )注册自己的账号\n2. 确定这个账号可以登录\n3. 在我们服务器上提交自己的镜像\n\n```\n# 登录dockerhub\n[root@zhenghaoyun ~]# docker login -u zhenghaoyun\nPassword: \nWARNING! Your password will be stored unencrypted in /root/.docker/config.json.\nConfigure a credential helper to remove this warning. See\nhttps://docs.docker.com/engine/reference/commandline/login/#credentials-store\n\nLogin Succeeded\n\n# 发布镜像前最好规范镜像名，如增加自己的姓名和版本号。\n[root@zhenghaoyun ~]# docker tag diytomcat zhy/diytomcat:1.0\n\n\n# push，自己发布的镜像尽量带上版本号\n[root@zhenghaoyun ~]# docker push zhy/diytomcat:1.0\n```\n\n提交的时候也是按照镜像的层级来提交的。\n\n## 发布到阿里云镜像\n\n1. 登录阿里云\n2. 找到容器镜像服务\n3. 创建命名空间![image-20200706120638375](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200706120638.png)\n4. 创建仓库![image-20200706120657984](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200706120658.png)\n5. 参考阿里云教程\n\n![image-20200706120717214](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200706120717.png)\n\n6. 推送示例\n\n![image-20200706120734404](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200706120734.png)\n\n## 小结\n\n![image-20200706120758027](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200706120758.png)\n\n# Docker网络\n\n## 理解Docker0\n\n```shell\n[root@zhenghaoyun ~]# ip addr\n\n# 本机回环地址\n1: lo: <LOOPBACK，UP，LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n       \n# 阿里云内网地址\n2: eth0: <BROADCAST，MULTICAST，UP，LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\n    link/ether 00:16:3e:2c:49:f0 brd ff:ff:ff:ff:ff:ff\n    inet 172.17.109.162/20 brd 172.17.111.255 scope global dynamic eth0\n       valid_lft 311911158sec preferred_lft 311911158sec\n       \n# docker0地址\n3: docker0: <NO-CARRIER，BROADCAST，MULTICAST，UP> mtu 1500 qdisc noqueue state DOWN group default \n    link/ether 02:42:d2:e2:8f:bc brd ff:ff:ff:ff:ff:ff\n    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker0\n       valid_lft forever preferred_lft forever\n74: br-fc3b359394e5: <NO-CARRIER，BROADCAST，MULTICAST，UP> mtu 1500 qdisc noqueue state DOWN group default \n    link/ether 02:42:9e:68:59:59 brd ff:ff:ff:ff:ff:ff\n    inet 172.19.0.1/16 brd 172.19.255.255 scope global br-fc3b359394e5\n       valid_lft forever preferred_lft forever\n\n```\n\n> 问题：docker是如何处理容器网络访问的\n\n我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要安装了docker，就会有一个网卡docker0\t桥接模式，使用的技术是veth-pair 技术。\n\n```shell\n# 启动一个容器tomcat01\n[root@zhenghaoyun ~]# docker run -d -P --name tomcat01 tomcat\n8d31b16a8cc1361dbd2b9117de424063ee1831d6c717aee75f2f54ae3aa45cb8\n\n# 查看容器内ip，注意到有个119: eth0@if120\n[root@zhenghaoyun ~]# docker exec -it tomcat01 ip addr\n1: lo: <LOOPBACK，UP，LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n119: eth0@if120: <BROADCAST，MULTICAST，UP，LOWER_UP> mtu 1500 qdisc noqueue state UP group default \n    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0\n    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0\n       valid_lft forever preferred_lft forever\n       \n # 尝试在容器外ping tomcat01，会发现可以ping通\n[root@zhenghaoyun ~]# ping 172.18.0.2\nPING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.\n64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.079 ms\n64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.057 ms\n64 bytes from 172.18.0.2: icmp_seq=3 ttl=64 time=0.054 ms\n^Z\n[1]+  Stopped                 ping 172.18.0.2\n\n# 在容器外再次测试ip addr，会发现又多了一对网卡120: veth349e841@if119，和之前tomcat01内的是惊人的相似119: eth0@if120\n[root@zhenghaoyun ~]#  ip addr\n1: lo: <LOOPBACK，UP，LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n2: eth0: <BROADCAST，MULTICAST，UP，LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\n    link/ether 00:16:3e:2c:49:f0 brd ff:ff:ff:ff:ff:ff\n    inet 172.17.109.162/20 brd 172.17.111.255 scope global dynamic eth0\n       valid_lft 311910065sec preferred_lft 311910065sec\n3: docker0: <BROADCAST，MULTICAST，UP，LOWER_UP> mtu 1500 qdisc noqueue state UP group default \n    link/ether 02:42:d2:e2:8f:bc brd ff:ff:ff:ff:ff:ff\n    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker0\n       valid_lft forever preferred_lft forever\n74: br-fc3b359394e5: <NO-CARRIER，BROADCAST，MULTICAST，UP> mtu 1500 qdisc noqueue state DOWN group default \n    link/ether 02:42:9e:68:59:59 brd ff:ff:ff:ff:ff:ff\n    inet 172.19.0.1/16 brd 172.19.255.255 scope global br-fc3b359394e5\n       valid_lft forever preferred_lft forever\n120: veth349e841@if119: <BROADCAST，MULTICAST，UP，LOWER_UP> mtu 1500 qdisc noqueue master docker0 state UP group default \n    link/ether da:41:5f:db:1e:89 brd ff:ff:ff:ff:ff:ff link-netnsid 0\n\n```\n\n> 我们发现这个容器带来的网卡都是一对一对的\n>\n> veth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一段连着协议，一段彼此相连\n>\n> 正因为有了这个特性，veth-pair 充当一个桥梁，连接各种虚拟网络设备的\n>\n> OpenStac ，Docker容器之间的连接，OVS的连接，都是使用veth-pair 技术\n\n再来测试一下tomcat01和tomcat02是否可以ping通\n\n```\nroot@zhenghaoyun ~]# docker exec -it tomcat02 ping 172.18.0.2\n\n# 结论: 容器和容器之间是可以互相ping通的\n```\n\n![image-20200706120820087](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200706120820.png)\n\n<center>网络模型图</center>\n\n### **结论**\n\ntomcat01和tomcat02是共用的一个路由器，docker0\n\n所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用ip。\n\nDocker使用的是Linux的桥接，宿主机中是一个Docker容器的网桥docker0。\n\n![image-20200706120841594](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200706120842.png)\n\nDocker中的所有的网络接口都是虚拟的，虚拟的转发效率高。(内网传递文件)\n\n只要容器删除，对应的一对网桥就没有了。\n\n## --link\n\n> 思考一个场景，我们编写了一个微服务，database url=ip:，项目不重启，数据库ip换掉了，我们希望可以处理这个问题，可以通过名字来进行访问容器。\n\n```shell\n# 通过名字无法ping\n[root@zhenghaoyun ~]# docker exec -it tomcat01 ping tomcat02\nping: tomcat02: Name or service not known\n\n# 如何可以解决呢\n# 通过--link就可以解决网络连通问题\n[root@zhenghaoyun ~]# docker run -d -P --name tomcat03 --link tomcat02 tomcat\n434fab3886a930372a75935b23abb2da4df07d1d860143c258769961e8b93e5a\n[root@zhenghaoyun ~]# docker exec -it tomcat03 ping tomcat02                  \nPING tomcat02 (172.17.0.3) 56(84) bytes of data.\n64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.070 ms\n64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.054 ms\n64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.074 ms\n\n# 反向可以ping通吗? 不行，因为没有配置\n[root@zhenghaoyun ~]# docker exec -it tomcat02 ping tomcat03 \nping: tomcat03: Name or service not known\n```\n\n> 查看tomcat03的hosts配置\n\n```shell\n# 查看hosts配置，在这里发现\n[root@zhenghaoyun ~]# docker exec -it tomcat03 cat /etc/hosts\n127.0.0.1       localhost\n::1     localhost ip6-localhost ip6-loopback\nfe00::0 ip6-localnet\nff00::0 ip6-mcastprefix\nff02::1 ip6-allnodes\nff02::2 ip6-allrouters\n172.17.0.3      tomcat02 a8be6dc01d63\n172.17.0.4      434fab3886a9\n```\n\n> 本质探究\n\n--link就是我们在hosts配置中增加了一个172.17.0.3，tomcat02 a8be6dc01d63。\n\n> 注意\n\n我们现在用Docker已经不建议使用`--link`了\n\n我们需要使用更高级的方式：**自定义网络**，不使用docker0。\n\ndocker0问题：它不支持容器名连接访问。\n\n## 自定义网络\n\n> 查看所有的docker网络\n\n```shell\n[root@zhenghaoyun ~]# docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\ne1e8a026e40f        bridge              bridge              local\nf2b909434e48        host                host                local\n255e387a2a2e        none                null                local\nfc3b359394e5        somenetwork         bridge              local\n```\n\n> 网络模式\n\n* bridge：桥接docker(默认，自己创建也是用bridge模式)\n\n* none：不配置网络\n\n* host：和宿主机共享网络\n\n* container：容器网络连通(用得少，局限很大)\n\n通常情况下，我们直接启动容器时，有个默认选项`--net bridge`，而这个就是我们的docker0。\n\n```\n# 这两者是等价的\ndocker run -d -P --name tomcat01 tomcat\ndocker run -d -P --name tomcat01 --net bridge tomcat \n```\n\n现在开始自定义一个网络吧\n\n```shell\n# docker0特点: 默认，域名不能访问，\t\t--link可以打通连接\n\n# 我们可以自定义一个网络\n# --driver bridge\n# --subnet 192.168.0.0/16 \t范围 192.168.0.2~192.168.255.255\n# --gateway 192.168.0.1\n\n[root@zhenghaoyun ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet\n837a94ff18774c323b48011a41112fcf8e4a34b13f6b5557fbf3bdfe01675fba\n[root@zhenghaoyun ~]# docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\ne1e8a026e40f        bridge              bridge              local\nf2b909434e48        host                host                local\n837a94ff1877        mynet               bridge              local\n255e387a2a2e        none                null                local\nfc3b359394e5        somenetwork         bridge              local\n[root@zhenghaoyun ~]# docker network inspect 837a94ff1877\n...\n            \"Config\": [\n                {\n                \n                \t# 看这里，和我们自定义的一样！\n                \n                    \"Subnet\": \"192.168.0.0/16\"，\n                    \"Gateway\": \"192.168.0.1\"\n                }\n            ]\n        }，\n...\n]\n\n```\n\n**测试ping连接**\n\n```shel\n# 再次测试ping连接\n[root@zhenghaoyun ~]# docker exec -it tomcat-net-01 ping 192.168.0.3\nPING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.\n64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.110 ms\n64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.064 ms\n\n# 现在不适用--link也可以ping名字了\n[root@zhenghaoyun ~]# docker exec -it tomcat-net-01 ping tomcat-net-02\nPING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.\n64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.036 ms\n64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.065 ms\n```\n\n我们自定义的网络docker都已经帮我们维护好了对应的关系，推荐我们平时这样使用网络。\n\n好处:\n\n有两个集群分别是redis和mysql，不同的集群使用不同的网络，保证集群是安全和健康的。\n\n## 网路连通\n\n通过以上的步骤，我们现在有两个网段了，一个是docker0和mynet，docker0和mynet内的容器是不能网络连通的，如何去解决这一问题？\n\n![image-20200530221341088](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200530221342.png)\n\n![image-20200530221425841](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200530221427.png)\n\n```shell\n# 测试打通tomcat01 - mynet\n[root@zhenghaoyun ~]# docker network connect mynet tomcat01\n\n# 连通之后就是将tomcat01 放到了mynet网络下\n\n# 一个容器两个ip地址\t\n# 好比 阿里云服务:公网ip 私网ip\n```\n\n```shel\n# tomcat01可以ping通\n[root@zhenghaoyun ~]# docker exec -it tomcat01 ping tomcat-net-01\nPING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.\n64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.081 ms\n64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.070 ms\n\n# tomcat02依旧打不通\n[root@zhenghaoyun ~]# docker exec -it tomcat02 ping tomcat-net-01 \nping: tomcat-net-01: Name or service not known\n```\n\n**结论**\n\n假设要跨网络操作别人，就需要使用docker network connect 连通。\n\n## 实战：部署redis集群\n\n场景：r-m2突然挂掉了\n\n![image-20200706120905672](https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200706120906.png)\n\n```shell\n# 创建网卡\ndocker network create redis --subnet 172.38.0.0/16\n\n# 通过脚本创建六个redis配置\nfor port in $(seq 1 6); \\\ndo \\\nmkdir -p /mydata/redis/node-${port}/conf\ntouch /mydata/redis/node-${port}/conf/redis.conf\ncat << EOF >/mydata/redis/node-${port}/conf/redis.conf\nport 6379\nbind 0.0.0.0\ncluster-enabled yes \ncluster-config-file nodes.conf\ncluster-node-timeout 5000\ncluster-announce-ip 172.38.0.1${port}\ncluster-announce-port 6379\ncluster-announce-bus-port 16379\nappendonly yes\nEOF\ndone\n\ndocker run -p 637${port}:6379 -p 1637${port}:16379 --name redis-${port} \\\n-v /mydata/redis/node-${port}/data:/data \\\n-v /mydata/redis/node-${port}/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.1${port} redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf; \\\n\ndocker run -p 6376:6379 -p 16376:16379 --name redis-6 \\\n-v /mydata/redis/node-6/data:/data \\\n-v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n# 创建集群\n[root@zhenghaoyun /]# docker exec -it redis-1 /bin/sh\n\n/data # redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1\n>>> Performing hash slots allocation on 6 nodes...\nMaster[0] -> Slots 0 - 5460\nMaster[1] -> Slots 5461 - 10922\nMaster[2] -> Slots 10923 - 16383\nAdding replica 172.38.0.15:6379 to 172.38.0.11:6379\nAdding replica 172.38.0.16:6379 to 172.38.0.12:6379\nAdding replica 172.38.0.14:6379 to 172.38.0.13:6379\nM: bc3aff4049d9610330f51b58871769f8ac827c63 172.38.0.11:6379\n   slots:[0-5460] (5461 slots) master\nM: 6af312198899e48ff01b1ee4a4158f7510e12d0b 172.38.0.12:6379\n   slots:[5461-10922] (5462 slots) master\nM: c4f207bf3beb7ff1ac6142ab7b40166d57d34463 172.38.0.13:6379\n   slots:[10923-16383] (5461 slots) master\nS: b2b335eb0306a36d23c9962b09f1ceed720200cc 172.38.0.14:6379\n   replicates c4f207bf3beb7ff1ac6142ab7b40166d57d34463\nS: c5bbf3ef339568f7d63000855d42ef366e52aba7 172.38.0.15:6379\n   replicates bc3aff4049d9610330f51b58871769f8ac827c63\nS: 5768864a0132bbc9139f16d1cf21b20868f66511 172.38.0.16:6379\n   replicates 6af312198899e48ff01b1ee4a4158f7510e12d0b\nCan I set the above configuration? (type 'yes' to accept): yes\n>>> Nodes configuration updated\n>>> Assign a different config epoch to each node\n>>> Sending CLUSTER MEET messages to join the cluster\nWaiting for the cluster to join\n..\n>>> Performing Cluster Check (using node 172.38.0.11:6379)\nM: bc3aff4049d9610330f51b58871769f8ac827c63 172.38.0.11:6379\n   slots:[0-5460] (5461 slots) master\n   1 additional replica(s)\nM: 6af312198899e48ff01b1ee4a4158f7510e12d0b 172.38.0.12:6379\n   slots:[5461-10922] (5462 slots) master\n   1 additional replica(s)\nS: b2b335eb0306a36d23c9962b09f1ceed720200cc 172.38.0.14:6379\n   slots: (0 slots) slave\n   replicates c4f207bf3beb7ff1ac6142ab7b40166d57d34463\nS: 5768864a0132bbc9139f16d1cf21b20868f66511 172.38.0.16:6379\n   slots: (0 slots) slave\n   replicates 6af312198899e48ff01b1ee4a4158f7510e12d0b\nS: c5bbf3ef339568f7d63000855d42ef366e52aba7 172.38.0.15:6379\n   slots: (0 slots) slave\n   replicates bc3aff4049d9610330f51b58871769f8ac827c63\nM: c4f207bf3beb7ff1ac6142ab7b40166d57d34463 172.38.0.13:6379\n   slots:[10923-16383] (5461 slots) master\n   1 additional replica(s)\n[OK] All nodes agree about slots configuration.\n>>> Check for open slots...\n>>> Check slots coverage...\n[OK] All 16384 slots covered.\n```\n\n至此redis集群就搭建完成了\n\n# SpringBoot微服务打包成Docker镜像\n\n1. 构建springboot项目\n2. 打包应用\n3. 编写dockerfile\n4. 构建镜像\n5. 发布运行\n\n到这里我们就完全够用了Docker。\n\n以后我们使用了Docker之后，给别人交付的就是一个镜像即可。\n\n\n\n# 其他\n\n如果有很多镜像，100个镜像，分别启动和维护，非常麻烦，所以真正的企业实战还需要以下知识：\n\n* Docker Compose\n* Docker Swarm\n* CI/CD Jenkins","tags":["Docker"],"categories":["Docker"]},{"title":"JUC并发编程学习笔记[全]","url":"/JUC/JUC并发编程学习笔记 [全]","content":"\n本笔记录了有关JUC的很多知识点，笔记做的比较匆忙，如果发现有任何问题都可以在评论区指出来。\n\n<!--more-->\n\n# 初识JUC\n\n## JUC概述\n\nJUC是Java中`java.util.concurrent`包中线程的高级应用，简称JUC，业内人士都读作钩优C~虽然我也不知道这个读法哪来打，但是我看的教程里面都是这么读的哈哈哈...\n\nJUC是从`JAVA 1.5`开始出现的，在此包中增加了在并发编程中的实用工具类，如`BlockingQueue`、`Callable`呀等等，还提供了线程池、异步IO和轻量级任务框架等等。\n\n![](https://i.loli.net/2020/05/07/yvLhFpmz63gZBCj.png)\n\n在学习JUC之前，需要先了解下线程与进程的区别，并发与并行的区别。\n\n## 线程与进程\n\n线程：程序执行的最小单位，是CPU调度的最小单位。\n\n进程：操作系统分配资源的最小单位。\n\n这样一说真的很抽象，必须打点比方才能迅速又深刻的记住二者的区别。\n\n打开windows任务管理器，可以看到线程比进程的数量多出几倍，可以大胆的猜测进程与线程是父子关系，一个进程包括多个线程。\n\n![image-20200507215629871](https://i.loli.net/2020/05/07/v6pFyMqZiGDHw2X.png)\n\n接下来引用知乎上的一个形象的比喻：\n\n<img src=\"https://i.loli.net/2020/05/07/Qk6BbXo9FLuC72t.png\" alt=\"image-20200507215953786\" style=\"zoom:80%;\" />\n\n<center>图片来源于知乎</center>\n\n是不是生动形象了很多？\n\n不过我认为对于线程和进程可以有更深层次的理解，本人对线程与进程的理解也仅限于此，望日后有空可以深究。\n\n-----\n\n### JAVA是否可以开启线程？\n\n答案是开不了，来看看源码吧！\n\n![image-20200507223222900](https://i.loli.net/2020/05/07/pfjTX4FPNWxCMZa.png)\n\n从关键字`native`中可以看出Thread源码中查看到Java启动线程的方法是调用的本地方法，所以Java是没本事自己开启线程的！\n\n-----\n\n### 线程的几种状态\n\n再次通过源码说事\n\n![image-20200507223438570](https://i.loli.net/2020/05/07/MxNhmFlYbzGSe6w.png)\n\n```java\npublic enum State {    \n\t// 新生    \n\tNEW,\n\t// 运行    \n\tRUNNABLE,\n    // 阻塞    \n    BLOCKED,        \n    // 等待，死死地等    \n    WAITING,\n    // 超时等待    \n    TIMED_WAITING,\n    // 终止    \n    TERMINATED; \n}\n```\n\n## 并发与并行\n\n并发：指两个或多个事件在很短的时间间隔内交替发生。\n\n并行：指两个或多个事件在同一时刻同时执行。\n\n如果觉得还是有点模糊，再看下面两张图，这样就不难理解了吧。\n\n\n\n![image-20200507221751892](https://i.loli.net/2020/05/16/T4JbGu3woe98VfM.png)\n\n<center>并发</center>\n\n![image-20200507221734140](https://i.loli.net/2020/05/16/uc52y93RhTjDnQ4.png)\n\n<center>并行</center>\n\n更具体的说并发就是一个处理器一次只能执行一个进程，但是它飞快的切换进程（也就是分配给每个进程的时间片很短，不，是非常短！），形成一种它同时在处理多个进程的错觉。\n\n所以对于并发有一种更为高级也更为精炼的解释：**宏观上并行，微观上串行！**\n\n而并行呢，就是多个处理器同时处理多个进程，这就是实打实的同时处理。\n\n------\n\n并发编程的实质就是充分利用CPU资源，就好比企业要挣钱，就要提高效率，就要找一个厉害的人去顶替三个不厉害的人，人员减少了，但是技术成本也提高了。\n\n# Lock锁\n\n在没学习JUC之前，要做到同步互斥，就要使用到`synchronized`。现在可以使用JUC内的LOCK接口。\n\n![image-20200507230349274](https://i.loli.net/2020/05/07/92z3cVRivdOW4t8.png)\n\nLOCK接口是JUC包内的一个接口，它有三个实现类：\n\n* ReentrantLock：可重入锁\n* ReadLock：读锁\n* WriteLock：写锁\n\n## 高内聚低耦合\n\n在进行多线程开发的时候，讲究的是高内聚低耦合，那么什么是高内聚和低耦合呢？\n\n### 高内聚\n\n高内聚指的是某个特定的软件模块内部包含一系列关系极其相关的功能，就比如说定义一个Class，里面包含了诸多的成员变量和方法，这些方法可以供外部使用，这就叫做高内聚。\n\n再打个生活上的部分，就如同你的电脑主机，主机内部的复杂组件被封装在主机里面，主机外部有很多插口，可以接屏幕、接鼠标、接网线等等，我们只能使用其暴露在外部的插口等，这就是高内聚。\n\n### 低耦合\n\n低耦合是指模块之间的依赖程度低，假如有两个模块A和B，如果每次修改A都要修改B，那么A和B之间就是强耦合。我们要尽量避免这种情况，就如同主机和屏幕，主机不连接屏幕，电脑的使用就会很复杂，可以说是无法使用，这种耦合性就很强。但是U盘和主机就几乎没什么关系吧，这就是低耦合。\n\n-----\n\n多线程操作的高内聚低耦合的实质就是**线程->操作->资源类**\n\n## Synchronized\n\n这里使用售票员卖票作为例子，首先定义一个Ticket，这个Ticket类就是资源类，它只包含必须的属性与方法。\n\n```java\n// 资源类 OOP \nclass Ticket {    \n\t// 属性、方法    \n\tprivate int number = 30;\n    // 卖票的方式    \n    // synchronized 本质: 队列，锁    \n    public synchronized void sale(){        \n        if (number>0){            \n        System.out.println(Thread.currentThread().getName()+\"卖出了\"+(number-)+\"票,剩余：\"+number);        \n    \t}   \n    }\n}\n```\n\n为了防止多个线程卖票的时候去查询剩余票量时出现混乱，在这里使用`synchronized`加锁，使得只能有一个线程进入此方法，现在创建三个售票员分别来卖票试试吧。\n\n```java\npublic static void main(String[] args) {\n    Ticket ticket = new Ticket();\n    new Thread(() -> {\n        for (int i = 0; i < 40; i++) ticket.sale();\n    }, \"A\").start();\n    new Thread(() -> {\n        for (int i = 0; i < 40; i++) ticket.sale();\n    }, \"B\").start();\n    new Thread(() -> {\n        for (int i = 0; i < 40; i++) ticket.sale();\n    }, \"C\").start();\n\n    List<String> list = new ArrayList<>();\n}\n```\n\n最后输出的结果有序且正确：\n\n![image-20200508000012987](https://i.loli.net/2020/05/08/hwytfrnJHcVZlzu.png)\n\n## Lock锁介绍\n\n然后再使用LOCK来上锁试试吧，LOCK接口最常用的实现类就是**可重入锁**（ReentrantLock），查看`ReentrantLock`源码可以看到有两种构造方法，默认的无参构造是`new NonfairSync()`，这个东西叫做非公平锁，第二种构造方法传入一个布尔值，这个布尔值决定是创建`FairSync`（公平锁）还是`NonfairSync`（非公平锁）。\n\n![image-20200508000145805](https://i.loli.net/2020/05/24/sOEApzy9ol2tZCH.png)\n\n### 公平锁与非公平锁\n\n那么什么是公平锁与非公平锁？\n\n公平锁：当某个线程拿到锁的时候，其他线程就得等待，这些等待的线程按到的顺序序排着长队，当锁释放的时候，排在队伍前面的线程就先去拿锁。\n\n非公平锁：就是非常的不公平，当锁释放的时候，等待的线程可以进行插队。\n\n### ReentrantLock的使用\n\n查看官方文档\n\n![image-20200508001641852](https://i.loli.net/2020/05/08/oyThIsKv3B8ltqe.png)\n\n大概的意思就是先定义可重入锁，然后在方法中用try-catch-finally包围起来，try和finally必须要有，finally块中需要将锁进行解锁，代码实现如下：\n\n```java\nclass Ticket {\n    private int num = 30;\n    Lock lock = new ReentrantLock();\n    public void sale() {\n\n        lock.lock();\n        try {\n            if (num > 0) {\n                num--;\n                System.out.println(Thread.currentThread().getName() + \"卖出了第\" + (30 - num) + \"票\\t还剩\" + num + \"张票\");\n            }\n        } finally {\n            // 无论如何都要进行解锁\n            lock.unlock();\n        }\n    }\n}\n```\n\n## 两者的区别\n\n其实从上面的代码上来看，使用LOCK也不简单，甚至说代码比synchronized还多一点，那为什么还要使用LOCK呢？自然而然就想到去探索下两者的区别：\n\n1. Synchronized 是内置的Java关键字，Lock 是一个Java类。\n2. Synchronized 无法判断获取锁的状态，Lock 可以判断是否获取到了锁。\n3. Synchronized 会自动释放锁，Lock 必须要手动释放锁！如果不释放锁，会导致死锁。\n4. Synchronized  线程 1（获得锁，阻塞）、线程2（等待，傻傻的等）；Lock锁就不一定会等待下去；\n5. Synchronized  是可重入锁，不可以中断的，非公平；Lock ，也是可重入锁，可以判断锁，非公平（可以 自己设置）；\n6. Synchronized  适合锁少量的代码同步问题，Lock  适合锁大量的同步代码。\n\n\n\n用B站狂神的话来讲就是：\n\n> 任何一个新的技术，绝对不是仅仅只是覆盖了原来的技术，它是优势和补充！\n\n# 生产者和消费者问题\n\n生产者和消费者问题是非常常见的一种问题，这个问题的意思是有一个生产者和一个消费者，生产者负责生产资源，消费者负责消费资源，二者协同合作，维持资源的稳定数目。\n\n\n\n## 传统 Synchronized 实现\n\n生产者和消费者问题的解决思路就在这里简述下吧，这不是本次学习的重点。\n\n1. 资源的数目初始化为0。\n2. 生产者检测资源的数目是否为0，如果为0则进行生产，如果不为0则等待。\n3. 假设生产者生产资源后，资源的数目变为1。\n4. 消费者检测到资源的数目大于0，于是进行消费，让资源的数目减1。\n5. 如果消费者检测到资源的数目不大于0 ，则也继续等待，等待生产者生产资源。\n\n代码实现如下：\n\n```java\npublic class TestPC {\n\n    public static void main(String[] args) {\n        Data data = new Data();\n        // A进程负责生产，B进程负责消费。\n        new Thread(() -> {\n            for (int i = 0; i < 20; i++) {\n                try {\n                    data.increment();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, \"A\").start();\n        new Thread(() -> {\n            for (int i = 0; i < 20; i++) {\n                try {\n                    data.decrement();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, \"B\").start();\n\n    }\n}\n\n// 资源类\nclass Data {\n    private int num = 0;\n\n    // 使用synchronized对方法加锁，保证每次只能有一个线程进入。\n    public synchronized void increment() throws InterruptedException {\n        if (num != 0) {\n            //如果 num 不为0，就没有生产（增加）的必要了。\n            //线程等待，同时wait()方法会释放掉锁。\n            this.wait();\n        }\n        num++;\n        System.out.println(Thread.currentThread().getName() + \">>\" + num);\n        // 将num++后可唤醒在decrement()方法中等待的线程，让其去num--。\n        this.notifyAll();\n    }\n\n\n    // decrement的思路和increment差不多\n    public synchronized void decrement() throws InterruptedException {\n        if (num == 0) {\n            this.wait();\n        }\n        num--;\n        System.out.println(Thread.currentThread().getName() + \">>\" + num);\n        this.notifyAll();\n    }\n}\n```\n\n通过输出结果可以看到资源一直维持在0与1。\n\n![image-20200508175242801](https://i.loli.net/2020/05/08/A2qlIkaOLYPevBj.png)\n\n### 虚假唤醒问题\n\n上面的代码其实是有问题的，注意到我是使用`if (num != 0)`去判断资源的数目的，这就会存在一个问题：**虚假唤醒**。\n\n#### 问题重现\n\n之前只有一个A进程和一个B进程，现在我再增加一个C进行，让它去生产。\n\n```java\nnew Thread(() -> {\n    for (int i = 0; i < 20; i++) {\n        try {\n            data.increment();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}, \"C\").start();\n```\n\n再次运行，通过输出结果可以看到资源的数目乱套了！它不再维持0和1这里两个数字，反而增加到10以上了。\n\n![image-20200508175916400](https://i.loli.net/2020/05/08/e8FW9ojwPJvbTD4.png)\n\n#### 原因\n\n这就是因为是使用`if (num != 0)`的原因，假设此时的num为1，那么A和C进程就会等待。\n\n![image-20200508181751879](https://i.loli.net/2020/05/08/NguHmJqX5t4Y63A.png)\n\n有同学会说，不是使用了synchronized来保证只有一个线程会进入吗，那A和C怎么会一起在等待，是这样的没错，但是使用wait()后，线程就会释放掉锁，那么其他进程就也可以进入此方法。假如A先进来，然后进行wait()，释放掉锁，C抢到锁，再次进来，也发现num != 0，于是A和C就一起在此等待了。\n\n这个时候A和C都在等待，B抢到锁开始做消费的操作，num--后，B唤醒其他的所有进程。\n\n![image-20200508180507682](https://i.loli.net/2020/05/08/aQCoigjkzNrFswP.png)\n\nA和C被唤醒，A和C也开始争夺锁，假如A抢到锁，继续执行下面的代码，A将num+1，并且唤醒其他进程，C抢到锁，那C也会将num+1，这个时候num就变成2了，这就是虚假唤醒问题。\n\n#### 解决方案\n\n首先看看官方文档对于虚假唤醒的解释和解决吧~\n\n![image-20200508175645521](https://i.loli.net/2020/05/08/HIGVTESKdA1qBkF.png)\n\n<center>官方文档中对于虚假唤醒的解决方案</center>\n\n只要将if换成while就可以了！这是因为if只会进行一次判断，线程被唤醒后就继续执行下面的代码，而while会多次判断，直至不满足while(条件)的条件后，线程才能走出while，所以当处于等待中的A和C被唤醒后，假设A抢到锁，它还是会去判断num是否为0，C抢到锁，也会去判断。\n\n```java\n// 使用synchronized对方法加锁，保证每次只能有一个线程进入。\npublic synchronized void increment() throws InterruptedException {\n    while (num != 0) {\n        //如果 num 不为0，就没有生产（增加）的必要了。\n        //线程等待，同时wait()方法会释放掉锁。\n        this.wait();\n    }\n    num++;\n    System.out.println(Thread.currentThread().getName() + \">>\" + num);\n    // 将num++后可唤醒在decrement()方法中等待的线程，让其去num--。\n    this.notifyAll();\n}\n\n\n// decrement的思路和increment差不多\npublic synchronized void decrement() throws InterruptedException {\n    while (num == 0) {\n        this.wait();\n    }\n    num--;\n    System.out.println(Thread.currentThread().getName() + \">>\" + num);\n    this.notifyAll();\n}\n```\n\n再次执行，发现结果很美好。\n\n![image-20200508182210561](https://i.loli.net/2020/05/08/PrA3VBNmYOxM8IT.png)\n\n## JUC版本的实现\n\n看官方文档可以发现Lock可以调用newCondition()方法得到一个Condition对象，这个Condition就是负责对线程的监控。\n\n![image-20200508183824433](https://i.loli.net/2020/05/08/fykKhbaJFIVHQOE.png)\n\n再来看看Condition的API吧\n\n![image-20200508183918001](https://i.loli.net/2020/05/08/sfZ5TA8nwBNtzI4.png)\n\n直接上代码\n\n```java\n/**\n * 使用Lock和Condition实现生产者消费者问题\n */\nclass Data {\n    private int num = 0;\n    private Lock lock = new ReentrantLock();\n    private Condition condition = lock.newCondition();\n\n    public void increment() throws InterruptedException {\n        lock.lock();\n        try {\n            while (num != 0) {\n                condition.await();\n            }\n            num++;\n            System.out.println(Thread.currentThread().getName() + \">>\" + num);\n            condition.signalAll();  //唤醒所有\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n\n    }\n\n    public void decrement() throws InterruptedException {\n        lock.lock();\n        try {\n            while (num == 0) {\n                condition.await();\n            }\n            num--;\n            System.out.println(Thread.currentThread().getName() + \">>\" + num);\n            condition.signalAll();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n}\n```\n\n运行 达到了同样的效果\n\n## 使用Condition实现精准唤醒\n\n再次引用那句话！\n\n> 任何一个新的技术，绝对不是仅仅只是覆盖了原来的技术，它是优势和补充！\n\n之所以使用Condition是因为Condition非常的强大，假设在做一种流水线生产，A做完后通知B继续，B做完后通知C继续，必须保证这种顺序，就可以使用Condition去实现。\n\n上代码\n\n```java\n/**\n * 精准唤醒\n */\nclass Data {\n    //1-A 2-B 3-C\n    //num为1时A工作，2时B工作，3时C工作。\n    private int num = 1;\n    private Lock lock = new ReentrantLock();\n    private Condition condition1 = lock.newCondition();\n    private Condition condition2 = lock.newCondition();\n    private Condition condition3 = lock.newCondition();\n\n    public void printA() {\n        lock.lock();\n        try {\n            while (num != 1) {\n                condition1.await();\n            }\n            num = 2;\n            System.out.println(Thread.currentThread().getName() + \">>\" + num);\n            // 通知B去工作\n            condition2.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void printB() {\n        lock.lock();\n        try {\n            while (num != 2) {\n                condition2.await();\n            }\n            num = 3;\n            System.out.println(Thread.currentThread().getName() + \">>\" + num);\n            // 通知C去工作\n            condition3.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void printC() {\n        lock.lock();\n        try {\n            while (num != 3) {\n                condition3.await();\n            }\n            num = 1;\n            System.out.println(Thread.currentThread().getName() + \">>\" + num);\n            // 通知A去工作\n            condition1.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\nmain方法\n\n```java\npublic static void main(String[] args) {\n    Data data = new Data();\n    new Thread(() -> {\n        for (int i = 0; i < 20; i++) {\n            data.printA();\n        }\n    }, \"A\").start();\n    new Thread(() -> {\n        for (int i = 0; i < 20; i++) {\n            data.printB();\n        }\n    }, \"B\").start();\n    new Thread(() -> {\n        for (int i = 0; i < 20; i++) {\n            data.printC();\n        }\n    }, \"C\").start();\n\n\n}\n```\n\n![image-20200508185149073](https://i.loli.net/2020/05/08/wdIoNKM5XPU2pmG.png)\n\n可以看到实现了A->B->C的有序工作。\n\n# 8锁现象\n\n不知道大家在使用锁的时候有没有想过锁究竟是什么？它到底锁的是什么？这次通过8锁现象可以对锁来一次深层次的了解。\n\n8锁现象就是关于锁的8种问题\n\n### 现象1-多个线程使用一把锁-无阻塞\n\n下面这种情况会先打电话还是先发短信呢？\n\n```java\npublic class EightLock {\n\n    public static void main(String[] args) {\n        Phone phone = new Phone();\n        //A负责发短信\n        new Thread(() -> phone.send(), \"A\").start();\n        try {\n            // 休眠一秒，使得A线程先拿到锁。\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //B负责打电话\n        new Thread(() -> phone.call(), \"B\").start();\n    }\n}\n\n/**\n * Phone中有两个方法，一个是发短信，一个是打电话。都加了锁。\n */\nclass Phone {\n    //发信息\n    public synchronized void send() {\n        System.out.println(\"发短信\");\n    }\n\n    //打电话\n    public synchronized void call() {\n        System.out.println(\"打电话\");\n    }\n\n}\n```\n\n执行多次后发现都是先发短信再打电话，这说明了谁先拿到锁，就先执行。锁的对象是方法的调用者，也就是phone，所以A和B线程使用的是同一把锁，而A线程先拿到锁，所以它先执行。\n\n### 现象2-多个线程使用同一把锁（其中一个线程被阻塞）\n\n试试将发短信的线程休眠几秒\n\n```java\n//发信息\npublic synchronized void send() {\n    try {\n        TimeUnit.SECONDS.sleep(3);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    System.out.println(\"发短信\");\n}\n```\n\n发现还是运行结果还是先发短信\n\n因为锁的是phone，多个线程调用phone的方法，也就是使用同一把锁，谁先拿到锁就先执行，即使其中有阻塞。\n\n### 现象3-调用普通方法\n\n在Phone中增加一个普通方法read(),增加一个线程去调用read()。\n\n```java\nimport java.util.concurrent.TimeUnit;\n\npublic class EightLock {\n\n    public static void main(String[] args) {\n\n        Phone phone = new Phone();\n\n        //A负责发短信\n        new Thread(() -> phone.send(), \"A\").start();\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //B负责打电话\n        new Thread(() -> phone.call(), \"B\").start();\n        //C负责看书\n        new Thread(() -> phone.read(), \"C\").start();\n    }\n\n}\n\n/**\n * Phone中有两个方法，一个是发短信，一个是打电话。都加了锁。\n */\nclass Phone {\n    //发信息\n    public synchronized void send() {\n        try {\n            TimeUnit.SECONDS.sleep(3);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"发短信\");\n    }\n\n    //打电话\n    public synchronized void call() {\n        System.out.println(\"打电话\");\n    }\n\n    //未加锁的方法：读书\n    public void read() {\n        System.out.println(\"读书\");\n    }\n\n}\n```\n\n运行多次后发现是先读书，因为普通方法没有加锁，所以不受限制，它不会去等待发信息的线程休眠3秒完后再去执行，而打电话的线程无论如何都会等待发消息的线程休眠完毕后再执行。\n\n### 现象4-多个线程使用多把锁\n\n现在使用两部phone，A使用phone1，B使用phone2，是会先发短信还是先打电话呢？\n\n```java\nimport java.util.concurrent.TimeUnit;\n\npublic class EightLock {\n\n    public static void main(String[] args) {\n\n        Phone phone1 = new Phone();\n        Phone phone2 = new Phone();\n\n        //A负责发短信\n        new Thread(() -> phone1.send(), \"A\").start();\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //B负责打电话\n        new Thread(() -> phone2.call(), \"B\").start();\n    }\n\n}\n\n/**\n * Phone中有两个方法，一个是发短信，一个是打电话。都加了锁。\n */\nclass Phone {\n    //发信息\n    public synchronized void send() {\n        try {\n            TimeUnit.SECONDS.sleep(3);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"发短信\");\n    }\n\n    //打电话\n    public synchronized void call() {\n        System.out.println(\"打电话\");\n    }\n\n}\n```\n\n锁的是方法的调用者，两部phone就是两把锁，相互之间不干扰，所以最后先打电话。\n\n### 现象5-添加静态方法\n\n使得Phone中的两个方法增加static修饰，还是使用一个对象，是先打电话还是先发短信呢？\n\n```java\nimport java.util.concurrent.TimeUnit;\n\npublic class EightLock {\n\n    public static void main(String[] args) {\n\n        Phone phone = new Phone();\n\n        //A负责发短信\n        new Thread(() -> phone.send(), \"A\").start();\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //B负责打电话\n        new Thread(() -> phone.call(), \"B\").start();\n    }\n\n}\n\n/**\n * Phone中有两个方法，一个是发短信，一个是打电话。都加了锁。\n */\nclass Phone {\n    //发信息\n    public static synchronized void send() {\n        try {\n            TimeUnit.SECONDS.sleep(3);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"发短信\");\n    }\n\n    //打电话\n    public static synchronized void call() {\n        System.out.println(\"打电话\");\n    }\n\n    //未加锁的方法：读书\n    public void read() {\n        System.out.println(\"读书\");\n    }\n\n}\n```\n\n结果是先发短信。\n\n添加了加锁的静态方法，这个时候锁的不再是方法调用者，而是Phone这个class类，但是因为A先拿到锁，所以还是先发短信。所以有静态方法的时候还是按顺序执行。\n\n### 现象6-添加静态方法同时使用两个对象\n\n```java\nimport java.util.concurrent.TimeUnit;\n\npublic class EightLock {\n\n    public static void main(String[] args) {\n\n        Phone phone1 = new Phone();\n        Phone phone2 = new Phone();\n\n        //A负责发短信\n        new Thread(() -> phone1.send(), \"A\").start();\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //B负责打电话\n        new Thread(() -> phone2.call(), \"B\").start();\n    }\n\n}\n\n/**\n * Phone中有两个方法，一个是发短信，一个是打电话。都加了锁。\n */\nclass Phone {\n    //发信息\n    public static synchronized void send() {\n        try {\n            TimeUnit.SECONDS.sleep(3);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"发短信\");\n    }\n\n    //打电话\n    public static synchronized void call() {\n        System.out.println(\"打电话\");\n    }\n\n    //未加锁的方法：读书\n    public void read() {\n        System.out.println(\"读书\");\n    }\n\n}\n```\n\n这个时候锁的是Class，所以不管多少个对象，都是使用的同一把锁，所以还是按顺序执行，谁先拿到锁就先执行，所以结果就是三秒过后发短信，然后再是打电话。\n\n### 现象7-一个静态同步方法与一个普通同步方法\n\n```java\nimport java.util.concurrent.TimeUnit;\n\npublic class EightLock {\n\n    public static void main(String[] args) {\n\n        Phone phone = new Phone();\n\n        //A负责发短信\n        new Thread(() -> phone.send(), \"A\").start();\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //B负责打电话\n        new Thread(() -> phone.call(), \"B\").start();\n    }\n\n}\n\n/**\n * Phone中有两个方法，一个是发短信，一个是打电话。都加了锁。\n */\nclass Phone {\n    //发信息\n    public static synchronized void send() {\n        try {\n            TimeUnit.SECONDS.sleep(3);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"发短信\");\n    }\n\n    //打电话\n    public synchronized void call() {\n        System.out.println(\"打电话\");\n    }\n\n    //未加锁的方法：读书\n    public void read() {\n        System.out.println(\"读书\");\n    }\n\n}\n```\n\n这个时候就是先打电话了，因为`static synchronized`锁的是class类，而只被`synchronized`修饰的锁的是方法的调用者，前者是class锁，后者是对象锁，二者不是同一把锁，互不干扰。\n\n### 现象8-多个对象+静态同步+普通同步\n\n使用两个phone对象\n\n```java\nimport java.util.concurrent.TimeUnit;\n\npublic class EightLock {\n\n    public static void main(String[] args) {\n\n        Phone phone1 = new Phone();\n        Phone phone2 = new Phone();\n\n        //A负责发短信\n        new Thread(() -> phone1.send(), \"A\").start();\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //B负责打电话\n        new Thread(() -> phone2.call(), \"B\").start();\n    }\n\n}\n\n/**\n * Phone中有两个方法，一个是发短信，一个是打电话。都加了锁。\n */\nclass Phone {\n    //发信息\n    public static synchronized void send() {\n        try {\n            TimeUnit.SECONDS.sleep(3);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"发短信\");\n    }\n\n    //打电话\n    public synchronized void call() {\n        System.out.println(\"打电话\");\n    }\n\n    //未加锁的方法：读书\n    public void read() {\n        System.out.println(\"读书\");\n    }\n\n}\n```\n\n被 synchronized和static修饰的方法，锁的对象是类的class对象！唯一的同一把锁；\n\n只被synchronized修饰的方法，是普通锁（如对象锁），不是Class锁，所以进程之间执行顺序互不干扰。\n\n所以最后还是先打电话。\n\n## 尾声\n\n通过这8个案例，应该能弄懂线程的执行顺序，锁的是什么。\n\n在并发编程下，ArrayList是线程不安全的，如果在修改ArrayList时同时读取ArrayList，它会造成`ConcurrentModificationException`（并发修改异常），这是在并发编程下需要解决的问题。\n\n\n\n```java\npublic static void main(String[] args) {\n    //1. arraylist线程不完全\n    List<String> list = new ArrayList<>();\n    for (int i = 1; i <= 50; i++) {\n        new Thread(() -> {\n            list.add(UUID.randomUUID().toString().substring(0, 5));\n            System.out.println(list);\n        }).start();\n    }\n}\n```\n\n上面的代码就是一边读一边写，最终运行结果如下：\n\n![image-20200509162857657](https://i.loli.net/2020/05/09/FSCwWNGjQplE9rT.png)\n\n### 解决方案一：Vector\n\n```java\npublic static void main(String[] args) {\n    List<String> list = new Vector<>();\n    for (int i = 1; i <= 50; i++) {\n        new Thread(() -> {\n            list.add(UUID.randomUUID().toString().substring(0, 5));\n            System.out.println(list);\n        }).start();\n    }\n}\n```\n\n使用Vector就不会发生并发修改异常，原因是：\n\n通过查看Vector源码可以发现Vector的方法上加了`synchronized`，那么这个list就被上锁了，这样在写入的时候就不能读取，在读取的时候就不能写入，使得读写分离，就不会发生并发修改异常。\n\n```java\n/**\n * Appends the specified element to the end of this Vector.\n *\n * @param e element to be appended to this Vector\n * @return {@code true} (as specified by {@link Collection#add})\n * @since 1.2\n */\npublic synchronized boolean add(E e) {\n    modCount++;\n    ensureCapacityHelper(elementCount + 1);\n    elementData[elementCount++] = e;\n    return true;\n}\n```\n\n#### 缺陷\n\n同时我也注意到Vector在Jdk 1.2就存在了，比ArrayList出生的还早一些，那为什么还会设计线程不安全的ArrayList呢？是因为Vector在读取的时候不能修改，在修改的时候不能读取，那它的效率就比ArrayList低，所以才有了ArrayList的存在。\n\n### 解决方案二：Collections.synchronizedList()\n\n```java\npublic static void main(String[] args) {\n    List<String> list = Collections.synchronizedList(new ArrayList<>());\n        for (int i = 1; i <= 50; i++) {\n            new Thread(() -> {\n                list.add(UUID.randomUUID().toString().substring(0, 5));\n                System.out.println(list);\n            }).start();\n        }\n}\n```\n\n通过`Collections.synchronizedList()`可以得到一个同步的List，也可以解决并发修改异常问题。\n\n### 解决方案三： CopyOnWriteArrayList\n\n`CopyOnWriteArrayList`也是JUC下的一个类。\n\n```java\npublic static void main(String[] args) {\n    List<String> list = new CopyOnWriteArrayList<>();\n    for (int i = 1; i <= 50; i++) {\n        new Thread(() -> {\n            list.add(UUID.randomUUID().toString().substring(0, 5));\n            System.out.println(list);\n        }).start();\n    }\n}\n```\n\n`CopyOnWriteArrayList`的原理是在写入的时候先复制一份底层的数组，然后对这个复制好的数组进行操作，这样就不会操作原始的数组，操作完成后，再将复制的数组设置为底层的数组。读取的时候读的是原始数组，写入的时候写的是复制数组，二者不是同一个事物，自然就不会产生并发修改异常。\n\n以下是`CopyOnWriteArrayList`在增加元素时的源码：\n\n```java\n/**\n * Appends the specified element to the end of this list.\n *\n * @param e element to be appended to this list\n * @return {@code true} (as specified by {@link Collection#add})\n */\npublic boolean add(E e) {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        Object[] elements = getArray();\n        int len = elements.length;\n        Object[] newElements = Arrays.copyOf(elements, len + 1);\n        newElements[len] = e;\n        setArray(newElements);\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n# Callable\n\n## Callable介绍\n\n`Callable`是一个接口，类似于`Runnable`，但是`Runnable`没有返回值，`Runnable`不返回结果，也不能抛出被检查的异常。\n\n\n\n `Callable`却可以做到：\n\n* 有返回值\n* 计算错误时抛出异常\n* `Runnable`使用run()，`Callable`使用call()。\n\n## Callable使用\n\n但是`Thread`的构造方法中，`Callable`是不能作为参数的。\n\n![image-20200509212857843](https://i.loli.net/2020/05/09/3XRrjeP85B9ipnY.png)\n\n这里要使用到`FutureTask`，它是`Runnable`接口的一个实现类，同时它的构造方法`FutureTask(Callable<V> callable) `可以接受`Callable`。\n\n![image-20200509213156120](https://i.loli.net/2020/05/09/zmd4BfsG6Uranlt.png)\n\n![image-20200509213132794](https://i.loli.net/2020/05/09/AkQZPLzmJUjiqou.png)\n\n所以可以通过以下代码使用`Callable`\n\n```java\n// 这个线程将1024作为返回值\nFutureTask futureTask = new FutureTask(() -> 1024);\nThread thread = new Thread(futureTask);\nthread.start();\n```\n\n## FutureTask的方法介绍\n\n![image-20200509213539438](https://i.loli.net/2020/05/09/zocUWSda62wDiIj.png)\n\n需要注意的是get()会一直等待计算完成，也就是如果计算一直没完成可能会产生阻塞。\n\n```java\n// 这个线程将1024作为返回值\nFutureTask futureTask = new FutureTask(() -> 1024);\nThread thread = new Thread(futureTask);\nthread.start();\nInteger num = (Integer)futureTask.get();\nSystem.out.println(num.toString());\n```\n\n最后输出的结果就是1024。\n\n# 集合不安全\n\n## ArrayList\n\n在并发编程下，ArrayList是线程不安全的，如果在修改ArrayList时同时读取ArrayList，它会造成`ConcurrentModificationException`（并发修改异常），这是在并发编程下需要解决的问题。\n\n\n\n```java\npublic static void main(String[] args) {\n    //1. arraylist线程不完全\n    List<String> list = new ArrayList<>();\n    for (int i = 1; i <= 50; i++) {\n        new Thread(() -> {\n            list.add(UUID.randomUUID().toString().substring(0, 5));\n            System.out.println(list);\n        }).start();\n    }\n}\n```\n\n上面的代码就是一边读一边写，最终运行结果如下：\n\n![image-20200509162857657](https://i.loli.net/2020/05/09/FSCwWNGjQplE9rT.png)\n\n### 解决方案一：Vector\n\n```java\npublic static void main(String[] args) {\n    List<String> list = new Vector<>();\n    for (int i = 1; i <= 50; i++) {\n        new Thread(() -> {\n            list.add(UUID.randomUUID().toString().substring(0, 5));\n            System.out.println(list);\n        }).start();\n    }\n}\n```\n\n使用Vector就不会发生并发修改异常，原因是：\n\n通过查看Vector源码可以发现Vector的方法上加了`synchronized`，那么这个list就被上锁了，这样在写入的时候就不能读取，在读取的时候就不能写入，使得读写分离，就不会发生并发修改异常。\n\n```java\n/**\n * Appends the specified element to the end of this Vector.\n *\n * @param e element to be appended to this Vector\n * @return {@code true} (as specified by {@link Collection#add})\n * @since 1.2\n */\npublic synchronized boolean add(E e) {\n    modCount++;\n    ensureCapacityHelper(elementCount + 1);\n    elementData[elementCount++] = e;\n    return true;\n}\n```\n\n#### 缺陷\n\n同时我也注意到Vector在Jdk 1.2就存在了，比ArrayList出生的还早一些，那为什么还会设计线程不安全的ArrayList呢？是因为Vector在读取的时候不能修改，在修改的时候不能读取，那它的效率就比ArrayList低，所以才有了ArrayList的存在。\n\n### 解决方案二：Collections.synchronizedList()\n\n```java\npublic static void main(String[] args) {\n    List<String> list = Collections.synchronizedList(new ArrayList<>());\n        for (int i = 1; i <= 50; i++) {\n            new Thread(() -> {\n                list.add(UUID.randomUUID().toString().substring(0, 5));\n                System.out.println(list);\n            }).start();\n        }\n}\n```\n\n通过`Collections.synchronizedList()`可以得到一个同步的List，也可以解决并发修改异常问题。\n\n### 解决方案三： CopyOnWriteArrayList\n\n`CopyOnWriteArrayList`也是JUC下的一个类。\n\n```java\npublic static void main(String[] args) {\n    List<String> list = new CopyOnWriteArrayList<>();\n    for (int i = 1; i <= 50; i++) {\n        new Thread(() -> {\n            list.add(UUID.randomUUID().toString().substring(0, 5));\n            System.out.println(list);\n        }).start();\n    }\n}\n```\n\n`CopyOnWriteArrayList`的原理是在写入的时候先复制一份底层的数组，然后对这个复制好的数组进行操作，这样就不会操作原始的数组，操作完成后，再将复制的数组设置为底层的数组。读取的时候读的是原始数组，写入的时候写的是复制数组，二者不是同一个事物，自然就不会产生并发修改异常。\n\n以下是`CopyOnWriteArrayList`在增加元素时的源码：\n\n```java\n/**\n * Appends the specified element to the end of this list.\n *\n * @param e element to be appended to this list\n * @return {@code true} (as specified by {@link Collection#add})\n */\npublic boolean add(E e) {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        Object[] elements = getArray();\n        int len = elements.length;\n        Object[] newElements = Arrays.copyOf(elements, len + 1);\n        newElements[len] = e;\n        setArray(newElements);\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n## Set\n\nSet其实和List是一样的，也会产生并发修改异常，而且解决方案也是类似的，在这里就统一列出。\n\n```java\n// 1.HashSet 会发生并发修改异常\nSet<String> set = new HashSet<>();\n\n// 2.synchronizedSet\nset = Collections.synchronizedSet(new HashSet<>());\n\n// 3.CopyOnWriteArraySet\nset = new CopyOnWriteArraySet<>();\n```\n\n## Map\n\n回顾Map基本操作\n\n<img src=\"https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200912210905.png\" alt=\"image-20200912210801561\" style=\"zoom:80%;\" />\n\n<img src=\"https://zhenghaoyun.oss-cn-beijing.aliyuncs.com/img/20200912210900.png\" alt=\"image-20200912210900098\" style=\"zoom:80%;\" />\n\n\n\n# 常用辅助类\n\n## CountDownLatch\nCountDownLatch 有两个用途：\n- 第一个是启动信号，防止任何工作人员进入，直到驾驶员准备好继续前进; \n- 第二个是完成信号，允许司机等到所有的工作人员完成。\n\n```java\npublic static void main(String[] args) {\n    // 假设有6个人，驾驶员需要等待6个人都上车后，再启动车辆。\n    CountDownLatch countDownLatch = new CountDownLatch(6);\n    for (int i = 1; i <= 6; i++) {\n        new Thread(() -> {\n            System.out.println(Thread.currentThread().getName() + \"上车了\");\n            // 每上一个人，将6减掉1。\n            countDownLatch.countDown();\n        }, i + \"\").start();\n    }\n    try {\n        // await()方法的作用是只有当6不断减1减到0的时候，才会执行接下来的代码，不然会一直在此等待。\n        // 就好比驾驶员一直在等待所有人上车\n        countDownLatch.await();\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    // 所有人都上车了，启动车辆！\n    System.out.println(\"驾驶员发车\");\n\n}\n```\n\n运行结果就是当6个人都上车后，驾驶员才会发车。\n\n![image-20200509215325091](https://i.loli.net/2020/05/09/BMeYxzNsIXEmRfF.png)\n\n## CyclicBarrier \n\nCyclicBarrier 的作用和 CountDownLatch 差不太多，就是使用方法有点差距。\n\n```java\npublic static void main(String[] args) {\n    // 这个里面的第二个参数是最后要执行的，等待所有条件满足后才会执行。\n    CyclicBarrier cyclicBarrier = new CyclicBarrier(6,()->{\n        System.out.println(\"大家都进来了，发车吧！\");\n    });\n    for (int i = 1; i <= 6; i++) {\n        new Thread(() -> {\n            try {\n                TimeUnit.SECONDS.sleep(3);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \" 进来了\");\n            try {\n                // 每个人进入车后要awiat()，表示自己已经进来了，等待其他人上车\n                // 当所有人都调用了awiat()后，驾驶员就会发车。\n                cyclicBarrier.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } catch (BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n        }, i + \"\").start();\n\n    }\n}\n```\n\n最后输出结果：\n\n![image-20200509220118382](https://i.loli.net/2020/05/09/BV4dtgITkeiofFU.png)\n\n## Semaphore\n\nSemaphore就是信号量，有操作系统基础的应该很好理解。\n\n我们可以通过Semaphore去限制操作某个资源的线程的数量。\n\n比如说桌上有两个苹果，那么Semaphore为2，当妈妈拿了一个，Semaphore减1，爸爸也可以拿，Semaphore减1，这个时候Semaphore为0，这你就不能拿了，只能等爷爷再削个苹果放桌上，Semaphore加1，你就可以拿苹果了。\n\n下面是一个限制车流量的例子\n\n```java\npublic static void main(String[] args) {\n    // 停车位数量有限 所以采用Semaphore限流\n    // 假设总共有3个车位 却有6台车\n    Semaphore semaphore = new Semaphore(3);\n    for (int i = 1; i <= 6; i++) {\n        new Thread(() -> {\n            try {\n                semaphore.acquire();    //车位减1\n                System.out.println(Thread.currentThread().getName() + \"进来停2秒的车\");\n                TimeUnit.SECONDS.sleep(2);\n                System.out.println(Thread.currentThread().getName() + \"进来停2秒后走了\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }finally {\n                semaphore.release();    //车位加1\n            }\n        }, String.valueOf(i)).start();\n    }\n\n}\n```\n\n# ReadWriteLock\n\nReadWriteLock（读写锁）可以使得读和读互不影响，读和写互斥，写和写互斥，提高读写的效率。\n\n\n\nReadWriteLock中包含两把锁：\n\n* 读锁（共享锁）\n* 写锁（独占锁）\n\n两种方法去获取锁\n\n![image-20200509223654884](https://i.loli.net/2020/05/09/x1tNZXiG4VsmOye.png)\n\n```java\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\npublic class TestReadWriteLock {\n    public static void main(String[] args) {\n        MyCacheLock myCache = new MyCacheLock();\n        for (int i = 1; i <= 40; i++) {\n            final int temp = i;\n            new Thread(() -> myCache.write(temp + \"\", temp + \"\"), String.valueOf(i)).start();\n        }\n        for (int i = 1; i <= 40; i++) {\n            final int temp = i;\n            new Thread(() -> myCache.read(temp + \"\"), String.valueOf(i)).start();\n        }\n    }\n}\n\nclass MyCacheLock {\n    private  Map<String, Object> map = new HashMap<>();\n    private  ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    public void write(String key, Object value) {\n        readWriteLock.writeLock().lock();\n        try {\n            System.out.println(Thread.currentThread().getName() + \"写入\" + key);\n            map.put(key, value);\n            System.out.println(Thread.currentThread().getName() + \"-写入OK\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n    }\n\n    public void read(String key) {\n        readWriteLock.readLock().lock();\n        try {\n            System.out.println(Thread.currentThread().getName() + \"读取\" + key);\n           map.get(key);\n            System.out.println(Thread.currentThread().getName() + \"-读取OK\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            readWriteLock.readLock().unlock();\n        }\n    }\n}\n```\n\n加读锁的作用是保证在读的时候，其他线程不能写，因为读锁和写锁是互斥的。如果不加读锁，可能在读的时候，其他线程就能写，而加了读锁，其他线程就不能加写锁了。\n\n# 阻塞队列\n\n\n阻塞队列和队列是一样的，讲究FIFO的原则，但是多了`阻塞`二字，意思是当队列满了的时候，就必须阻塞等待。\n\n## 阻塞队列的实现类\n\n阻塞队列是一个接口，有以下实现类：\n\n![image-20200510154958476](https://i.loli.net/2020/05/10/dwuSiIM6U439cKW.png)\n\n## 阻塞队列的地位\n\n![image-20200510155056890](https://i.loli.net/2020/05/10/YCZLWAtJ9euVg1c.png)\n\n## 阻塞队列的使用\n\n在并发编程和线程池中，阻塞队列会被使用到。\n\n阻塞队列有四组添加和移除的方法，每一组的功能都不同，总结如下表：\n\n|       方式       | 有返回值会抛出异常 | 有返回值不抛出异常 | 会阻塞等待 | 会超时等待 |\n| :--------------: | :----------------: | :----------------: | :--------: | :--------: |\n|       添加       |       add()        |      offer()       |   put()    | offer(...) |\n|       移除       |      remove()      |       poll()       |   take()   | poll(...)  |\n| 检索但不删除队头 |     element()      |       peek()       |     -      |     -      |\n\n说明：\n\n1. 可能产生的异常有：\n   * IllegalStateException - 如果由于容量限制，此时无法添加该元素\n   * ClassCastException - 如果指定元素的类阻止将其添加到此队列 \n   * NullPointerException - 如果指定的元素为空 \n   * IllegalArgumentException - 如果指定元素的某些属性阻止将其添加到此队列中\n   * NoSuchElementException - 如果这个队列是空的 \n   * 等等...\n2. 超时等待那一列的方法的参数可以写时间，表明过了多久时间就不等待了。\n\n## 同步队列\n\nSynchronousQueue是这样一种阻塞队列，其中每个put必须等待一个take，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。\n不能在同步队列上进行peek，因为仅在试图要取得元素时，该元素才存在；除非另一个线程试图移除某个元素，否则也不能（使用任何方法）添加元素；也不能迭代队列，因为其中没有元素可用于迭代。队列的头是尝试添加到队列中的首个已排队线程元素；如果没有已排队线程，则不添加元素并且头为null。\n对于其他Collection方法（例如contains），SynchronousQueue作为一个空集合。此队列不允许null元素。\n它非常适合于传递性设计，在这种设计中，在一个线程中运行的对象要将某些信息、事件或任务传递给在另一个线程中运行的对象，它就必须与该对象同步。\n对于正在等待的生产者和使用者线程而言，此类支持可选的公平排序策略。默认情况下不保证这种排序。\n但是，使用公平设置为true所构造的队列可保证线程以FIFO的顺序进行访问。公平通常会降低吞吐量，但是可以减小可变性并避免得不到服务。\n\n```java\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.SynchronousQueue;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 同步队列 * 和其他的BlockingQueue 不一样， SynchronousQueue 不存储元素 \n * put了一个元素，必须从里面先take取出来，否则不能在put进去值！\n */\npublic class SynchronousQueueDemo {\n    public static void main(String[] args) {\n        BlockingQueue<String> blockingQueue = new SynchronousQueue<>(); // 同步队列\n        new Thread(() -> {\n            try {\n                System.out.println(Thread.currentThread().getName() + \" put 1\");\n                blockingQueue.put(\"1\");\n                System.out.println(Thread.currentThread().getName() + \" put 2\");\n                blockingQueue.put(\"2\");\n                System.out.println(Thread.currentThread().getName() + \" put 3\");\n                blockingQueue.put(\"3\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }, \"T1\").start();\n        new Thread(() -> {\n            try {\n                TimeUnit.SECONDS.sleep(3);\n                System.out.println(Thread.currentThread().getName() + \"=>\" + blockingQueue.take());\n                TimeUnit.SECONDS.sleep(3);\n                System.out.println(Thread.currentThread().getName() + \"=>\" + blockingQueue.take());\n                TimeUnit.SECONDS.sleep(3);\n                System.out.println(Thread.currentThread().getName() + \"=>\" + blockingQueue.take());\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }, \"T2\").start();\n    }\n}\n```\n\n# 线程池\n\n线程池的三大方法、七大参数、四大拒绝策略。\n\n\n\n## 池化技术\n\n程序运行会占用系统资源，采用池化技术可以优化资源的使用。常见的池子有：线程池、连接池、内存池、对象池等等。\n\n池化技术也就是说：事先准备好一些资源，有人需要就过来拿，用完后就归还。\n\n### 好处：\n\n* 降低资源的消耗（可以线程复用）\n* 提高响应的速度（可以控制最大并发数）\n* 方便管理（可以管理线程）\n\n>使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资\n>源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者 “过度切换”的问题。 ——引用自阿里巴巴开发手册\n\n## 线程池三大方法\n\n阿里巴巴开发手册中这样写道：\n\n![image-20200512161036004](https://i.loli.net/2020/05/12/nKa231siHRlVmq7.png)\n\n可见要创建线程池推荐使用ThreadPoolExecutor，但是我先使用下Executors，好让我了解下Executors的弊端。\n\n### newSingleThreadExecutor()\n\n这个方法可以创建在线程池中创建一个单一线程。\n\n```java\npublic static void main(String[] args) {\n    ExecutorService threadPool = Executors.newSingleThreadExecutor();\n    try {\n        for (int i = 0; i < 20; i++) {\n            threadPool.execute(() -> System.out.println(Thread.currentThread().getName()));\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        //用完后线程池要关闭\n        threadPool.shutdown();\n    }\n\n}\n```\n\n运行后：\n\n![image-20200512161407287](https://i.loli.net/2020/05/12/MpL7hHk3xqDB1uR.png)\n\n可以看到一直是同一个线程。\n\n### newFixedThreadPool(...)\n\n在线程池中创建固定数量的线程池。\n\n```java\npublic static void main(String[] args) {\n    ExecutorService threadPool = Executors.newFixedThreadPool(5);\n    try {\n        for (int i = 0; i < 20; i++) {\n            threadPool.execute(() -> System.out.println(Thread.currentThread().getName()));\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        //用完后线程池要关闭\n        threadPool.shutdown();\n    }\n\n}\n```\n\n运行后可以看到最多只有5个线程，就不放图了。\n\n### newCachedThreadPool()\n\n这个方法不用参数，可以根据需要创建线程数量，也可重用之前创建好的线程。不过创建的线程数量根据CPU的性能而定，如果你的CPU只运行同时运行20个线程，那么你就不能创建30个线程同时工作。\n\n```java\npublic static void main(String[] args) {\n    ExecutorService threadPool = Executors.newCachedThreadPool();\n    try {\n        // 需要创建1000个线程\n        // 但是运行结果只创建了100多个线程，根据CPU的性能而定。\n        for (int i = 0; i < 1000; i++) {\n            threadPool.execute(() -> System.out.println(Thread.currentThread().getName()));\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        //用完后线程池要关闭\n        threadPool.shutdown();\n    }\n\n}\n```\n\n## 七大参数\n\n首先来看看上面提到的三个方法的源码\n\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n}\n```\n\n发现这个三个方法的本质都是ThreadPoolExecutor，这也就是为什么阿里巴巴推荐使用ThreadPoolExecutor。\n\n这三个方法允许请求的队列长度都是Integer.MAX_VALUE，可能会堆积大量的请求，导致OOM。\n\n下面是ThreadPoolExecutor中各大参数的含义\n\n```\npublic ThreadPoolExecutor(int corePoolSize,\t\t\t\t\t\t//核心线程池大小\n                          int maximumPoolSize,\t\t\t\t\t//最大核心线程池大小\n                          long keepAliveTime,\t\t\t\t\t//超时了没有人调用就会释放\n                          TimeUnit unit,\t\t\t\t\t\t//超时单位\n                          BlockingQueue<Runnable> workQueue,\t//阻塞队列\n                          ThreadFactory threadFactory,\t\t\t//线程工厂，用来创建线程。\n           \t\t\t\t  //拒接策略\n                          RejectedExecutionHandler handler) {\n    if (corePoolSize < 0 ||\n        maximumPoolSize <= 0 ||\n        maximumPoolSize < corePoolSize ||\n        keepAliveTime < 0)\n        throw new IllegalArgumentException();\n    if (workQueue == null || threadFactory == null || handler == null)\n        throw new NullPointerException();\n    this.acc = System.getSecurityManager() == null ?\n            null :\n            AccessController.getContext();\n    this.corePoolSize = corePoolSize;\n    this.maximumPoolSize = maximumPoolSize;\n    this.workQueue = workQueue;\n    this.keepAliveTime = unit.toNanos(keepAliveTime);\n    this.threadFactory = threadFactory;\n    this.handler = handler;\n}\n```\n\n接下来以银行办理业务举例来说明这几大参数的意义：\n\n在生活中，我们去银行办理业务时，都会有柜台、候客区等。\n\n1. 假设有5个柜台，但是只有1号和2号柜台是开放的，其他3个柜台暂时关闭，这个时候corePoolSize就为2，maximumPoolSize就为5。\n2. 现在来了两个客人，那么他们俩就可以去1号和2号柜台办理业务。\n3. 又来了三个客人，他们就只能在候客区等待（假设候客区是三个位置），他们三个人就把候客区坐满了。如果前面两个人业务办理完了，他们就可以按FIFO原则去柜台办理业务。这个候客区就是workQueue（阻塞队列）。\n4. 但是如果有一天人特别多，候客区都坐满了，还是有人从银行进来，这个时候银行就会将另外关闭了三个窗口开放，这就体现了maximumPoolSize的含义。\n5. 如果5个窗口都有人在，候客区也坐满了，还是有人进来，那就得去处理这个人，是让他离开还是给他找个地方等，这就叫做RejectedExecutionHandler（拒绝策略）\n6. keepAliveTime表示如果银行等了keepAliveTime的时间，还是没有人来办理业务，银行就会将临时开放的三个窗口给关闭，也就是释放线程池。\n\n![image-20200512175120673](https://i.loli.net/2020/05/12/zFk3lbcjpwoaLYh.png)\n\n<center>图示</center>\n\n## 四种拒绝策略\n\n\n* new ThreadPoolExecutor.AbortPolicy()   银行满了，还有人进来，不处理这个人，直接抛出异常。\n* new ThreadPoolExecutor.CallerRunsPolicy()  哪来的去哪里！\n* new ThreadPoolExecutor.DiscardPolicy() 队列满了，丢掉任务，不会抛出异常！\n* new ThreadPoolExecutor.DiscardOldestPolicy() 队列满了，尝试去和早的竞争，也不会抛出异常！\n\n## 手动自定义线程池\n\n```java\npublic static void main(String[] args) {\n    /*\n     * new ThreadPoolExecutor.AbortPolicy() // 银行满了，还有人进来，不处理这个人的，抛出异 常\n     * new ThreadPoolExecutor.CallerRunsPolicy() // 哪来的去哪里！\n     * new ThreadPoolExecutor.DiscardPolicy() //队列满了，丢掉任务，不会抛出异常！\n     * new ThreadPoolExecutor.DiscardOldestPolicy() //队列满了，尝试去和早的竞争，也不会 抛出异常！\n     */\n    ThreadPoolExecutor threadPool = new ThreadPoolExecutor(\n            3,\n            5,\n            3,\n            TimeUnit.SECONDS,\n            new LinkedBlockingDeque<>(3),\n            Executors.defaultThreadFactory(),\n            new ThreadPoolExecutor.AbortPolicy()\n    );\n\n    try {\n        // 最大承载：Deque的容量 + maximumPoolSize\n        // 超过就抛出RejectedExecutionException\n        for (int i = 1; i <= 8; i++) {\n            // 使用了线程池之后，使用线程池来创建线程\n            threadPool.execute(() -> System.out.println(Thread.currentThread().getName() + \" ok\"));\n        }\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        threadPool.shutdown();\n    }\n\n}\n```\n\n## 池的大小如何设定\n\n关于池中线程数量的设定有两种说法\n\n1. CPU密集型：根据你的CPU性能来设置线程数量，保持CPU的效率最高。\n\n`Runtime.getRuntime().availableProcessors()`可以获取到当前计算机的CPU的核数，不能将最大线程数量写死，假如你的项目迁移到别人的电脑上，而他的电脑配置很低，你要是最大线程数量写的过大的话，就会出问题。而用`Runtime.getRuntime().availableProcessors()`可以很好的解决这个问题。\n\n```\nThreadPoolExecutor threadPool = new ThreadPoolExecutor(\n        3,\n        Runtime.getRuntime().availableProcessors(),     //用CPU的核数代替最大线程数量\n        3,\n        TimeUnit.SECONDS,\n        new LinkedBlockingDeque<>(3),\n        Executors.defaultThreadFactory(),\n        new ThreadPoolExecutor.AbortPolicy()\n);\n```\n\n2. IO密集型：判断程序中十分耗IO的线程的数量，设置最大线程数量大于IO线程数量（一般为两倍）。\n\n因为IO线程非常占用资源，而我们设置最大线程数量大于IO线程数量，就可以避免线程阻塞。\n\n# ForkJoin详解\n\nForkJoin中文名叫做分支合并，ForkJoin是在JDK1.7出现的，它主要用作在大数据量时并行执行效率，提高效率。\n\n\n\n## ForkJoin思想\n\n它的思想是将一个大任务分割成若干个小任务，最终汇总每个小任务的结果得到这个大任务的结果。类似于分治法。\n\n![image-20200513142115803](https://i.loli.net/2020/05/13/v4dEieLXKPZNTpu.png)\n\n## ForkJoin特点：工作窃取\n\n如图A和B线程处理两个任务，当B比A先处理完时，它可以从另一头开始去处理A的任务。A和B的任务是一个双端队列，所以B可以从另外一头进入。这就是工作窃取。\n\n![image-20200513142256555](https://i.loli.net/2020/05/13/rHRcn2pz5j16IKZ.png)\n\n## ForkJoin使用\n\n### 简单介绍\n\n1. ForkJoinPool\n\nForkJoinPool用来存放一个个任务\n\n![image-20200513214414430](https://i.loli.net/2020/05/13/JBhIo6vaQEKzufS.png)\n\n2. ForkJoinTask\n\nForkJoinTask就是ForkJoinPool里面的一个个任务，它有两个主要子类：\n\n* RecusiveAction（递归事件，没有返回值）\n* RecisiveTask（递归任务，有返回值）\n\n可以通过fork()方法去分配任务执行任务，通过join()方法汇总任务结果（其他方法具体可以看官方文档）\n\nForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责存放程序提交给ForkJoinPool的任务，而ForkJoinWorkerThread数组负责执行这些任务。\n\n### 具体使用\n\n目的：计算1至1亿相加的结果\n\n1. 创建自己的任务类 MyTask，需要继承RecisiveTask。\n\n```java\npackage forkjoin;\n\nimport java.util.concurrent.RecursiveTask;\n\n/**\n * 我的任务Class\n * 任务是计算1至1亿的和\n */\npublic class MyTask extends RecursiveTask<Long> {\n\n    private Long start; //计算起始点\n    private Long end;   //计算终点\n\n    private Long temp = 10000L;\n\n    public MyTask(Long start, Long end) {\n        this.start = start;\n        this.end = end;\n    }\n\n    @Override\n    protected Long compute() {\n        //如果计算量较小，直接交给for循环去计算。\n        if ((end - start) < temp) {\n            Long sum = 0L;\n            for (Long i = start; i <= end; i++) {\n                sum += i;\n            }\n            return sum;\n        } else {\n            //使用forkjoin去计算\n            long middle = (start + end) / 2;                //中间值\n            //开始拆分任务\n            MyTask task1 = new MyTask(start, middle);       //任务1\n            task1.fork();                                   //使用fork()去拆分任务，将任务压入线程队列。\n            MyTask task2 = new MyTask(middle + 1, end);     //任务2\n            task2.fork();\n            return task1.join() + task2.join();\n\n        }\n    }\n\n}\n```\n\n2. 测试\n\n```java\npackage forkjoin;\n\nimport org.junit.Test;\n\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.ForkJoinTask;\n\npublic class TestForkJoin {\n\n    @Test\n    public void test1() throws ExecutionException, InterruptedException {\n        Long startTime = System.currentTimeMillis();\n        MyTask myTask = new MyTask(1L, 1_0000_0000L);\n        ForkJoinPool forkJoinPool = new ForkJoinPool();\n        ForkJoinTask<Long> submit = forkJoinPool.submit(myTask);    //提交任务\n        Long sum = submit.get();                                    //get()方法会去等待返回值，可能会发生阻塞。\n        Long endTime = System.currentTimeMillis();\n        System.out.println(\"结果是：\" + sum + \"，所耗时间为：\" + (endTime - startTime));\n\n    }\n}\n```\n\n3. 运行结果\n\n![image-20200513220808233](https://i.loli.net/2020/05/13/dyWP5As98wxIjqg.png)\n\n4. 使用Stream流去计算会更加块\n\n```java\n@Test\npublic void test2() {\n    //使用Stream流去计算\n    long startTime = System.currentTimeMillis();\n    LongStream stream = LongStream.rangeClosed(0L, 1_0000_0000);\n    long sum = stream.parallel().reduce(Long::sum).getAsLong();\n    long endTime = System.currentTimeMillis();\n    System.out.println(\"结果是：\" + sum + \"，所耗时间为：\" + (endTime - startTime));\n}\n```\n\n![image-20200513221859810](https://i.loli.net/2020/05/13/qSnTLb9EJYasMQx.png)\n\n# 异步回调\n\n学习过Ajax的应该很好理解这部分的内容。\n\n## CompletableFuture\n\nCompletableFuture内包含两类常用方法：\n\n### 没有返回值的方法\n\n![image-20200516212905649](https://i.loli.net/2020/05/16/A8MzfcUxP3tHNCZ.png)\n\n就好比小红和小明一起在健身房，，小红突然有事，对小明说我先走了，小红不用等小明回复，打声招呼就走了。\n\n```java\n@Test\npublic void testRunAsync() throws ExecutionException, InterruptedException {\n\n    // 没有返回值的用法\n    // Void是void的包装类，就好比Integer是int的包装类。\n    CompletableFuture<Void> voidCompletableFuture = CompletableFuture.runAsync(() -> {\n        System.out.println(Thread.currentThread().getName() + \"没有返回值！\");\n    });\n    System.out.println(voidCompletableFuture.get());\n}\n```\n\n输出结果：\n\n```\nForkJoinPool.commonPool-worker-1没有返回值！\nnull\n```\n\n### 有返回值的方法\n\n### 有返回值的方法\n\n![image-20200516213355855](https://i.loli.net/2020/05/16/8lrWjnpkDMqw9uH.png)\n\n这个的意思就是说假如你有道题目不会做，你去问同桌，但是同桌也得想一下，你就对同桌说我先去做其他作业了，你做好后告诉我。如果同桌做好了，他就告诉你正确的结果，如果同桌也遇到了困难，他就会告诉你不会做（给你返回异常信息）。\n\n```java\n@Test\npublic void testSupplyAsync() {\n    // 有返回值的用法，返回1+1的结果。\n    CompletableFuture<Integer> integerCompletableFuture = CompletableFuture.supplyAsync(() -> {\n        System.out.println(Thread.currentThread().getName() + \"有返回值！\");\n        return 1+1;\n    });\n    // whenComplete表示完成后的操作\n    // whenComplete内的参数是一个BiConsumer接口，它能够接受两个参数。而普通的Consumer接口只能接受一个参数。\n    integerCompletableFuture.whenComplete((integer, throwable) -> {\n        System.out.println(integer);        // 1+1的结果，如果有异常，就为null。\n        System.out.println(throwable);      // 异常信息，如果没有异常就为null。\n    });\n    // 输出后第一行是1+1的结果，第二行为null。\n}\n```\n\n如果是计算1+1/0呢，这个肯定是出现异常的。\n\n```java\n@Test\npublic void testSupplyAsync() throws ExecutionException, InterruptedException {\n    // 有返回值的用法，返回1+1的结果。\n    CompletableFuture<Integer> integerCompletableFuture = CompletableFuture.supplyAsync(() -> {\n        System.out.println(Thread.currentThread().getName() + \"有返回值！\");\n        return 1 + 1 / 0;\n    });\n    // whenComplete表示完成后的操作\n    // whenComplete内的参数是一个BiConsumer接口，它能够接受两个参数。而普通的Consumer接口只能接受一个参数。\n    System.out.println(integerCompletableFuture.whenComplete((integer, throwable) -> {\n        System.out.println(integer);        // 1+1的结果，如果有异常，就为null。\n        System.out.println(throwable);      // 异常信息，如果没有异常就为null。\n    }).exceptionally(throwable -> {\n        // exceptionally就好比try-finally的finally\n        System.out.println(\"出现异常啦：\" + throwable.getMessage());\n        return 4444;\n    }).get());\n```\n\n运行结果：\n\n```\nForkJoinPool.commonPool-worker-1有返回值！\nnull\njava.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero\n出现异常啦：java.lang.ArithmeticException: / by zero\n4444\n```\n\n# JMM\n\n## 什么是JMM\n\nJMM 是Java内存模型，是一个不存在的东西，是一种概念、约定，不是像JVM是存在的东西。\n\n## JMM对同步的约定\n\n1. 线程解锁前必须把共享变量**立刻**刷新回主存。\n\n> 什么意思呢？\n>\n> 假设主存中有个布尔变量flag=true，线程A要去拿这个变量的时候，会将这个变量拷贝到线程自己的工作内存中，而不是操作主存中的flag变量，当线程解锁的时候，如果它将flag改为false，它就必须将flag=false刷新会主存，也就是将主存中的flag改为false。\n>\n> 这其中对应了8中操作：\n>\n> 1. read：从主存中读（read）出flag=true\n> 2. load：将flag=true load 至线程自己的工作内存\n> 3. use：执行引擎use工作内存中的flag变量\n> 4. assign：执行引擎use完后assign（赋值）至工作内存\n> 5. store：线程用完flag变量后store至工作内存的变量副本中，对应load操作\n> 6. write：将store操作从工作内存中得到的变量放入主内存的变量中，对应read\n> 7. lock：加锁，把一个变量标识位线程独占状态\n> 8. unlock：解锁，将一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定\n\n2. 线程加锁前，必须读取主存中的最新值到工作内存中！\n3. 加锁和解锁是同一把锁。\n\n## 内存交互对应8种操作\n\n1. read：从主存中读（read）出flag=true\n2. load：将flag=true load 至线程自己的工作内存\n3. use：执行引擎use工作内存中的flag变量\n4. assign：执行引擎use完后assign（赋值）至工作内存\n5. store：线程用完flag变量后store至工作内存的变量副本中，对应load操作\n6. write：将store操作从工作内存中得到的变量放入主内存的变量中，对应read\n7. lock：加锁，把一个变量标识位线程独占状态\n8. unlock：解锁，将一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定\n\n![image-20200516221312702](https://i.loli.net/2020/05/16/pfR1u5aGl4As8ZY.png)\n\nJMM对着8种指令的使用制定了如下规则：\n\n1. 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须 write 。\n2. 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存 。\n3. 不允许一个线程将没有assign的数据从工作内存同步回主内存 。\n4. 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量 。\n5. 实施use、store操作之前，必须经过assign和load操作 。\n6. 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁 。\n7. 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前， 必须重新load或assign操作初始化变量的值 。\n8. 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量 对一个变量进行unlock操作之前，必须把此变量同步回主内存。\n\n# Volatile\n\n> 面试题：请你谈谈你对Volatile的理解\n\nVolatile 是 Java 虚拟机提供的轻量级的同步机制\n\n1. 保证可见性\n2. 不保证原子性\n3. 禁止指令重排\n\n## 保证可见性\n\n可见性：一个线程对共享变量的修改，更够及时的被其他线程看到。\n\n```java\n/**\n * 测试保证可见性\n */\nprivate static int num = 0;\n\npublic static void main(String[] args) throws InterruptedException {\n    new Thread(() -> {\n        // num为线程A与main线程的共享变量，但是由于不可见性，A线程无法指定主存中num的变化，所以会一直卡在while循环。\n        while (num == 0) ;\n    }, \"A\").start();\n\n    TimeUnit.SECONDS.sleep(1);\n\n    // main线程将主存中的num的值改为1\n    num = 1;\n    System.out.println(Thread.currentThread().getName() + \"将num修改为1\");\n}\n```\n\n将`private static int num = 0`修改为`private volatile static int num = 0`后，主存中的num变量对A可见，A能及时感知到num的变化，当num为1的时候，就不会卡在while循环。\n\n这就体现了可见性。\n\n## 不保证原子性\n\n原子性：不可分割的操作\n\n线程A在执行操作的时候，是不能被打扰的，也不能被分割，要么同时成功，要么同时失败。\n\n```java\npublic volatile static int num = 0;\n\npublic static void add(){\n    /**\n     * num++对应的字节码指令为：\n     *  getstatic \n     *  iconst_1\n     *  iadd\n     *  putstatic\n     *  return\n     *  所以num++的操作是非原子性的。\n     */\n    num++;\n}\n\npublic static void main(String[] args) {\n    // 理论上num最后的结果应该是20000，\n    for (int i = 1; i <= 20; i++){\n        new Thread(() -> {\n            for (int j = 0; j < 1000; j++){\n                add();\n            }\n        }).start();\n    }\n    while (Thread.activeCount() > 2) {   // GC main\n        Thread.yield();\n    }\n    System.out.println(Thread.currentThread().getName() + \" \" + num);\n}\n```\n\n从上面代码及运行结果可以知道volatile是不保证原子性的。\n\n> 通过对add()加锁可以保证原子性，那不加锁怎么保证原子性呢？\n\nJUC包下有很多原子类\n\n![image-20200517093629661](https://i.loli.net/2020/05/17/fEmKaLjc41piMQ8.png)\n\n```java\npublic volatile static AtomicInteger num = new AtomicInteger();\n\npublic static void add(){\n    num.getAndIncrement();\n}\n\npublic static void main(String[] args) {\n    // 理论上num最后的结果应该是20000，\n    for (int i = 1; i <= 20; i++){\n        new Thread(() -> {\n            for (int j = 0; j < 1000; j++){\n                add();\n            }\n        }).start();\n    }\n    while (Thread.activeCount() > 2) {   // GC main\n        Thread.yield();\n    }\n    System.out.println(Thread.currentThread().getName() + \" \" + num);\n}\n```\n\n这样就得到了正确结果\n\n## 禁止指令重排\n\n> 什么是指令重排\n>\n> 你写的程序，计算机并不是按照你写的那样的顺序去执行的。\n>\n> 源代码>编译器优化的重排>指令并行也可能会重排>内存系统也会重排>执行\n\n但是计算机在重排指令的时候，也不会乱排：它会考虑数据的依赖性！\n\n```\nint x = 1; // 1 \nint y = 2; // 2 \nx = x + 5; // 3 \ny = x * x; // 4\n我们所期望的：1234 \n但是可能执行的时候会变成 2134、1324 \n但不可能是  4123！因为要考虑数据的依赖性\n```\n\n再看下面这个例子，a、b、x、y这四个值默认都是0\n\n| 线程A | 线程B |\n| ----- | ----- |\n| x=a   | y=b   |\n| b=1   | a=2   |\n\n但是由于指令重排，执行的顺序可能会变成这样：\n\n| 线程A | 线程B |\n| ----- | ----- |\n| b=1   | a=2   |\n| x=a   | y=b   |\n\n造成我们意料之外的结果：x=2，y=1。\n\n### 内存屏障\n\nvolatile可以避免指令重排，而原理就是内存屏障。\n\n内存屏障是一种屏障指令，它使CPU或编译器对屏障指令之前和之后发出的内存操作执行一个排序约束。 这通常意味着在屏障之前发布的操作被保证在屏障之后发布的操作之前执行。\n\n屏障一共分为四种类型：\n\n**LoadLoad屏障**：\n\n抽象场景：Load1; LoadLoad; Load2\n\nLoad1 和 Load2 代表两条读取指令。在Load2要读取的数据被访问前，保证Load1要读取的数据被读取完毕。\n\n**StoreStore屏障：**\n\n抽象场景：Store1; StoreStore; Store2\n\nStore1和 Store2代表两条写入指令。在Store2写入执行前，保证Store1的写入操作对其它处理器可见\n\n**LoadStore屏障：**\n\n抽象场景：Load1; LoadStore; Store2\n\n在Store2被写入前，保证Load1要读取的数据被读取完毕。\n\n**StoreLoad屏障：**\n\n抽象场景：Store1; StoreLoad; Load2\n\n在Load2读取操作执行前，保证Store1的写入对所有处理器可见。**StoreLoad屏障的开销是四种屏障中最大的**。\n\n# 玩转单例模式\n\nvolatile在单例模式模式中非常有用，在实例化对象的时候会有指令重排，造成线程不安全，volatile可以解决此问题。\n\n先上实现单例模式的几种方法的代码\n\n```java\npackage single;\n\npublic class Singleton {\n\n//    // 1.懒汉式[线程不安全]\n//    //这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。\n//    private static Singleton instance;\n//\n//    private Singleton() {\n//    }\n//\n//    public static Singleton getInstance(){\n//        if(instance == null){\n//            instance = new Singleton();\n//        }\n//        return instance;\n//    }\n\n//    // 2.懒汉式[线程安全][效率低]\n//    //这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。\n//    private static Singleton instance;\n//\n//\n//    public synchronized static Singleton getInstance() {\n//        if (instance == null) {\n//            instance = new Singleton();\n//        }\n//        return instance;\n//    }\n\n//    // 3.饿汉式\n//    /*\n//    描述：这种方式比较常用，但容易产生垃圾对象。\n//    优点：没有加锁，执行效率会提高。\n//    缺点：类加载时就初始化，浪费内存。\n//    它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，\n//    虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，\n//    这时候初始化 instance 显然没有达到 lazy loading 的效果。\n//     */\n//    private static Singleton instance = new Singleton();\n//\n//    private Singleton(){}\n//\n//    public static Singleton getInstance() {\n//        return instance;\n//    }\n\n//    // 4.双检锁/双重校验锁（DCL，即 double-checked locking）\n//    // 这种方式采用双锁机制，安全且在多线程情况下能保持高性能\n//    private static volatile Singleton instance;\n//\n//    private Singleton() {\n//    }\n//\n//    public static Singleton getInstance() {\n//        if (instance == null) {\n//            synchronized (Singleton.class) {\n//                if (instance == null)\n//                    /* 1. 分配内存空间 * 2、执行构造方法，初始化对象 * 3、把这个对象指向这个空间 */\n//                    /* 指令重排可能会导致1、2、3顺序错乱，volatile通过添加内存屏障禁止指令重排。*/\n//                    instance = new Singleton();\n//            }\n//        }\n//\n//        return instance;\n//    }\n\n    // 5.登记式/静态内部类\n    /*\n    采用静态内部类的形式可以达到同样的效果，而且代码更加简单。\n    这种方式是就算Singleton被加载了,INSTANCE也不一定被实例化。\n    SingletonHolder，只有显示调用了getInstance()方法时，\n    才会显示装载SingletonHolder类，这个时候INSTANCE才会被实例化。\n     */\n    private static class SingletonHolder {\n        private static final Singleton instance = new Singleton();\n    }\n\n    private Singleton() {\n    }\n\n    public static final Singleton getInstance() {\n        return SingletonHolder.instance;\n    }\n\n}\n```\n\n你以为这样就安全了吗？我们还可以利用反射去打破单例模式！\n\n```java\npublic class TestSingleton {\n    //你以为这就安全了吗？利用反射去打破单例模式！\n    public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException {\n        // 利用正规方法获取到singleton实例\n        Singleton singleton1 = Singleton.getInstance();\n        // 利用反射获取到singleton实例\n        Constructor<Singleton> constructor = Singleton.class.getDeclaredConstructor();\n        constructor.setAccessible(true);\n        Singleton singleton2 = constructor.newInstance();\n        \n        System.out.println(singleton1.equals(singleton2));  //false\n    }\n}\n```\n通过上面的的反射我们居然获取到了两个实例，这明显违背了单例模式。\n尝试去解决这个问题，在构造器中加锁！\n\n```java\nprivate Singleton() {\n    synchronized (Singleton.class) {\n        if (instance != null) {\n            throw new RuntimeException(\"不要试图用反射去破坏单例模式！\");\n        }\n    }\n}\n```\n\n再次输出\n\n```java\nException in thread \"main\" java.lang.reflect.InvocationTargetException\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat single.TestSingleton.main(TestSingleton.java:18)\nCaused by: java.lang.RuntimeException: 不要试图用反射去破坏单例模式！\n\tat single.Singleton.<init>(Singleton.java:55)\n\t... 5 more\n```\n\n但是这样还是不安全的\n\n如果我们这样去反射，直接利用反射去得到两个实例！\n\n```java\npublic class TestSingleton {\n    //你以为这就安全了吗？利用反射去打破单例模式！\n    public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException {\n//        // 利用正规方法获取到singleton实例\n//        Singleton singleton1 = Singleton.getInstance();\n        // 利用反射获取到singleton实例\n        Constructor<Singleton> constructor = Singleton.class.getDeclaredConstructor();\n        constructor.setAccessible(true);\n        Singleton singleton1 = constructor.newInstance();\n        Singleton singleton2 = constructor.newInstance();\n\n        System.out.println(singleton1.equals(singleton2));  //false\n    }\n}\n```\n\n还是成功获取到了两个实例\n\n通过设置一个标志位去解决这个问题！\n\n```java\nprivate static boolean singletonFlag = false;\nprivate Singleton() {\n    synchronized (Singleton.class) {\n        if (singletonFlag == false) {\n            singletonFlag = true;\n        }else {\n            throw new RuntimeException(\"不要试图用反射去破坏单例模式！\");\n        }\n    }\n}\n```\n\n这样就得不到两个实例了，我们还可以对singletonFlag这个变量进行加密，这样别人就找不到这个变量了，就不能改变这个变量的值。\n\n但是再牛逼的加密也有更牛逼的人解密，万一别人解密出来了，去改变这个变量的值，单例模式又再次被打破！\n\n```java\npublic class TestSingleton {\n    //你以为这就安全了吗？利用反射去打破单例模式！\n    public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException, NoSuchFieldException {\n        // 假设SingletonFlag被解密出来了，尝试去改变它的值。\n        Field singletonFlag = Singleton.class.getDeclaredField(\"singletonFlag\");\n        singletonFlag.setAccessible(true);\n        Constructor<Singleton> constructor = Singleton.class.getDeclaredConstructor();\n        constructor.setAccessible(true);\n        Singleton singleton1 = constructor.newInstance();\n        singletonFlag.set(singleton1, false);\n        Singleton singleton2 = constructor.newInstance();\n\n        System.out.println(singleton1.equals(singleton2));  //false\n    }\n}\n```\n\n这样就又得到了两个变量\n\n**最后一种方式：使用枚举去完成单例模式！**\n\n```java\npublic enum EnumSingleton {\n    INSTANCE;\n}\n```\n\n这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。\n这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。\n\n# 深入理解CAS\n\n## CAS原理\n\n什么是CAS？\n\n>CAS即CompareAndSwap，比较并交换，CAS有三个操作参数：内存地址、期望值、要修改的新值。当期望值和内存当中的值进行比较不相等的时候，表示内存中的值已经被别线程改动过，这时候失败返回，只有相等时，才会将内存中的值改为新的值，并返回成功。\n\n这里我们可以看一下JAVA的原子类AtomicLong.getAndIncrement()的实现，来理解一下CAS这一乐观锁（JDK 1.8）。\n\n```java\npublic final long getAndIncrement() {\n   return unsafe.getAndAddLong(this, valueOffset, 1L);\n}\n```\n\n接着看一下 Unsafe.getAndAddLong()的实现：\n\n```java\npublic final long getAndAddLong(Object var1, long var2, long var4) {\n   long var6;\n   do {\n       var6 = this.getLongVolatile(var1, var2);\n   } while(!this.compareAndSwapLong(var1, var2, var6, var6 + var4));\n   return var6;\n}\n```\n\n这里我们可以看到AtomicLong.getAndIncrement()的实现就是通过CAS循环操作的实现，只有期望值与真实值相同情况下，CAS操作才会成功执行，退出循环，如果失败则继续**自旋**，直到成功。\n\nCAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。\n\n##  CAS缺点\n\nCAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。\n\n1. 循环时间长开销很大。\n2. 只能保证一个共享变量的原子操作。\n3. ABA问题。\n\n## ABA问题\n\n如果内存地址V初次读取的值是A，并且在准备赋值的时候检查到它的值仍然为A，那我们就能说它的值没有被其他线程改变过了吗？\n\n如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。\n\n### 解决办法\n\nABA问题的解决思路是，每次变量更新的时候把变量的**版本号**加1，那么A-B-A就会变成A1-B2-A3，只要变量被某一线程修改过，改变量对应的版本号就会发生递增变化，从而解决了ABA问题。在JDK的java.util.concurrent.atomic包中提供了AtomicStampedReference来解决ABA问题，该类的compareAndSet是该类的核心方法，实现如下：\n\n```java\npublic boolean compareAndSet(V   expectedReference,\n                            V   newReference,\n                            int expectedStamp,\n                            int newStamp) {\n   Pair<V> current = pair;\n   return\n       expectedReference == current.reference &&\n       expectedStamp == current.stamp &&\n       ((newReference == current.reference &&\n         newStamp == current.stamp) ||\n        casPair(current, Pair.of(newReference, newStamp)));\n}\n```\n\n我们可以发现，该类检查了当前引用与当前标志是否与预期相同，如果全部相等，才会以原子方式将该引用和该标志的值设为新的更新值，这样CAS操作中的比较就不依赖于变量的值了。\n\n### 场景重现\n\n```java\n//AtomicStampedReference 注意，如果泛型是一个包装类，注意对象的引用问题        // 正常在业务操作，这里面比较的都是一个个对象\nstatic AtomicStampedReference<Integer> atomicStampedReference = new AtomicStampedReference<>(1, 1);\n\n// CAS  compareAndSet : 比较并交换！\npublic static void main(String[] args) {\n    new Thread(() -> {\n        int stamp = atomicStampedReference.getStamp(); // 获得版本号            System.out.println(\"a1=>\"+stamp);\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        atomicStampedReference.compareAndSet(1, 2, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);\n        System.out.println(\"a2=>\" + atomicStampedReference.getStamp());\n        System.out.println(atomicStampedReference.compareAndSet(2, 1, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1));\n        System.out.println(\"a3=>\" + atomicStampedReference.getStamp());\n    }, \"a\").start();\n    // 乐观锁的原理相同！\n    new Thread(() -> {\n        int stamp = atomicStampedReference.getStamp();\n        // 获得版本号\n        System.out.println(\"b1=>\" + stamp);\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        } catch (\n                InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(atomicStampedReference.compareAndSet(1, 6, stamp, stamp + 1));\n        System.out.println(\"b2=>\" + atomicStampedReference.getStamp());\n    }, \"b\").start();\n}\n```\n\n**注意：**\n**Integer 使用了对象缓存机制，默认范围是 -128 ~ 127 ，推荐使用静态工厂方法 valueOf 获取对象实例，而不是 new，因为 valueOf 使用缓存，而 new 一定会创建新的对象分配新的内存空间；**\n\n![image-20200523222720833](https://i.loli.net/2020/05/23/Y2nPyQVmB9j1Fob.png)\n\n# 几种锁\n\n## 死锁\n\n如果有两个线程A和B同时进行，如果线程A拿到了锁1，同时去申请锁2，而线程B到了锁2并申请锁1，因为锁2在B手里，A就拿不到，A就一直等待；同理锁1在A手里，B也拿不到，就一直等待。这就造成了**死锁**现象。\n\n![img](https://i.loli.net/2020/05/24/iv6EIZp34xursCb.jpg)\n\n### JAVA代码重现死锁场景\n\n```java\npackage lock;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author ZhengHaoYun\n * @create 2020/5/24 17:01\n */\npublic class DeadLockDemo {\n\n    public static void main(String[] args) {\n        String lockA = \"lockA\";\n        String lockB = \"lockB\";\n        new Thread(new MyThread(lockA, lockB), \"T1\").start();\n        new Thread(new MyThread(lockB, lockA), \"T2\").start();\n\n    }\n\n}\n\nclass MyThread implements Runnable {\n    private String lockA;\n    private String lockB;\n\n    public MyThread(String lockA, String lockB) {\n        this.lockA = lockA;\n        this.lockB = lockB;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lockA) {\n            System.out.println(Thread.currentThread().getName() + \"lock:\" + lockA + \"=>get\" + lockB);\n            try {\n                TimeUnit.SECONDS.sleep(2);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            synchronized (lockB) {\n                System.out.println(Thread.currentThread().getName() + \"lock:\" + lockB + \"=>get\" + lockA);\n            }\n        }\n    }\n}\n```\n\nT1拿到lockA，然后休眠2秒，在这两秒内，T2拿到lockB。2秒后T1去获取lockB，T2去获取lockA，但是都拿不到，造成死锁现象。\n\n### 解决\n\n我查了下百度百科，大概有这几种办法去解决吧：\n\n1. 死锁预防\n\n   1. 当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。\n   2. 采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。\n   3. 实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源\n\n   死锁预防有个著名的算法：银行家算法\n\n2. 死锁避免\n\n   系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源；如果分配后系统可能发生死锁，则不予分配，否则予以分配。这是一种保证系统不进入死锁状态的动态策略。\n\n3. 死锁排查\n\n   1. 使用 `jps -l` 定位进程号\n\n   ![image-20200524172207756](https://i.loli.net/2020/05/24/92vm7NBhztkUqw3.png)\n   2. 使用 `jstack 进程号 `找到死锁问题\n\n   ![image-20200524172326499](https://i.loli.net/2020/05/24/dcQTuta1oMELPjp.png)\n\n## 可重入锁\n\n可重入锁其实就是字面意思，**可重入！**浅显的讲就是你进了朋友的家，那你就也可以进朋友的卧室去参观参观了！\n\n大多数的内置锁都是可重入的，用专业的话讲也就是说**如果某个线程尝试获取一个它已经持有的锁的时，那么这个请求就会立刻成功**，并且会将这个锁的计数值+1（可重入锁会有一个计数值），而当线程退出同步代码块的时候，计数值会-1，当计数值为0的时候，锁会释放。\n\n<img src=\"https://i.loli.net/2020/05/24/XmTxrionLBFuYMq.png\" alt=\"image-20200524230850873\" style=\"zoom:150%;\" />\n\n自己实现的可重入锁\n\n```java\nclass MyReLock {\n    private boolean isLocked = false;\n    private Thread lockedBy = null; //存储哪个线程拿了锁\n    private int holdCount = 0;  //计数器\n\n    public void lock() throws InterruptedException {\n        Thread thread = Thread.currentThread();\n        while (isLocked && !lockedBy.equals(thread)) wait();\n        isLocked = true;\n        lockedBy = thread;\n        holdCount++;\n    }\n\n    public void unlock() {\n        if (Thread.currentThread().equals(lockedBy)) {\n            holdCount--;\n            if (holdCount == 0) {\n                isLocked = false;\n                notify();\n                lockedBy = null;\n            }\n        }\n    }\n}\n```\n\n## 自旋锁\n\n是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。\n\n### 优点\n\n自旋锁的原理比较简单，如果持有锁的线程能在短时间内释放锁资源，那么那些**等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态**，它们只需要等一等(自旋)，等到持有锁的线程释放锁之后即可获取，这样就避免了用户进程和内核切换的消耗。\n\n### 缺点\n\n1. 导致死锁\n\n> [死锁](https://baike.baidu.com/item/死锁)。试图递归地获得自旋锁必然会引起死锁：递归程序的持有实例在第二个实例循环，以试图获得相同自旋锁时，不会释放此自旋锁。在递归程序中使用自旋锁应遵守下列策略：递归程序决不能在持有自旋锁时调用它自己，也决不能在[递归调用](https://baike.baidu.com/item/递归调用)时试图获得相同的自旋锁。此外如果一个进程已经将资源锁定，那么，即使其它申请这个资源的进程不停地疯狂“自旋”,也无法获得资源，从而进入[死循环](https://baike.baidu.com/item/死循环)。\n\n2. 过多占用[cpu](https://baike.baidu.com/item/cpu)资源\n\n> 过多占用[cpu](https://baike.baidu.com/item/cpu)资源。如果不加限制，由于申请者一直在循环等待，因此自旋锁在锁定的时候,如果不成功,不会睡眠,会持续的尝试,单cpu的时候自旋锁会让其它process动不了. 因此，一般自旋锁实现会有一个参数限定最多持续尝试次数. 超出后, 自旋锁放弃当前time slice. 等下一次机会。\n\n具体关于死锁的可以看[这篇文章](https://www.cnblogs.com/cxuanBlog/p/11679883.html) \n\n\n\n# 完结\n\n至此关于JUC的笔记就到此结束了，完结撒花~","tags":["JUC"],"categories":["JUC"]},{"title":"Ubuntu 18.04搭建FTP服务器","url":"/Linux/Ubuntu 18.04搭建FTP服务器","content":"本次安装基于Ubuntu 18.04，其他系统在命令上有所不同。\n\n<!--more-->\n\n### 安装FTPD\n\n```\napt install vsftpd\n```\n\n![](https://pic.downk.cc/item/5e9d72e5c2a9a83be5910c48.png)\n\n### 增加新用户\n\n增加新用户ftpuser并设置其密码为123456\n\n```\nadduser ftpuser\n```\n\n![](https://pic.downk.cc/item/5e9d731bc2a9a83be591332d.png)\n\n### 修改ftp配置文件\n\n```\nvim /etc/vsftpd.conf \n```\n\n按下G跳到最后一行，在末尾增加以下内容：\n\n[FTP配置参数详解](https://blog.csdn.net/miss520jenny/article/details/90693677)\n\n```\nuserlist_deny=NO\nuserlist_enable=YES\nuserlist_file=/ect/vsftpd.user_list\nseccomp_sandbox=NO\nlocal_root=/home/ftpuser/\nlocal_enable=YES\nwrite_enable=YES\nutf8_filesystem=YES\n```\n\n进入etc目录并新建文件vsftpd.user_list \n\n```\ncd /etc\nvim vsftpd.user_list \n```\n\n增加以下内容\n\n```\nftpuser\nzhenghaoyun\t\t\t#这个你可以写另外一个用户，我这里写的是zhenghaoyun用户，也可以不写。\n```\n\n![](https://pic.downk.cc/item/5e9d7363c2a9a83be5917e01.png)\n\n### 重启ftp服务器\n\n```\n/etc/init.d/vsftpd restart\n```\n\n![](https://pic.downk.cc/item/5e9d7375c2a9a83be5918fa0.png)\n\n### 开始测试\n\n在浏览器中输入ftp://你的IP地址  (如 ftp://11.11.11.11) 后弹出登录窗口\n\n![](https://pic.downk.cc/item/5e9d7384c2a9a83be5919e24.png)\n\n输入ftpuser的账号密码即可成功访问\n\n![](https://pic.downk.cc/item/5e9d7393c2a9a83be591aecd.png)","tags":["Linux","FTP"],"categories":["Linux"]},{"title":"从初识DNS到搭建DNS服务器","url":"/Linux/从初识DNS到搭建DNS服务器","content":"写一个网站很简单，大多数人都能胜任，但是向一个外行的人如何展示你的网站呢？我们会想到把自己的网站部署到服务器上去，每台服务器都会对应一串数字（如123.xx.xxx.xxx），这个就是我们的IP地址，我们通过这个IP地址就可以访问到我们的网站。记一个IP地址都够呛，更何况世界上的IP地址那么多，然后我们就又买了一个域名（如zhenghaoyun.cn)，通过这个域名就可以访问到我们的网站。\n\n为什么通过域名就能访问到网站？这就是DNS的作用，我们在浏览器输入域名时，DNS将域名“翻译”成IP地址，然后我们就可以访问到服务器了，自然而然就可以看到网站了。\n\n<!--more-->\n\n## DNS原理\n\n### 简介\n\nDNS的中文名叫做域名解析协议，它用于域名与IP地址的互换。能够使人便捷的访问互联网，而不用记住能够被机器识别的IP地址。\n\n每一个域名都对应了一个IP地址，一个IP地址可能对应了多个域名，所以多个域名可以同时被解析到一个IP地址。域名解析需要由专门的DNS服务器完成。\n\n### DNS服务器\n\nDNS服务器是指运行DNS服务器程序的计算机，储存DNS的数据信息。DNS服务器会尝试解析客户机的查询请求。就如同你（客户机）想给小明（域名）打电话，然后你拨打小明的电话，这个时候通讯录（DNS服务器）查到小明的电话是138xxxxxxxx，你就顺利的拨出了电话。\n\n### DNS缓存\n\n世界上几乎每个人都拥有1个以上的电话号码，如果你想给一个人打电话，但是你没有他的电话号码怎么办？世界上也没有一本通讯录记录着所有人的电话号码，这个时候你可能去问亲朋好友，问到后你为了方便就会将他的电话号码存在自己的手机里。\n\nDNS服务器在解析客户机的请求时，如果本地没有该DNS信息，会去询问其他DNS服务器，当从其他DNS服务器得到查询结果时，该DNS服务器会将结果记录在本地的DNS缓存中，成为DNS缓存地址。\n\n当下一次客户机提交相同的请求时，DNS服务器能够直接使用缓存中的DNS信息进行解析。\n\n### DNS解析过程\n\nDNS解析过程就拿访问 www.163.com 来举例吧。www.163.com 其实完整的写法是 www.163.com. ，注意com后面有个`.`。我们在平常都是将这个`.`给省略了的。\n\n#### DNS域名层次结构\n\n在了解DNS解析过程前，先了解下DNS域名的层次结构，DNS域名是分层次的且以`.`进行分割，而且是从后面开始的，分别为：\n\n* 根域（ www.163.com. 最后的那个`.`）\n* 顶级域（.com）\n* 二级域（.163.com）\n* 子域（ www.163.com 只分了四层，所以子域是 www.163.com ）\n* 主机名，通常情况下是指域名的最左侧的标签标识网络上的特定计算机（如 h1.www.qq.com ）\n\n\n\n#### 解析过程\n\n1. 客户机请求本地DNS服务器查询 www.163.com 对应的缓存信息，如果查到直接返回给客户机，如果没有查到去询问根服务器。\n2. 根服务器发现这个域名是.com，返回给本地DNS服务器.com域服务器的地址。\n3. 本地DNS服务器通过.com域服务器的地址找到.com域服务器并询问。\n4. .com域服务器又说.163.com域服务器可以帮到你，并且告诉了.163.com域服务器的地址。\n5. 本地DNS服务器又找到了.163.com域服务器，并询问 www.163.com 对应的IP地址是多少。\n6. .163.com域服务器经查询得知IP地址为1.1.1.1，然后告诉了本地DNS服务器。\n7. 本地DNS服务器将此IP地址写入缓存，然后告诉了客户机。\n8. 客户机得到IP地址，欣喜若狂。\n\n![](https://pic.downk.cc/item/5e9c237dc2a9a83be511c0a8.jpg)\n\n<center>图片来源于网络</center>\n\n\n\n### DNS查询方式\n\n上面的DNS解析过程多次提到了查询，DNS查询的方式分为两种：\n\n* **递归查询**：也就是说我问你，你找不到，你去问别人。别人找不到，再再去问，找到了就一层一层向上返回最终给我。在该模式下DNS 服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机。如果DNS 服务器本地没有存储查询DNS 信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机。\n* **迭代查询**：我问你，你不知道，但是你告诉我另一个服务器，让我去那里找。类似相关部门踢皮球。DNS 服务器会向客户机提供其他能够解析查询请求的DNS 服务器地址，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，而是告诉客户机另一台DNS 服务器地址，客户机再向这台DNS 服务器提交请求，依次循环直到返回查询的结果为止。\n\n客户端和本地DNS使用递归查询，本地DNS找不到会去其他的服务器找，但是其他服务器与本地DNS服务器之间通常是迭代查询，毕竟服务器查询压力很大的，不能帮每个人都去找，只能告诉他你去哪找。\n\n\n\n## DNS服务器搭建\n\n本次安装基于CentOS 6.8，其他版本可能会有所出入。\n\n### 安装BIND\n\n`yum install bind`\n\n`yum install bind-chroot`\n\n`yum install bind-utils`\t默认已安装\n\n显示完毕即安装成功\n\n> BIND是一种开源的DNS（Domain Name System）协议的实现，包含对域名的查询和响应所需的所有软件。它是互联网上最广泛使用的一种DNS服务器，对于类UNIX系统来说，已经成为事实上的标准。\n>\n> BIND-chroot是BIND的一个功能，使得BIND在chroot模式下运行，提高安全性。\n\n### 启动named服务\n\n开启named服务后，会自动挂载调用chroot功能。\n\n`service named restart`\n\n![](https://pic.downk.cc/item/5e9c4e62c2a9a83be54d34dc.jpg)\n\n使用`ifconfig`查看到本机的IP地址为192.168.254.128，记录下你自己的IP地址，后续要使用到。\n\n![](https://pic.downk.cc/item/5e9d0ef6c2a9a83be51a3b30.jpg)\n\n使用`cat /etc/resolv.conf`查看DNS服务器地址\n\n![](https://pic.downk.cc/item/5e9c5050c2a9a83be55017ce.jpg)\n\n使用`vim /etc/resolv.conf`将DNS服务器地址修改为本机的IP地址\n\n![](https://pic.downk.cc/item/5e9c5efcc2a9a83be5674b9c.jpg)\n\n### 配置DNS服务器解析\n\n使用`vim /var/named/chroot/etc/named.conf `修改全局配置文件，将下面三处修改为any表示允许任何服务器。\n\n![](https://pic.downk.cc/item/5e9c51b9c2a9a83be55230ad.jpg)\n\n按下G跳到文件末尾，在图中位置添加以下内容。\n\n```\nzone \"zhenghaoyun.cn\" IN {\n\ttype master;\n\tfile \"zhenghaoyun.cn.zone\";\n};\n```\n\n![](https://pic.downk.cc/item/5e9c5366c2a9a83be554ca70.jpg)\n\n### 创建ZONE文件\n\n进入此目录\n\n```\ncd /var/named/chroot/var/named/\n```\n\n创建ZONE文件\n\n```\ncp -rp named.localhost zhenghaoyun.cn.zone\n```\n\n修改此文件\n\n```\nvim zhenghaoyun.cn.zone \n```\n\n修改为以下内容\n\n![](https://pic.downk.cc/item/5e9c582ac2a9a83be55c5a11.jpg)\n\n```\n$TTL 1D\n@       IN SOA  ns.zhenghaoyun.cn.        admin.zhenghaoyun.cn (\n                                        0       ; serial\n                                        1D      ; refresh\n                                        1H      ; retry\n                                        1W      ; expire\n                                        3H )    ; minimum\n        NS      ns.zhenghaoyun.cn.\nns      A       192.168.254.128\t\t\t#这里填你自己的Linux主机的IP地址\nwww     A       192.168.254.128\t\t\t#这里填你自己的Linux主机的IP地址\nsmtp    CNAME   mail.zhenghaoyun.cn.\n```\n\n## 测试\n\n退出named目录\n\n```\ncd ~\n```\n\n重启服务\n\n```\n service named restart\n```\n\n如果如下图所示正常启动，说明你的配置是没有问题的。如果有问题，就检查自己的配置有没有问题，有没有漏掉标点符号，这一步相对来说比较复杂。\n\n![](https://pic.downk.cc/item/5e9c6533c2a9a83be57094db.jpg)\n\n查看DNS\n\n```\nnslookup www.zhenghaoyun.cn\n```\n\n![](https://pic.downk.cc/item/5e9c63f9c2a9a83be56efbbe.jpg)\n\n从图中我们可以看到成功获取到地址！至此大功告成！\n\n\n\n## 总结\n\nDNS服务器是很重要的一环，本人之前对DNS一点表面的认识，此次加强了对DNS的理解，但是总感觉在搭建过程中对一些东西的理解有所纰漏，如果发现问题，欢迎指出，共同进步。","tags":["Linux","DNS"],"categories":["Linux"]},{"title":"怎样写一个Singleton？","url":"/设计模式/怎样写一个Singleton？","content":"“写一个Singleton实例”这是一个高频的面试题，这里面也涉及到很多的小细节，如：静态代码块、线程安全、枚举类等等。\n\n<!--more-->\n\n## 简介\n单例模式能保证在创建类的时候只有一个对象实例，什么意思呢？就如同一个盒子里面只装了一个小球，你去盒子里面拿小球，永远都是这一个小球，也就是说我们去取一个类的对象时，不需要再实例化该类的对象，就能取到这个类的实例对象，而且一直都是同一个。\n总的来说单例模式提供了一种访问其唯一对象的方式，可以直接访问，不需要实例化该类的对象。\n### 注意\n* 单例类只有一个实例\n    * 含有一个静态变量来保存这个对象的唯一实例\n* 单例类必须自己创建自己的唯一实例\n    * 构造器私有化\n* 单例类必须给其他对象提供这一实例\n    * 直接暴露给其他对象\n    * 其他对象使用get方法获取\n\n\n\n## 饿汉式单例模式\n\n饿汉式这个取名是很形象的，一个人饿的时候就需要立即吃饭。所以采用饿汉式的时候在单例类被加载的时候就立马会创建单例对象。因为在类加载的时候就创建了对象了，所以不存在线程安全的问题。\n### 直接实例化饿汉式\n采用这种方式比较简洁直观，如果我们要获取这个对象单例，就直接使用`Singleton1.INSTANCE`获取就可以了。\n```java\npublic class Singleton1 {\n\tpublic static final Singleton1 INSTANCE = new Singleton1();\n\tprivate Singleton1(){\n    \n\t}\n}\n```\n### 枚举式\n采用枚举的方式是最简洁的。\n```java\n/*\n * 枚举类型：表示该类型的对象是有限的几个\n * 我们可以限定为一个，就成了单例\n */\npublic enum Singleton2 {\n\tINSTANCE\n}\n```\n### 静态代码块饿汉式\n静态代码块饿汉式的代码相对于前两者是比较复杂的，那么我们为什么还要采用这种形式呢？\n是因为我们有时候需要加载外部文件的内容，将其内容传递给对象。像下面的代码，我们需要得到`single.properties`中的`info`的值，然后利用info的值进行有参构造。这个时候我们就不能一行代码搞定了，需要使用到静态代码块。而静态代码块里面的代码是在类加载的时候就会执行，早于构造函数。\n[Java中静态代码块详解](https://blog.csdn.net/qq_35868412/article/details/89360250)\n```java\npublic class Singleton3 {\n\tpublic static final Singleton3 INSTANCE;\n\tprivate String info;\n\t\n\tstatic{\n\t\ttry {\n\t\t\tProperties pro = new Properties();\t\t\t\n\t\t\tpro.load(Singleton3.class.getClassLoader().getResourceAsStream(\"single.properties\"));\n\t\t\tINSTANCE = new Singleton3(pro.getProperty(\"info\"));\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\t\n\tprivate Singleton3(String info){\n\t\tthis.info = info;\n\t}\n\n    //省略不重要的方法...\n\t\n}\n```\n\n## 懒汉式单例模式\n懒汉式延迟创建在个类的实例对象，是指在需要找个单例类的对象时，才会创建这个类的对象。\n### 线程不安全的写法\n这种写法适合单线程\n```java\npublic class Singleton4 {\n\tprivate static Singleton4 instance;\n\tprivate Singleton4(){\n\t\t\n\t}\n\tpublic static Singleton4 getInstance(){\n\t\tif(instance == null){\n        //这种写法会导致线程不安全，当有两个线程同时请求获取实例时，这个两个线程都会进入到此if分支\n        //内，那么就会创建两个不同的实例，违背了单一实例的原则。\n\t\t\tinstance = new Singleton4();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n### 线程安全的写法\n这种写法适合多线程，并且是线程安全的。\n首先我们使用`synchronized`作用于一个给定的实例对象instance，即当前实例对象就是锁对象，每次当线程进入synchronized包裹的代码块时就会要求当前线程持有instance实例对象锁，如果当前有其他线程正持有该对象锁，那么新到的线程就必须等待，这样也就保证了每次只有一个线程进入这个if分支。当然除了instance作为对象外，我们还可以使用this对象(代表当前实例)或者当前类的class对象作为锁。\n但是这样会有一个问题，就是如果这个类实例早就创建好了也就是说`instance != null`，我们就不必去加锁了，因为新到的线程根本就不会进入到这个分支。所以我们又在`synchronized`的外层再次`if(instance == null)`的判断，这样就使得实例对象存在时，不会进行加锁操作，直接返回instance。\n```java\npublic class Singleton5 {\n\tprivate static volatile Singleton5 instance;\n\tprivate Singleton5(){\n\t\t\n\t}\n\tpublic static Singleton5 getInstance(){\n\t\tif(instance == null){\n\t\t\tsynchronized (Singleton5.class) {\n\t\t\t\tif(instance == null){\n\t\t\t\t\tinstance = new Singleton5();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n### 静态内部类的形式\n前者线程安全的方式采用了双锁机制，但是代码还是比较复杂的。采用静态内部类的形式可以达到同样的效果，而且代码更加简单。\n这种方式是就算Singleton6被加载了,INSTANCE也不一定被实例化。因为静态内部类Inner没有被主动使用，只有显示调用了getInstance()方法时，才会显示装在Inner类，这个时候INSTANCE才会被实例化。\n```java\npublic class Singleton6 {\n\tprivate Singleton6(){\n\t\t\n\t}\n\tprivate static class Inner{\n\t\tprivate static final Singleton6 INSTANCE = new Singleton6();\n\t}\n\t\n\tpublic static Singleton6 getInstance(){\n\t\treturn Inner.INSTANCE;\n\t}\n}\n```\n## 总结\n在一般情况下，都建议使用饿汉式中的直接实例化方式。只有在明确实现懒加载的效果时，才会使用静态内部类的方式去实现懒加载。\n如果要实现反序列化创建对象，那么就可以使用枚举的方式。\n\n>枚举式还没被广泛采用，因为它看起来比较生疏。但是它无疑是单例模式的最佳实现方式，自动支持序列化机制，绝对防止多次实例化。这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。","tags":["单例模式"],"categories":["设计模式"]},{"title":"如何使用Hexo在本地打造属于自己的博客","url":"/博客搭建/如何使用Hexo在本地打造属于自己的博客","content":"## Hexo是什么？\n\nHexo是一个快速、简洁且高效的博客框架，它是一个基于Node.js制作的博客工具，我们可以使用Markdown编写文章，然后Hexo会帮我们生成静态页面。我们将静态页面上传到我们的服务器上，就形成了我们想要的博客。\n\n<!--more-->\n\n### 为什么快速、高效？\n\n因为Hexo使用Markdown解析文章，在几秒内即可生成静态文件。\n\n### 为什么简洁？\n\n因为Hexo的主题库里面提供了数不尽的主题模板，我们可以很轻松的更换我们的主题，可以挑选一个自己喜欢的简洁主题。\n\n---\n\n## Hexo快速上手\n\n本次安装Hexo是基于Windows系统，其他Mac和Linux用户的安装过程也差不多，而Windows其实还是坑最多的，一言不合就出问题。所以我推荐有条件的使用Mac和Linux安装Hexo，有很多东西可以直接通过终端安装，很方便。\n\nLet‘s go.\n\n### 安装Git\n\n如果你没有使用过Git也没有关系，去Git官网上下载一个Git就好，也不用学它的操作，因为我们安装Git的目的是使用它的Git bash，它可以使我们在windows系统上使用Linux的命令，非常的方便，Hexo写好文章也要利用Git上传。\n\n[Git下载](https://Gitforwindows.org/)\n[廖雪峰Git教程](https://www.liaoxuefeng.com/wiki/896043488029600)\n\n如果安装过程中遇到问题可以访问廖雪峰大佬的博客，里面有详细的教程。\n\n### 安装Node.js\n\nHexo是基于Node.js的，所以安装Node.js必不可少。\n\n[Node.js下载](https://nodejs.org/en/download/)\n\n<img src=\"https://pic.downk.cc/item/5e96bc16c2a9a83be593649b.jpg\" alt=\"Node.js下载版本选择\" style=\"zoom:67%;\" />\n\n选择LTS 版本下载即可，Node.js具体安装过程本文不再阐述，若遇问题，可使用搜索引擎。\n\n安装完成后，打开Git Bash，使用`node -v`命令，如果输出Node版本号，则说明安装成功！\n\n### 安装CNPM\n\n为什么使用cnpm而不是npm呢？因为使用npm安装插件是从国外服务器下载，受网络波动影响，经常出现异常。而淘宝团队研发的cnpm是一个完整的npm的国内镜像，所以我们使用cnpm。\n\n当然，我们首先得使用npm下载cnpm。\n\n```\n# 后面跟的是淘宝的镜像源\nnpm install cnpm -g –registry=https://registry.npm.taobao.org\n```\n\n**推荐在windows的cmd（使用管理员身份打开）上输入npm和cnpm的指令，如果在Git Bash上使用，出现问题了你就重试2-3次，如果还是出现问题，你就去cmd上输入指令下载，就成功了，亲测有效！**\n\n<img src=\"https://pic.downk.cc/item/5e96d6a7c2a9a83be5a72b12.png\" style=\"zoom: 67%;\" />\n\n<center><div style=\"color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;\">在Git Bash上使用npm时很多莫名的ERROR</div> </center>\n\n<img src=\"https://pic.downk.cc/item/5e96d842c2a9a83be5a8b74f.jpg\" style=\"zoom:67%;\" />\n\n<center><div style=\"color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;\">在Git Bash上使用cnpm时就舒服了很多，但是还是有很多小块块</div> </center>\n\n<img src=\"https://pic.downk.cc/item/5e96d92fc2a9a83be5a9a002.jpg\" style=\"zoom:67%;\" />\n\n<center><div style=\"color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;\">在cmd上使用cnpm就非常的舒适，而且出错率低！</div> </center>\n\n如果出现问题，重试几次。\n\n安装完成后命令行输入`cnpm -v`查看是否安装成功。\n\n### ※ 安装Hexo\n\n**注意：除了使用cnpm下载的时候，我会去cmd上操作，其他指令我都是在Git Bash上操作的，因为Git Bash还是比cmd好用很多！**\n\n首先找个地方新建一个文件夹test（或者其他名字），**然后`cd Blog`进入**。\n\n去cmd上**使用`cnpm install -g hexo-cli`下载Hexo**，出现问题重试。\n\n依旧使用`hexo -v`查看版本。\n\n**使用`hexo init`初始化Hexo**，这个操作可能耗费几分钟，耐心等待！\n\n<img src=\"https://pic.downk.cc/item/5e96dca1c2a9a83be5ac42b1.jpg\" style=\"zoom: 80%;\" />\n\n忽略`WARN  Failed to install dependencies. Please run 'npm install' manually!`\n\n---\n\n初始化Hexo时**可能出现的问题**：\n\n```\nFATAL D:\\XXX not empty, please run `hexo init` on an empty folder and then copy your files into it\n```\n\n<img src=\"https://pic.downk.cc/item/5e96db6dc2a9a83be5ab6c28.jpg\" style=\"zoom: 80%;\" />\n\n删除XXX目录里的所有文件，再次执行`hexo init`就可以了。\n\n---\n\n执行`cnpm install`，这个是为了下载之前下载失败的依赖。\n\n<img src=\"https://pic.downk.cc/item/5e96de41c2a9a83be5ad24fd.jpg\" style=\"zoom: 67%;\" />\n\n以上操作完成后，指定文件夹的目录结构是这样的：\n\n随着更新迭代可能会有所改变，大体上一致即可。\n\n![](https://pic.downk.cc/item/5e96dec1c2a9a83be5ad6f94.jpg)\n\n- node_modules: 依赖包\n- public：存放生成的页面\n- scaffolds：生成文章的一些模板\n- source：用来存放你的文章\n- themes：主题\n- **_config.yml: 博客的配置文件**\n\n\n\n### 启动Hexo\n\n第一步使用`hexo g`生成静态文件\n\n第二部使用`hexo s`启动服务\n\n<img src=\"https://pic.downk.cc/item/5e96df90c2a9a83be5ade74d.jpg\" style=\"zoom: 80%;\" />\n\n\n\n然后去浏览器输入 http://localhost:4000 就可以看到你创建的博客啦，使用Ctrl+C可以关闭服务！\n\n<img src=\"https://pic.downk.cc/item/5e96e001c2a9a83be5ae35bf.jpg\" style=\"zoom:80%;\" />\n\n至此，就大功告成了！\n\n\n\n## 总结\n\n本教程中所搭建的博客只是一个雏形，之后可能需要完成以下步骤：\n\n1. 修改_config.yml配置文件，满足自己的需求。\n2. 去[Hexo主题库](https://hexo.io/themes/)挑选自己喜欢的主题\n3. 修改主题的配置文件\n4. 配置评论系统\n5. 配置RSS订阅\n6. 站点访问量、文章阅读量统计\n7. 部署到服务器上（如GitHub、Gitee、Coding、云服务器），这里我推荐同时部署到GitHub和Coding上，实现国内外分流。\n8. 绑定域名\n9. 更改为Https\n10. 百度与Google的SEO优化\n\n相信你一定有自己的需求，具体的可以阅读[Hexo官方文档](https://hexo.io/zh-cn/docs/)找到自己想要的东西，Hexo官网是支持中文的，非常的方便！如果之后我有空的话，也会做上述操作的教程！\n\n\n\n","tags":["Hexo"],"categories":["博客搭建"]},{"title":"Java8新特性之Optional","url":"/Java8新特性/Java8新特性之Optional","content":"\n空指针异常是程序中经常会遇到的异常，见怪不怪了，也非常好排错，但是这个异常还是非常的烦人，因为它一旦发生了，就会导致程序终止。于是Java8中引入了Optional，Optional<T>是一个容器类，它可以保存类型T的值，代表这个这个值存在。或者仅仅保存null，代表这个值不存在。原来用null表示一个值不存在，现在可以用Optional可以更好的表达这个概念，并且可以避免空指针异常。\n\n<!--more-->\n\n![](https://pic.downk.cc/item/5ea934cdc2a9a83be517ec19.jpg)\n\n这是Optional的源码，可以看到其中有个value变量，就是用这个value来保存值，所以这个value可以为null，不会发生空指针异常。简而言之，Optional将原来的值进行了封装。\n\n### Optional的使用方法\n\noptional 提供了很多有用的方法，这样我们就不用显示的进行空值判断。具体的可以查看文档或者阅读源码，在这里我就其中的一部分作演示。\n\n![](https://pic.downk.cc/item/5eaabf4fc2a9a83be553156f.jpg)\n\n<center>图片来源于尚硅谷</center>\n\n### 示例\n\n```java\n@Test\npublic void test1() {\n    // 创建一个Person对象\n    Person person = new Person();\n    // 使用Optional.of()创建一个Optional，此时of()内的参数必须不为null。\n    Optional<Person> personOptional1 = Optional.of(person);\n    // 如果person为null\n    person = null;\n    // 那就可以使用Optional.ofNullable()去创建一个Optional\n    Optional<Person> personOptional2 = Optional.ofNullable(person);\n\n    // 使用get()可以获取到Person实例，前提是person不为null，否则抛出异常。\n    Person person1 = personOptional1.get();\n\n    // 如果person为null的话，可以使用orElse(T t)，如果person为null，返回t指定的内容。\n    // 比如说personOptional2内的person为null\n    Person person2 = personOptional2.orElse(new Person(\"小红\"));\n    String name = person2.getName();    //小红\n\n}\n```","tags":["Optional"],"categories":["Java8新特性"]},{"title":"Java8新特性之Stream API","url":"/Java8新特性/Java8新特性之Stream API","content":"\nStream API是Java 8中两大重要改变之一，另外一个是Lambda表达式。\n\n<!--more-->\n\n使用Stream API可以对集合数据进行操作，就类似于使用SQL执行的数据库查询，也可以使用Stream API来并行执行操作。简言之，Stream API提供了一种高效且易于使用的处理数据的方法。\n\nCollection集合和Stream的区别：Collection是一种静态的内存数据结构，而Stream是有关计算的，前者主要面向内存，存储在内存中，后者主要是面向CPU，通过CPU实现计算。\n\n> 集合讲的是数据，Stream讲的是计算！\n\n## 怎样创建Stream\n\n#### 方式一：通过集合\n\n```java\n@Test\npublic void test1() {\n    // 这是一个存放了一些Employee对象的集合\n    List<Employee> employees = new ArrayList<>();\n    employees.add(new Employee(1));\n    employees.add(new Employee(2));\n    employees.add(new Employee(3));\n\n    // 通过stream()返回一个顺序流\n    Stream<Employee> stream = employees.stream();\n\n    // 通过parallelStream()返回一个并行流\n    Stream<Employee> parallelStream = employees.parallelStream();\n    \n\n}\n```\n\n并行流和顺序流的区别是：\n\n* 顺序流按照集合中的顺序取出集合中的元素\n* 并行流创建多个线程去取出集合中的元素，所以取出来的元素顺序不一定是原来的顺序了。\n\n#### 方式二：通过数组\n\n```java\n@Test\npublic void test2(){\n    // 例1.\n    int [] arr = new int[]{1,2,3,4,5,6};\n    IntStream stream = Arrays.stream(arr);\n    \n    // 例2.\n    Employee e1 = new Employee(1);\n    Employee e2 = new Employee(2);\n    Employee [] employees = new Employee[]{e1,e2};\n    Stream<Employee> employeeStream = Arrays.stream(employees);\n}\n```\n\n#### 方式三：通过Stream的of()\n\n```java\n@Test\npublic void test3(){\n    //of()中的内容就相当于一个集合了\n    Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 6);\n}\n```\n\n#### 方式四：创建无限流\n\n```java\n@Test\npublic void test4() {\n    // 迭代 public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)\n    // 第一个参数0为seed（种子），第二个参数是一个Function函数接口。\n    // 通过这条语句，可以实现从0开始不断+2，然后再利用forEach打印这些数字。\n    // forEach()里面需要传一个Consumer函数接口，这里我使用方法引用实现Consumer函数接口。\n    Stream.iterate(0, integer -> integer + 2).forEach(System.out::println);\n}\n```\n\n运行后打印出来的就是无限的偶数。\n\n![](https://pic.downk.cc/item/5ea7f80cc2a9a83be5d398cf.jpg)\n\n```java\n@Test\npublic void test5(){\n    // 生成 public static<T> Stream<T> generate(Supplier<T> s)\n    // 这个方法的作用是生成我们想要的东西\n    // generate()内的参数是一个Supplier函数接口，这里使用方法引用Math::random实现。\n    // 最终可以得到无限的随机数。\n    Stream.generate(Math::random).forEach(System.out::println);\n    \n}\n```\n\n这两种方法（生成和迭代）都是为了生成我们想要的数据，并且可以达到无限的操作。\n\n\n\n## Steam的中间操作\n\n创建好Stream后就可以开始进行Steam的一些中间操作。\n\n#### 筛选与切片\n\n有以下四种操作。\n\n![](https://pic.downk.cc/item/5ea7fa27c2a9a83be5d6383e.jpg)\n\n```java\n@Test\npublic void test6() {\n    List<Employee> employees = new ArrayList<>();\n    employees.add(new Employee());\n    employees.add(new Employee());\n    \n    // filter(Predicate p)——接收 Lambda ， 从流中排除某些元素。\n    Stream<Employee> stream = employees.stream();\n    //练习：查询员工表中薪资大于7000的员工信息\n    stream.filter(e -> e.getSalary() > 7000).forEach(System.out::println);\n    System.out.println();\n    \n    // limit(n)——截断流，使其元素不超过给定数量。\n    // 注意stream在使用过一次后就不能再使用了，这里我在后面会总结，所以我又通过employees.stream()获取了一个新的Stream。\n    employees.stream().limit(3).forEach(System.out::println);\n    System.out.println();\n    \n    // kip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补\n    employees.stream().skip(3).forEach(System.out::println);\n    System.out.println();\n    \n    // distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素\n    employees.stream().distinct().forEach(System.out::println);\n}\n```\n\n#### 映射\n\n![](https://pic.downk.cc/item/5ea90044c2a9a83be5e023c4.jpg)\n\n这里使用一下`map()`和`flatMap()`，其他的都差不太多。\n\n```java\n@Test\npublic void test7() {\n    // map(Function f) —— 接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素。\n    // 下面的代码就实现了将小写字符串变成大写字符串。\n    List<String> list = Arrays.asList(\"aa\", \"bb\", \"cc\", \"dd\");\n    list.stream().map(str -> str.toUpperCase()).forEach(System.out::println);\n\n    System.out.println();\n    //  flatMap(Function f) —— 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。\n    Stream<Character> characterStream = list.stream().flatMap(StreamTest::fromStringToStream);\n    characterStream.forEach(System.out::println);\n}\n\n//将字符串中的多个字符构成的集合转换为对应的Stream的实例\npublic static Stream<Character> fromStringToStream(String str) {//aa\n    ArrayList<Character> list = new ArrayList<>();\n    for (Character c : str.toCharArray()) {\n        list.add(c);\n    }\n    return list.stream();\n\n}\n```\n\n`flatMap()`和`map()`的区别是：\n\n打个比方，假设有一个嵌套集合[1,2,3,4,[5,6]]，里面还有一个[5,6]的子集合，map()在处理这个集合的时候，会将[5,6]当作一个集合来处理，而flatMap()会自动拆分[5,6]，[1,2,3,4,[5,6]]就被flatMap()处理成了[1,2,3,4,5,6]。\n\n所以，map()在处理一个Stream流的时候，如果碰到这个Stream流里面的元素还有一个Stream流，就要调用方法去处理这个Stream流。而flatMap()会自动将Stream流里面的所有元素转换成一个流，再将所有流连接成一个流，这个流里面就不会有嵌套流了，也就自然可以一次性处理了。\n\n#### 排序\n\n```java\n@Test\npublic void test8() {\n    // 自然排序\n    List<Integer> list = Arrays.asList(1, 2, 5, 4, 3, 1);\n    list.stream().sorted().forEach(System.out::println);\n\n    // 定制排序，将employee的id按序排序。\n    List<Employee> employees = new ArrayList<>();\n    employees.add(new Employee(1));\n    employees.add(new Employee(3));\n    employees.add(new Employee(2));\n    employees.stream().sorted((e1, e2) ->\n            Integer.compare(e1.getId(), e2.getId())\n    ).forEach(System.out::println);\n}\n```\n\n排序比较简单，定制排序里面传一个Comparator的实例就可以了，这里我用的lambda表达式去实现的。\n\n## Stream的终结操作\n\n创建好Stream并进行一系列中间操作后，就可以进行终结操作了，之前一直使用到的forEach()其实就是一个终结操作。\n\n#### 匹配与查找\n\n![](https://pic.downk.cc/item/5ea91cd9c2a9a83be5fde4a8.jpg)\n\n![](https://pic.downk.cc/item/5ea92073c2a9a83be501bad0.jpg)\n\n```java\n@Test\npublic void test9() {\n    List<Employee> employees = new ArrayList<>();\n    employees.add(new Employee(1));\n    employees.add(new Employee(3));\n    employees.add(new Employee(2));\n\n    // allMatch(Predicate p)——检查是否匹配所有元素。\n    //  练习：是否所有的员工的年龄都大于18\n    boolean allMatch = employees.stream().allMatch(e -> e.getAge() > 18);\n\n    // anyMatch(Predicate p)——检查是否至少匹配一个元素。\n    // 练习：是否存在员工的工资大于 10000\n    boolean anyMatch = employees.stream().anyMatch(e -> e.getSalary() > 10000);\n\n    // noneMatch(Predicate p)——检查是否没有匹配的元素。\n    // 练习：是否存在员工姓“雷”\n    boolean noneMatch = employees.stream().noneMatch(e -> e.getName().startsWith(\"雷\"));\n\n    // findFirst——返回第一个元素\n    Optional<Employee> employee = employees.stream().findFirst();\n\n    // findAny——返回当前流中的任意元素\n    Optional<Employee> employee1 = employees.parallelStream().findAny();\n\n    // count——返回流中元素的总个数\n    // 练习：返回工资大于5000的员工的个数\n    long count = employees.stream().filter(e -> e.getSalary() > 5000).count();\n    System.out.println(count);\n    \n    // max(Comparator c)——返回流中最大值\n    // 练习：返回最高的工资：\n    Optional<Integer> maxSalary = employees.stream().map(e -> e.getSalary()).max(Integer::compare);\n    \n    // min(Comparator c)——返回流中最小值\n    // 练习：返回最低工资的员工\n    Optional<Employee> minSalary = employees.stream().min((e1, e2) -> Integer.compare(e1.getSalary(), e2.getSalary()));\n    \n    //  forEach(Consumer c)——内部迭代\n    employees.stream().forEach(System.out::println);\n\n    //使用集合的遍历操作\n    employees.forEach(System.out::println);\n\n}\n```\n\n#### 归约\n\n```java\n@Test\npublic void test10() {\n    List<Employee> employees = new ArrayList<>();\n    employees.add(new Employee(1));\n    employees.add(new Employee(3));\n    employees.add(new Employee(2));\n\n    // reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T\n    // 练习1：计算1-10的自然数的和\n    List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n    Integer sum = list.stream().reduce(0, Integer::sum);\n    list.stream().reduce(0, Integer::sum);\n\n\n    // reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional<T>\n    // 练习2：计算公司所有员工工资的总和\n    Stream<Integer> salaryStream = employees.stream().map(Employee::getSalary);\n    Optional<Integer> sumMoney = salaryStream.reduce(Integer::sum);\n\n}\n```\n\n#### 收集\n\n![image-20200429152631959](https://i.loli.net/2020/05/13/NawhCJceYb6nlGF.png)\n\nCollector接口中的方法实现了如何对流实现收集的操作（如List、Set、Map）。另外Collectors实用类中提供了很多静态方法，可以方便的创建常见收集器实例，详情见下表：\n\n![](https://pic.downk.cc/item/5ea92be7c2a9a83be50d88cd.jpg)\n\n![](https://pic.downk.cc/item/5ea92d58c2a9a83be50f2d28.jpg)\n\n```java\n@Test\npublic void test11() {\n    List<Employee> employees = new ArrayList<>();\n    employees.add(new Employee(1));\n    employees.add(new Employee(3));\n    employees.add(new Employee(2));\n    // collect(Collector c)——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法\n    // 练习：查找工资大于6000的员工，结果返回为一个List或Set\n    List<Employee> employeeList = employees.stream().filter(e -> e.getSalary() > 6000).collect(Collectors.toList());\n    employeeList.forEach(System.out::println);\n    \n    Set<Employee> employeeSet = employees.stream().filter(e -> e.getSalary() > 6000).collect(Collectors.toSet());\n    employeeSet.forEach(System.out::println);\n\n}\n```\n\n## 总结\n\n通过以上例子，可以熟悉Stream从创建到中间操作再到终结操作的使用方法。\n\n* 创建：从一个数据源（如集合、数组）获取一个流\n* 中间操作：一个中间操作链，对数据源的数据进行处理。\n* 终止操作：一旦执行终止操作，就执行中间操作链，并产生结果，之后不会再使用到。需要使用时只能再创建一个新的流。\n\n在使用Stream的时候需要注意以下几点：\n\n* Stream不会自己存储元素\n* Steam不会改变源对象，相反它们会返回一个持有新的对象的Stream。\n* Stream的操作是延迟执行的，这意味着它们会等到需要结果的时候才执行。\n\n","tags":["Stream流"],"categories":["Java8新特性"]},{"title":"Java8新特性之方法、构造器与数组引用","url":"/Java8新特性/Java8新特性之方法、构造器与数组引用","content":"\n当要传递给Lambda体的操作已经有实现的方法了，就可以使用方法引用去引用这个方法！\n\n<!--more-->\n\n### 方法引用\n\n方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。\n\n**要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致。**\n\n这样一说，可能还会很懵，来看下面这个例子吧：\n\n```java\n@Test\npublic void testMethodReferer() {\n    //常规写法\n    Consumer<String> consumer1 = new Consumer<String>() {\n        @Override\n        public void accept(String s) {\n            System.out.println(s);\n        }\n    };\n    consumer1.accept(\"常规写法~\");\n\n    // Lambda写法\n    Consumer<String> consumer2 = str -> System.out.println(str);\n    consumer2.accept(\"Lambda写法~\");\n\n    // 方法引用写法\n    // 我们注意到Consumer的accept方法是接收一个参数，没有返回值。\n    // void accept(T t)\n    // 我们经常使用的System.out.println()其实是一个PrintStream，它的print方法也刚好是接收一个参数，没有返回值。\n    // void print(T t)\n    // 所以我们可以引用PrintStream的print()方法，具体写法如下：\n    PrintStream printStream = System.out;\n    Consumer<String> consumer3 = printStream::println;\n    consumer3.accept(\"方法引用写法~\");\n}\n```\n\n`printStream::println`就是一个方法引用，格式是使用`::`将类（或对象）与方法名分隔开来。\n\n#### 方法引用的三种情况\n\n1. 对象 :: 非静态方法\n\n   这个就不过多解释了，和上面那个例子是一样的。\n\n   ```java\n   PrintStream printStream = System.out;\n   Consumer<String> consumer3 = printStream::println;\t\n   ```\n\n2. 类 :: 静态方法\n\n   ```java\n   @Test\n   public void testMethodReferer2(){\n       //Comparator中的int compare(T t1, T t2)\n       //Integer中的int compare(T t1, T t2)\n       //注意到这两个方法的返回值，参数类型都是一样的，那么我们就可以直接引用Integer中的compareTo方法。\n       Comparator<Integer> comparator1 = Integer::compareTo;\n       comparator1.compare(13,14);\n   }\n   ```\n\n3. 类 :: 非静态方法\n\n   什么？类还可以调用非静态方法？是的你没有听错，方法引用可以实现这点，但是这一点比较难理解！\n\n   ```java\n   @Test\n   public void testMethodReferer3(){\n       //Comparator中的int compare(T t1, T t2)\n       //String中的int t1.compareTo(t2)\n       //我们注意到虽然两者的返回值都是int，但是前者是两个参数，后者是一个参数，这不是违背了参数类型一致的原则吗？\n       //实际上因为String中t1调用了它的compareTo(t2)方法，也同样拥有t1和t2，所以我们可以当做它也是两个参数，t1和t2。\n       //所以我们可以这样写：\n       Comparator<String> comparator = String::compareTo;\n   }\n   ```\n\n   有点难理解，再来看一个例子吧：\n\n   ```java\n   @Test\n   public void testMethodReferer4() {\n       //BiPredicate中的boolean test(T t1, T t2)\n       //String中的boolean t1.equals(t2)\n       //所以我们可以这样写：\n       BiPredicate<String, String> biPredicate = String::equals;\n   }\n   ```\n\n### 构造器引用\n\n首先在`Employee`对象中有这样一个构造方法\n\n```java\npublic Employee() {\n    \n}\n```\n\n这次我们使用Supplier接口来举例，先来看看最原始的写法：\n\n```java\nSupplier<Employee> supplier1 = new Supplier<Employee>() {\n    @Override\n    public Employee get() {\n        return new Employee();\n    }\n};\n```\n\n从上面我们可以看出Supplier的get方法可以获取到Employee的实例对象。\n\n再用lambda表达式去实现上述代码：\n\n```java\nSupplier<Employee> supplier2 = () -> new Employee();\n```\n\n应该不难理解，最后来看构造器引用的写法：\n\n```java\nSupplier<Employee> supplier3 = Employee::new;\n```\n\n就直接使用一个`new`就搞定了，等同于引用了`Employee`中的构造器。\n\n但是如果`Employee`中的构造器是像下面这样是有参构造怎么办？\n\n```java\npublic Employee(int id) {\n    this.id = id;\n}\n```\n\n我们依旧可以使用构造器引用，看下面这段代码：\n\n```java\n@Test\npublic void testConstruct2() {\n    // 常规写法\n    Function<Integer, Employee> function1 = new Function<Integer, Employee>() {\n        @Override\n        public Employee apply(Integer integer) {\n            return new Employee(integer);\n        }\n    };\n\n    // lambda写法\n    Function<Integer, Employee> function2 = id -> new Employee(id);\n\n    // 构造器引用写法\n    Function<Integer, Employee> function3 = Employee::new;\n\n}\n```\n\n构造器引用的写法居然还是一样的，观察常规写法可以发现这个时候的 `apply(Integer integer)`中的`integer`就对应着`new Employee(integer)`中的`integer`，所以使用构造器引用写法的时候，就自动调用了有参构造方法了。\n\n### 数组引用\n\n如果理解了方法引用和构造器引用，那数组引用就非常简单了。\n\n```java\n@Test\npublic void testArrayReference() {\n    // lambda写法\n    Function<Integer, String[]> function1 = length -> new String[length];\n\n    // 数组引用写法\n    Function<Integer, String[]> function2 = String[]:new;\n}\n```\n\n### 总结\n\n方法引用说实话还是有点难以想到的，如果想不到就用lambda表达式吧，如果lambda表达式也没有想到，那就只能用原生的了。总之，熟能生巧！","categories":["Java8新特性"]},{"title":"Java8新特性之函数式接口","url":"/Java8新特性/Java8新特性之函数式接口","content":"\nJava从诞生日起就一直提倡”一切皆对象”，面向对象编程。但是后来随着python、scala等语言的兴起，为了适应更加广泛的技术要求。在Java8里，Java引进了面向函数编程，Java不仅支持OOP（面向对象编程），还支持OOF（面向函数编程）了！\n\n<!--more-->\n\n## 如何理解函数式接口\n\n**只包含一个抽象方法的接口，成为函数式接口。**\n\n我们可以通过lambda表达式来创建函数式接口的对象。\n\n在函数式编程语言中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，Lambda表达式是对象，而不是函数，它们必须依赖于一类特别的对象类型——**函数式接口**。\n\n简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。\n\n如`Runnable r2 = () -> System.out.println(\"Hello Lambda!\")`中，`=`右边的lambda表达式就是`Runnable`接口的实例。\n\n我们查看Runnable的源码，也可以发现它用`@FunctionalInterface`接口表明了这是一个函数式接口。\n\n![](https://pic.downk.cc/item/5ea56d8cc2a9a83be5f6d33d.png)\n\n也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用lambda表达式来表示。\n\n## Java内置的函数式接口介绍及使用举例\n\n在java.util.function包下定义了Java 8的丰富的函数式接口。\n\n![](https://pic.downk.cc/item/5ea56da2c2a9a83be5f6ef5f.png)\n\n![](https://pic.downk.cc/item/5ea56e84c2a9a83be5f7c6e0.jpg)\n\n### Consumer接口使用举例\n\n```Java\n@Test\npublic void testConsumer() {\n    // 常规写法\n    happyTime(500, new Consumer<Double>() {\n        @Override\n        public void accept(Double aDouble) {\n            System.out.println(\"今天学些太累了，去天上人间买了瓶水，花了我\" + aDouble);\n        }\n    });\n\n    //lambda写法\n    happyTime(500, money -> System.out.println(\"今天学些太累了，去天上人间买了瓶水，花了我\" + money));\n}\n```\n\n### Predicate接口使用举例\n\n```java\n@Test\npublic void testPredicate() {\n    List<String> original = Arrays.asList(\"北京\", \"南京\", \"天津\", \"东京\", \"普金\");\n    // 常规写法\n    List<String> result1 = filterString(original, new Predicate<String>() {\n        @Override\n        public boolean test(String s) {\n            return s.contains(\"京\");\n        }\n    });\n\n    //lambda写法\n    List<String> result2 = filterString(original, s -> s.contains(\"京\"));\n\n    System.out.println(result1.equals(result2));\n\n}\n\n//实现对字符串过滤的功能，过滤条件来源于对predicate中的test方法的重写。\npublic List<String> filterString(List<String> list, Predicate<String> predicate) {\n    List<String> filterList = new ArrayList<>();\n    for (String s : list) {\n        if (predicate.test(s)) {\n            filterList.add(s);\n        }\n    }\n    return filterList;\n}\n```\n\n\n\n## 结束语\n\n函数式接口就到此结束啦！要使用函数接口，就必须熟悉函数式接口内的抽象方法，不然就用不好Lambda表达式哦！\n","tags":["Java8","函数式接口"],"categories":["Java8新特性"]},{"title":"Java8新特性之Lambda表达式","url":"/Java8新特性/Java8新特性之Lambda表达式","content":"\nLambda表达式是一个**匿名函数**，我们可以把Lambda表达式理解为一段可以传递的代码，即将代码像数据一样传递。使用Lambda表达式可以缩减代码量，写出更简洁、更灵活的代码。\n\n<!--more-->\n\n## Lambda使用举例\n\n当我们在写Runnable时，可以采用常规的写法：\n\n```java\n // 常规写法\nRunnable r1 = new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"Hello Lambda!\");\n    }\n};\n```\n\n而我们采用Lambda写法一句话就搞定了，是不是简洁了一些呢？\n\n```java\n// Lambda写法\nRunnable r2 = () -> System.out.println(\"Hello Lambda!\");\n```\n\n再来看一个例子，当我们在写Comparator时，常规的写法是这样的：\n\n```java\n// 常规写法\nComparator<Integer> comparator1 = new Comparator<Integer>() {\n    @Override\n    public int compare(Integer o1, Integer o2) {\n        return Integer.compare(o1,o2);\n    }\n};\n```\n\n而我们采用Lambda表达式时，同样是一句话搞定！\n\n```java\n// Lambda写法\nComparator<Integer> comparator2 = (o1, o2) -> Integer.compare(o1, o2);\n```\n\n## Lambda的使用\n\n### 格式\n\n以`(o1, o2) -> Integer.compare(o1, o2)`来举例吧\n\n* `->`称作Lambda表达式操作符或者箭头操作符\n* `左边的(o1,02)`是Lambda的形参列表，对应常规写法中的compare(Integer o1, Integer o2)的o1和o2，其实就是接口中的抽象方法的形参列表，如果没有参数就用()替代。\n* `右边的Integer.compare(o1, o2)`是Lambda体，对应重写的抽象方法的方法体。\n\n### 语法\n\n1. 没有参数，没有返回值的时候：\n\n    ```java\n    Runnable r2 = () -> System.out.println(\"Hello Lambda!\");\n    ```\n\n2. 需要一个参数，但是没有返回值：\n\n    ```java\n    Consumer<String> consumer1 = (s) -> System.out.println(s);\n    ```\n\n3. 当然，lambda的形参也可以声明类型的，不过我们尽量能省就省，像这样就声明s为String类了：\n\n   ```java\n   Consumer<String> consumer1 = (String s) -> System.out.println(s);\n   ```\n   \n   lambda省略类型时，是可以推断出类型的，所以可以省略不写，我们称作：**类型推断**。\n\n4. 若形参只有一个参数，可以省略小括号：\n\n    ```\n    Consumer<String> consumer1 = s -> System.out.println(s);\n    ```\n    \n5. 如果方法体中有多条语句并且有返回值的时候，就要加个大括号了，像这样：\n\n    ```java\n    Comparator<Integer> comparator1 = (o1, o2) -> {\n        System.out.println(o1);\n        System.out.println(o2);\n        return Integer.compare(o1, o2);\n    };\n    ```\n\n6. 如果方法体中只有一条返回语句，我们甚至可以将return省掉！\n\n   ```java\n   Comparator<Integer> comparator2 = (o1, o2) -> Integer.compare(o1, o2);\n   ```\n\n\n\nLambda表达式的本质实际上是作为接口的实例，也就是一个对象，毕竟Java万物皆对象。\n\n","tags":["Lambda"],"categories":["Java8新特性"]},{"title":"解决idea卡在Resoving Maven dependencies的问题","url":"/idea/解决idea卡在Resoving Maven dependencies的问题","content":"\n由于本人也是从eclipse转idea不久，今天在建spring initializr的maven project的时候就出现了Resoving Maven dependencies这个问题。\n\n<!--more-->\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190814152226690.png)\n\n\n\n## 解决方案\n\n1.检查自己的maven项目配置，是否是使用自己本地的maven。因为如果没有默认配置maven，每次新建工程时候，maven的配置都会被初始化。\n\n**点击File-Other Settings-Default Settings**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190814152609852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hleVl1bg==,size_16,color_FFFFFF,t_70)\n\t**在弹出来的设置窗口搜索maven**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190814152818512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hleVl1bg==,size_16,color_FFFFFF,t_70)\n\t**检查maven的配置是否正确**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019081415290096.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hleVl1bg==,size_16,color_FFFFFF,t_70)\n**如果不正确，修改maven目录为自己的本地maven目录，并正确settings.xml即可解决问题。\n前提是settings.xml内配置了阿里云的镜像仓库。**\n\n2.如果配置是正确的，且仍然卡在Resoving Maven dependencies。可以尝试以下解决方案。\n**修改maven Importing的jvm参数, 默认为700多, 直接修改成 -Xms1024m -Xmx2048m**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190814153334666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hleVl1bg==,size_16,color_FFFFFF,t_70)\n## 总结\nmaven加载jar包过慢的因素有很多\n1.正确配置maven目录下conf文件内的settings.xml文件，主要是要配置好阿里云的镜像仓库，方法可自行百度。\n2.idea每次新建工程时都会初始化maven配置，可修改默认的maven配置解决问题。\n3.修改maven Importing的jvm参数。\n4.如果还未解决问题，欢迎留言！","tags":["idea","Maven"],"categories":["idea"]},{"title":"Git的工作区、暂存区和版本库分别是什么？","url":"/Git/Git的工作区、暂存区和版本库分别是什么？","content":"\n### 工作区\n\ngit的**工作区**就是我们本机的目录，在电脑文件资源管理器中可以真实查看到的目录，如下图所示，我所创建的test目录就是一个**工作区**。\n\n<!--more-->\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190905163140202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hleVl1bg==,size_16,color_FFFFFF,t_70)\n\n### 暂存区\ngit相比较其他版本控制工具有一个比较独特的东西，那就是**暂存区**。\n顾名思义，暂存区就是暂时存放文件的地区，那么什么文件将被存放在暂存区呢？\n相信我们会经常用到`git add`这条命令，这条命令可以将工作区中的文件加入到**暂存区**。\n例如：\n在test目录中我已经创建了一个readme.txt，然后我在git bash中使用`git add readme.txt`这条命令，那么readme.txt文件就被添加到**暂存区**了。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190905163424401.png)\n### 版本库\n相信安装了git的你一定发现会多一个.git的目录，这个目录就是git的**版本库**，版本库中存了很多东西，其中就包含我们刚讲的暂存区，还有Git为我们自动创建的第一个分支master。\n当我们使用`git commit`时，就会将暂存区的所有内容提交至master分支，如果有多个分子，就将暂存区的所有内容提交至当前分支。\n看看下面这个图，你应该能更加理解一些（图片来自[廖雪峰的官方网站](https://www.liaoxuefeng.com)）\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190905163927291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hleVl1bg==,size_16,color_FFFFFF,t_70)\n**简而言之，工作区、暂存区和版本库三者的联系就是你把已经修改的文件先从工作区添加至暂存区，然后再提交的版本库中。**","tags":["Git"],"categories":["Git"]}]